<!DOCTYPE html>
<html lang="tr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Profesyonel Fotoğraf Editörü ve Kolaj</title>
    
    <script src="https://cdn.tailwindcss.com"></script>
    
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://css.gg/css" rel="stylesheet" />
    <link href="https://fonts.googleapis.com/css2?family=Caveat:wght@500&family=Inter:wght@400;500;600;700&family=Playfair+Display:wght@700&family=Roboto+Mono&family=Poppins:wght@400;700&family=Oswald:wght@700&family=Lobster&family=Pacifico&family=Bebas+Neue&family=Anton&family=Dancing+Script:wght@700&family=Shadows+Into+Light&family=Kanit:wght@400;700&family=Montserrat:wght@400;700&display=swap" rel="stylesheet">
    <style>
        body { 
            font-family: 'Inter', sans-serif; 
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: #1a202c;
        }

        .glass-card {
            background: rgba(255, 255, 255, 0.15);
            -webkit-backdrop-filter: blur(20px) saturate(180%);
            backdrop-filter: blur(20px) saturate(180%);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .control-section { padding-top: 1.5rem; margin-top: 1.5rem; border-top: 1px solid rgba(255, 255, 255, 0.2); }
        .focus-ring:focus { box-shadow: 0 0 0 3px rgba(124, 58, 237, 0.5); outline: none; }
        .mode-btn, .fit-btn, .layout-btn, .pattern-btn { background-color: rgba(0, 0, 0, 0.1); color: #e2e8f0; transition: all 0.2s ease-in-out; }
        .mode-btn:hover, .fit-btn:hover, .layout-btn:hover, .pattern-btn:hover { background-color: rgba(0, 0, 0, 0.2); }
        .mode-btn.active, .fit-btn.active, .layout-btn.active, .pattern-btn.active { background-color: rgba(20, 10, 50, 0.6); color: white; box-shadow: 0 4px 15px -1px rgba(0, 0, 0, 0.2); }
        .upload-area { transition: all 0.2s ease-in-out; border-color: rgba(255, 255, 255, 0.3);}
        .upload-area.drag-over { border-color: #a78bfa; background-color: rgba(167, 139, 250, 0.2); }

        select, input[type="text"], input[type="number"] { background-color: rgba(0, 0, 0, 0.15); border: 1px solid rgba(255, 255, 255, 0.2); color: white; }
        select option { background: #2d3748; color: white; }
        ::placeholder { color: #a0aec0; }
        
        input[type="color"] { -webkit-appearance: none; -moz-appearance: none; appearance: none; width: 100%; height: 40px; padding: 0; border: 1px solid rgba(255, 255, 255, 0.2); border-radius: 0.5rem; background-color: transparent; cursor: pointer; }
        input[type="color"]::-webkit-color-swatch-wrapper { padding: 4px; }
        input[type="color"]::-webkit-color-swatch { border: none; border-radius: 0.375rem; }

        input[type=range] { -webkit-appearance: none; background: transparent; width: 100%; }
        input[type=range]:focus { outline: none; }
        input[type=range]::-webkit-slider-runnable-track { width: 100%; height: 6px; cursor: pointer; background: rgba(0, 0, 0, 0.2); border-radius: 3px; }
        input[type=range]::-webkit-slider-thumb { -webkit-appearance: none; height: 20px; width: 20px; border-radius: 50%; background: #f7fafc; cursor: pointer; margin-top: -7px; box-shadow: 0 0 5px rgba(0,0,0,0.3); transition: transform .1s ease-in-out; }
        input[type=range]::-webkit-slider-thumb:hover { transform: scale(1.1); }
        input[type=range]::-moz-range-track { width: 100%; height: 6px; cursor: pointer; background: rgba(0, 0, 0, 0.2); border-radius: 3px; }
        input[type=range]::-moz-range-thumb { height: 20px; width: 20px; border-radius: 50%; background: #f7fafc; cursor: pointer; }

        .peer:checked ~ label { background-color: rgba(20, 10, 50, 0.6); color: white; border-color: transparent; }

        /* Polaroid Çerçeve Stilleri */
        .frame-btn { border: 2px solid transparent; transition: all 0.2s ease-in-out; overflow: hidden; }
        .frame-btn.active { border-color: #a78bfa; transform: scale(1.05); box-shadow: 0 0 15px rgba(167, 139, 250, 0.5); }
        .frame-preview { width: 60px; height: 72px; border: 2px solid #4a5568; background-size: cover; background-position: center; }
        .frame-preview-img { width: 80%; height: 70%; background: #718096; }

        /* Modal Stilleri */
        .modal-overlay { transition: opacity 0.3s ease; }
        .modal-content { transition: transform 0.3s ease; }
        
        /* Toast Bildirim Stilleri */
        #toast {
            position: fixed; bottom: -100px; left: 50%; transform: translateX(-50%);
            transition: bottom 0.5s ease-in-out; z-index: 100;
        }
        #toast.show { bottom: 30px; }

        /* Kolaj Sıralama ve Silme Stilleri */
        #collageThumbnailsContainer {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            padding: 10px;
            border-radius: 0.5rem;
            background-color: rgba(0,0,0,0.1);
        }
        .thumbnail-item {
            position: relative;
            cursor: grab;
            border: 2px solid transparent;
            border-radius: 0.375rem;
            transition: transform 0.2s, border-color 0.2s;
        }
        .thumbnail-item img {
            width: 60px;
            height: 60px;
            object-fit: cover;
            border-radius: 0.25rem;
            display: block;
        }
        .thumbnail-item.dragging {
            opacity: 0.5;
            transform: scale(1.1);
            border-color: #a78bfa;
        }
        .thumbnail-item.drag-over-thumb {
            border-color: #c4b5fd;
        }
        .delete-thumb-btn {
            position: absolute;
            top: -8px;
            right: -8px;
            width: 24px;
            height: 24px;
            background-color: rgba(239, 68, 68, 0.9);
            color: white;
            border: 2px solid white;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            font-weight: bold;
            line-height: 1;
            cursor: pointer;
            opacity: 0;
            transform: scale(0.8);
            transition: opacity 0.2s, transform 0.2s;
            z-index: 10;
        }
        .thumbnail-item:hover .delete-thumb-btn {
            opacity: 1;
            transform: scale(1);
        }
    </style>
</head>
<body class="p-4 lg:p-8">

    <div class="w-full max-w-8xl mx-auto grid grid-cols-1 lg:grid-cols-2 lg:gap-8 xl:gap-12">
        
        <div class="w-full glass-card rounded-2xl shadow-xl p-6 md:p-8 h-max">
            <div class="space-y-6">
                <div class="text-center">
                    <h1 class="text-3xl md:text-4xl font-bold text-white">Profesyonel Editör</h1>
                    <p class="mt-2 text-gray-300">Fotoğraflarınıza sanatsal dokunuşlar katın.</p>
                </div>
                
                <div class="grid grid-cols-3 md:grid-cols-7 gap-2 p-1 bg-black/10 rounded-lg">
                     <button id="singleModeBtn" class="mode-btn active py-2 rounded-md font-semibold text-sm">Tekli</button>
                     <button id="collageModeBtn" class="mode-btn py-2 rounded-md font-semibold text-sm">Kolaj</button>
                     <button id="polaroidModeBtn" class="mode-btn py-2 rounded-md font-semibold text-sm">Polaroid</button>
                     <button id="magnifyModeBtn" class="mode-btn py-2 rounded-md font-semibold text-sm">Büyüteç</button>
                     <button id="doubleExposureModeBtn" class="mode-btn py-2 rounded-md font-semibold text-sm">Çift Pozlama</button>
                     <button id="lightEffectModeBtn" class="mode-btn py-2 rounded-md font-semibold text-sm">Işık Efekti</button>
                     <button id="popOutModeBtn" class="mode-btn py-2 rounded-md font-semibold text-sm">Pop-Out</button>
                </div>

                <div class="space-y-4">
                    <div>
                        <label id="imageLoaderLabel" class="block text-sm font-medium text-gray-200 mb-2">1. Fotoğraf Seçin</label>
                        <div id="singleUploader" class="upload-area p-4 border-2 border-dashed rounded-lg text-center">
                             <input type="file" id="imageLoader" accept="image/*" class="block w-full text-sm text-gray-300 file:mr-4 file:py-2 file:px-4 file:rounded-lg file:border-0 file:text-sm file:font-semibold file:bg-violet-500/30 file:text-violet-50 hover:file:bg-violet-500/50 cursor-pointer focus-ring rounded-lg">
                        </div>
                        <div id="collageUploader" class="hidden">
                            <div class="upload-area p-4 border-2 border-dashed rounded-lg text-center mb-4">
                                <input type="file" id="collageImageLoader" accept="image/*" multiple class="block w-full text-sm text-gray-300 file:mr-4 file:py-2 file:px-4 file:rounded-lg file:border-0 file:text-sm file:font-semibold file:bg-purple-500/30 file:text-purple-50 hover:file:bg-purple-500/50 cursor-pointer focus-ring rounded-lg">
                            </div>
                            <div id="collageThumbnailsWrapper" class="hidden">
                                <label class="block text-sm font-medium text-gray-200 mb-2">Resimleri Sırala (Sürükle) veya Sil (X)</label>
                                <div id="collageThumbnailsContainer"></div>
                            </div>
                        </div>
                         <div id="doubleExposureUploader" class="hidden space-y-4">
                            <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                                <div>
                                    <label for="bottomImageLoader" class="block text-xs font-medium text-gray-200 mb-1">Alt Katman</label>
                                    <input type="file" id="bottomImageLoader" accept="image/*" class="block w-full text-sm text-gray-300 file:mr-4 file:py-2 file:px-4 file:rounded-lg file:border-0 file:text-sm file:font-semibold file:bg-blue-500/30 file:text-blue-50 hover:file:bg-blue-500/50 cursor-pointer focus-ring rounded-lg">
                                </div>
                                <div>
                                    <label for="topImageLoader" class="block text-xs font-medium text-gray-200 mb-1">Üst Katman</label>
                                    <input type="file" id="topImageLoader" accept="image/*" class="block w-full text-sm text-gray-300 file:mr-4 file:py-2 file:px-4 file:rounded-lg file:border-0 file:text-sm file:font-semibold file:bg-pink-500/30 file:text-pink-50 hover:file:bg-pink-500/50 cursor-pointer focus-ring rounded-lg">
                                </div>
                            </div>
                        </div>
                    </div>

                    <div id="settingsPanel" class="pt-4">
                        <h2 class="text-lg font-semibold text-gray-100 mb-4 text-center">2. Düzenleme Araçları</h2>

                        <div id="canvasSizeSettings">
                             <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
                                <div>
                                    <label for="sizePreset" class="text-xs text-gray-300 mb-2 block">Kanvas Boyutu</label>
                                    <select id="sizePreset" class="w-full h-12 px-3 rounded-lg focus-ring">
                                        <option value="original">Orijinal Boyut</option>
                                        <optgroup label="Sosyal Medya">
                                            <option value="square" selected>Kare Post (1:1 - 1080x1080)</option>
                                            <option value="portrait45">Dikey Post (4:5 - 1080x1350)</option>
                                            <option value="story">Hikaye/Reels (9:16 - 1080x1920)</option>
                                            <option value="horizontal">Yatay Post (1.91:1 - 1080x566)</option>
                                            <option value="profile">Profil Fotoğrafı (1:1 - 320x320)</option>
                                        </optgroup>
                                    </select>
                                </div>
                                <div id="fitFillContainer">
                                    <label class="text-xs text-gray-300 mb-2 block">Fotoğraf Yerleşimi</label>
                                    <div class="grid grid-cols-2 gap-2 p-1 bg-black/10 rounded-lg h-12 items-center">
                                         <button id="fitContainBtn" class="fit-btn active py-2 rounded-md font-semibold text-sm">Sığdır</button>
                                         <button id="fitCoverBtn" class="fit-btn py-2 rounded-md font-semibold text-sm">Doldur</button>
                                    </div>
                                </div>
                            </div>
                        </div>
                        
                        <div id="imageAdjustments" class="control-section">
                             <label class="block text-sm font-medium text-gray-200">Genel Ayarlamalar</label>
                             <div class="mt-4">
                                <div class="flex justify-between items-center mb-1"><label for="exposure" class="text-xs text-gray-300">Pozlama</label><span id="exposureValue" class="text-sm font-semibold text-violet-300">0</span></div>
                                <input type="range" id="exposure" value="0" min="-100" max="100" class="w-full">
                             </div>
                        </div>

                        <div id="backgroundStyleSettings">
                            <div class="control-section">
                                <label class="block text-sm font-medium text-gray-200 mb-2">Arkaplan Stili</label>
                                <div class="grid grid-cols-4 gap-2">
                                    <div><input type="radio" name="bgType" id="bgSolid" value="solid" checked class="hidden peer"><label for="bgSolid" class="block text-center cursor-pointer rounded-lg border border-white/20 p-2 text-gray-200 text-sm">Renk</label></div>
                                    <div><input type="radio" name="bgType" id="bgGradient" value="gradient" class="hidden peer"><label for="bgGradient" class="block text-center cursor-pointer rounded-lg border border-white/20 p-2 text-gray-200 text-sm">Gradyan</label></div>
                                    <div><input type="radio" name="bgType" id="bgBlur" value="blur" class="hidden peer"><label for="bgBlur" class="block text-center cursor-pointer rounded-lg border border-white/20 p-2 text-gray-200 text-sm">Bulanık</label></div>
                                    <div><input type="radio" name="bgType" id="bgTransparent" value="transparent" class="hidden peer"><label for="bgTransparent" class="block text-center cursor-pointer rounded-lg border border-white/20 p-2 text-gray-200 text-sm">Transparan</label></div>
                                </div>
                                <div id="colorPickers" class="mt-4 grid grid-cols-2 gap-4">
                                    <input type="color" id="color1" value="#000000">
                                    <input type="color" id="color2" value="#4a5568" class="hidden">
                                </div>
                                <div id="blurAmountContainer" class="mt-4 hidden">
                                    <div class="flex justify-between items-center mb-1"><label for="bgBlurAmount" class="text-xs text-gray-300">Bulanıklık Seviyesi</label><span id="bgBlurAmountValue" class="text-sm font-semibold text-violet-300">15</span></div>
                                    <input type="range" id="bgBlurAmount" min="0" max="50" value="15" class="w-full">
                                </div>
                            </div>
                        </div>

                        <div id="standardSettings">
                            <div class="control-section">
                                 <label class="block text-sm font-medium text-gray-200">Dış Kenar Boşlukları (Padding)</label>
                                 <div class="flex items-center justify-start mt-2 mb-4"><input type="checkbox" id="syncPadding" checked class="h-4 w-4 rounded border-gray-500 text-violet-400 bg-transparent focus:ring-violet-500"><label for="syncPadding" class="ml-2 block text-sm text-gray-200">Tümünü eşitle</label></div>
                                <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-x-6 gap-y-4">
                                    <div><div class="flex justify-between items-center mb-1"><label for="paddingTop" class="text-xs text-gray-300">Üst</label><span id="paddingTopValue" class="text-sm font-semibold text-violet-300">0px</span></div><input type="range" id="paddingTop" value="0" min="0" max="300" class="padding-slider w-full"></div>
                                    <div><div class="flex justify-between items-center mb-1"><label for="paddingRight" class="text-xs text-gray-300">Sağ</label><span id="paddingRightValue" class="text-sm font-semibold text-violet-300">0px</span></div><input type="range" id="paddingRight" value="0" min="0" max="300" class="padding-slider w-full"></div>
                                    <div><div class="flex justify-between items-center mb-1"><label for="paddingBottom" class="text-xs text-gray-300">Alt</label><span id="paddingBottomValue" class="text-sm font-semibold text-violet-300">0px</span></div><input type="range" id="paddingBottom" value="0" min="0" max="300" class="padding-slider w-full"></div>
                                    <div><div class="flex justify-between items-center mb-1"><label for="paddingLeft" class="text-xs text-gray-300">Sol</label><span id="paddingLeftValue" class="text-sm font-semibold text-violet-300">0px</span></div><input type="range" id="paddingLeft" value="0" min="0" max="300" class="padding-slider w-full"></div>
                                </div>
                            </div>
                        </div>
                        
                        <div id="polaroidSettings" class="hidden">
                            <div class="control-section">
                                <label class="block text-sm font-medium text-gray-200 mb-3">Çerçeve Stili</label>
                                <div id="polaroidFrameContainer" class="grid grid-cols-3 sm:grid-cols-4 lg:grid-cols-5 gap-4">
                                    <!-- Çerçeveler JS ile eklenecek -->
                                </div>
                            </div>
                            <div class="control-section" id="polaroidColorSection">
                                <label for="polaroidFrameColor" class="block text-sm font-medium text-gray-200 mb-2">Çerçeve Rengi</label>
                                <input type="color" id="polaroidFrameColor" value="#ffffff">
                            </div>
                             <div class="control-section">
                                <label for="polaroidText" class="block text-sm font-medium text-gray-200 mb-2">El Yazısı Not</label>
                                <input type="text" id="polaroidText" placeholder="Kısa bir not ekle..." class="w-full p-2 rounded-lg" style="font-family: 'Caveat', cursive; font-size: 20px;">
                            </div>
                             <div class="control-section">
                                <label for="polaroidRotation" class="block text-sm font-medium text-gray-200 mb-2">Döndürme Açısı</label>
                                <input type="range" id="polaroidRotation" min="-15" max="15" value="5" class="w-full">
                            </div>
                             <div class="control-section">
                                <label for="polaroidZoom" class="block text-sm font-medium text-gray-200 mb-2">Yakınlaştırma</label>
                                <input type="range" id="polaroidZoom" min="100" max="300" value="100" class="w-full">
                            </div>
                        </div>
                        
                        <div id="magnifySettings" class="hidden">
                            <div class="control-section space-y-4 text-gray-200 text-sm">
                                <div>
                                    <label for="magnifyBlur" class="block mb-1">Arkaplan Bulanıklığı</label>
                                    <input type="range" id="magnifyBlur" min="0" max="40" value="10" class="w-full">
                                </div>
                                <div>
                                    <label for="magnifyZoom" class="block mb-1">Çerçeve İçi Yakınlaştırma</label>
                                    <input type="range" id="magnifyZoom" min="1" max="5" value="1.5" step="0.1" class="w-full">
                                </div>
                                <div class="grid grid-cols-2 gap-4">
                                    <div>
                                        <label for="magnifyFrameWidth" class="block mb-1">Çerçeve Genişliği</label>
                                        <input type="range" id="magnifyFrameWidth" min="100" max="1000" value="300" class="w-full">
                                    </div>
                                    <div>
                                        <label for="magnifyFrameHeight" class="block mb-1">Çerçeve Yüksekliği</label>
                                        <input type="range" id="magnifyFrameHeight" min="100" max="1000" value="450" class="w-full">
                                    </div>
                                </div>
                                <div class="grid grid-cols-2 gap-4">
                                     <div>
                                        <label for="magnifyBorderWidth" class="block mb-1">Çerçeve Kalınlığı</label>
                                        <input type="range" id="magnifyBorderWidth" min="0" max="50" value="10" class="w-full">
                                    </div>
                                    <div>
                                        <label for="magnifyBorderColor" class="block mb-1">Çerçeve Rengi</label>
                                        <input type="color" id="magnifyBorderColor" value="#ffffff">
                                    </div>
                                </div>
                            </div>
                        </div>

                        <div id="collageSettings" class="hidden control-section">
                             <label class="block text-sm font-medium text-gray-200 mb-4">Kolaj Ayarları</label>
                             <div class="grid grid-cols-1 gap-6 text-gray-300 text-xs">
                                <div>
                                    <label class="mb-1 block">İç Boşluk (Gap)</label>
                                    <input type="range" id="collageGap" value="10" min="0" max="100" class="w-full">
                                </div>
                                <div>
                                    <label class="mb-1 block">Köşe Yumuşatma</label>
                                    <input type="range" id="cornerRadius" min="0" max="100" value="0" class="w-full">
                                </div>
                                <div>
                                    <label class="mb-2 block">Kolaj Yerleşimi</label>
                                    <div class="flex flex-wrap gap-2" id="collageLayoutContainer">
                                        <button data-layout="auto" class="layout-btn active text-sm px-3 py-1 rounded">Oto</button>
                                        <button data-layout="grid" class="layout-btn text-sm px-3 py-1 rounded">Izgara</button>
                                        <button data-layout="masonry" class="layout-btn text-sm px-3 py-1 rounded">Masonry</button>
                                        <button data-layout="asym-mosaic" class="layout-btn text-sm px-3 py-1 rounded">Asimetrik</button>
                                        <button data-layout="hero" class="layout-btn text-sm px-3 py-1 rounded">Hero</button>
                                        <button data-layout="center-focus" class="layout-btn text-sm px-3 py-1 rounded">Odak</button>
                                        <button data-layout="center-circle" class="layout-btn text-sm px-3 py-1 rounded">Dairesel</button>
                                        <button data-layout="film-strip" class="layout-btn text-sm px-3 py-1 rounded">Film Şeridi</button>
                                        <button data-layout="scattered-polaroids" class="layout-btn text-sm px-3 py-1 rounded">Dağınık</button>
                                        <button data-layout="columns" class="layout-btn text-sm px-3 py-1 rounded">Sütun</button>
                                        <button data-layout="rows" class="layout-btn text-sm px-3 py-1 rounded">Sıra</button>
                                        <button data-layout="mosaic" class="layout-btn text-sm px-3 py-1 rounded">Mozaik</button>
                                        <button data-layout="overlap" class="layout-btn text-sm px-3 py-1 rounded">Üst Üste</button>
                                        <button data-layout="diagonal" class="layout-btn text-sm px-3 py-1 rounded">Çapraz</button>
                                        <button data-layout="three-stack" class="layout-btn text-sm px-3 py-1 rounded">Üçlü Yığın</button>
                                        <button data-layout="pano" class="layout-btn text-sm px-3 py-1 rounded">Panoramik</button>
                                    </div>
                                </div>
                             </div>
                        </div>

                        <div id="doubleExposureSettings" class="hidden control-section">
                            <div class="grid grid-cols-1 gap-6 text-gray-300">
                                <div class="flex items-center justify-center">
                                    <button id="swapLayersBtn" class="bg-indigo-500/50 text-indigo-50 font-semibold py-2 px-4 rounded-lg hover:bg-indigo-500/70 transition-colors">
                                        Katmanları Değiştir
                                    </button>
                                </div>
                                <div>
                                    <label for="doubleExposureOpacity" class="mb-1 block text-sm">Üst Katman Opaklığı</label>
                                    <div class="flex items-center gap-4">
                                        <input type="range" id="doubleExposureOpacity" value="50" min="0" max="100" class="w-full">
                                        <span id="doubleExposureOpacityValue" class="text-sm font-semibold text-violet-300 w-12 text-center">50%</span>
                                    </div>
                                </div>
                                <div>
                                    <label for="blendMode" class="mb-1 block text-sm">Karışım Modu</label>
                                    <select id="blendMode" class="w-full h-12 px-3 rounded-lg focus-ring">
                                        <option value="source-over">Normal</option>
                                        <option value="screen" selected>Screen</option>
                                        <option value="multiply">Multiply</option>
                                        <option value="overlay">Overlay</option>
                                        <option value="lighten">Lighten</option>
                                        <option value="darken">Darken</option>
                                        <option value="color-dodge">Color Dodge</option>
                                        <option value="color-burn">Color Burn</option>
                                        <option value="hard-light">Hard Light</option>
                                        <option value="soft-light">Soft Light</option>
                                        <option value="difference">Difference</option>
                                        <option value="exclusion">Exclusion</option>
                                        <option value="hue">Hue</option>
                                        <option value="saturation">Saturation</option>
                                        <option value="color">Color</option>
                                        <option value="luminosity">Luminosity</option>
                                    </select>
                                </div>
                            </div>
                        </div>

                        <div id="lightEffectSettings" class="hidden control-section">
                            <div class="space-y-6 text-gray-200">
                                <div>
                                    <label class="block text-sm font-medium mb-3">Işık Deseni</label>
                                    <div id="lightPatternContainer" class="grid grid-cols-3 sm:grid-cols-5 gap-3">
                                        <!-- Desenler JS ile eklenecek -->
                                    </div>
                                </div>
                                 <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
                                    <div>
                                        <label for="lightEffectOpacity" class="mb-1 block text-sm">Yoğunluk (Opaklık)</label>
                                        <input type="range" id="lightEffectOpacity" value="100" min="0" max="100" class="w-full">
                                    </div>
                                    <div>
                                        <label for="lightEffectColor" class="mb-1 block text-sm">Işık Rengi</label>
                                        <input type="color" id="lightEffectColor" value="#FFFFFF">
                                    </div>
                                </div>
                                <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
                                    <div>
                                        <label for="lightEffectAngle" class="mb-1 block text-sm">Açı</label>
                                        <input type="range" id="lightEffectAngle" value="0" min="0" max="360" class="w-full">
                                    </div>
                                    <div>
                                        <label for="lightEffectScale" class="mb-1 block text-sm">Ölçek</label>
                                        <input type="range" id="lightEffectScale" value="100" min="20" max="300" class="w-full">
                                    </div>
                                </div>
                                <div>
                                    <label for="lightEffectBlendMode" class="mb-1 block text-sm">Karışım Modu</label>
                                    <select id="lightEffectBlendMode" class="w-full h-12 px-3 rounded-lg focus-ring">
                                        <option value="screen" selected>Screen (Önerilen)</option>
                                        <option value="color-dodge">Color Dodge (Daha Parlak)</option>
                                        <option value="overlay">Overlay</option>
                                        <option value="soft-light">Soft Light</option>
                                        <option value="hard-light">Hard Light</option>
                                        <option value="lighten">Lighten</option>
                                    </select>
                                </div>
                            </div>
                        </div>

                        <div id="popOutSettings" class="hidden control-section">
                            <div class="space-y-6 text-gray-200">
                                <div>
                                    <label for="popOutBackgroundEffect" class="block text-sm font-medium mb-2">Arkaplan Efekti</label>
                                    <select id="popOutBackgroundEffect" class="w-full h-12 px-3 rounded-lg focus-ring">
                                        <option value="grayscale" selected>Siyah & Beyaz</option>
                                        <option value="blur">Bulanık</option>
                                        <option value="sepia">Sepya</option>
                                        <option value="none">Efekt Yok</option>
                                    </select>
                                </div>
                                <div id="popOutBlurContainer" class="hidden pt-2">
                                    <div class="flex justify-between items-center mb-1">
                                        <label for="popOutBlurAmount" class="text-xs">Bulanıklık Seviyesi</label>
                                        <span id="popOutBlurAmountValue" class="text-sm font-semibold text-violet-300">10</span>
                                    </div>
                                    <input type="range" id="popOutBlurAmount" value="10" min="0" max="40" class="w-full">
                                </div>
                                <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
                                    <div>
                                        <label for="popOutSize" class="mb-1 block text-sm">Ön Plan Boyutu</label>
                                        <input type="range" id="popOutSize" value="70" min="20" max="95" class="w-full">
                                    </div>
                                    <div>
                                        <label for="popOutBorderWidth" class="mb-1 block text-sm">Kenar Kalınlığı</label>
                                        <input type="range" id="popOutBorderWidth" value="5" min="0" max="50" class="w-full">
                                    </div>
                                </div>
                                <div>
                                    <label for="popOutBorderColor" class="mb-1 block text-sm">Kenar Rengi</label>
                                    <input type="color" id="popOutBorderColor" value="#FFFFFF">
                                </div>
                                <div class="space-y-3">
                                    <label class="block text-sm font-medium">Metin Ayarları <span class="text-xs text-gray-400">(Metni taşımak için üzerine tıklayıp sürükleyin)</span></label>
                                    <input type="text" id="popOutText" placeholder="Metin ekleyin..." class="w-full p-2 rounded-lg">
                                    <select id="popOutFont" class="w-full p-2 rounded-lg">
                                        <option value="Playfair Display">Playfair Display</option>
                                        <option value="Poppins">Poppins</option>
                                        <option value="Oswald">Oswald</option>
                                        <option value="Lobster">Lobster</option>
                                        <option value="Pacifico">Pacifico</option>
                                        <option value="Bebas Neue">Bebas Neue</option>
                                        <option value="Anton">Anton</option>
                                        <option value="Dancing Script">Dancing Script</option>
                                        <option value="Shadows Into Light">Shadows Into Light</option>
                                        <option value="Kanit">Kanit</option>
                                        <option value="Montserrat">Montserrat</option>
                                    </select>
                                </div>
                            </div>
                        </div>

                        <div id="generalTools">
                            <div class="control-section">
                                <label class="block text-sm font-medium text-gray-200 mb-2">Metin Ekle</label>
                                <input type="text" id="textInput" placeholder="Metninizi buraya yazın..." class="w-full p-2 rounded-lg">
                                <div class="grid grid-cols-2 md:grid-cols-4 gap-4 mt-4">
                                    <input type="color" id="textColor" value="#FFFFFF" title="Metin Rengi">
                                    <input type="number" id="textSize" value="48" title="Metin Boyutu" class="w-full p-2 rounded-lg">
                                    <select id="textFont" class="w-full p-2 rounded-lg">
                                        <option value="Inter">Inter</option>
                                        <option value="Playfair Display">Playfair</option>
                                        <option value="Roboto Mono">Mono</option>
                                        <option value="Caveat">Caveat</option>
                                    </select>
                                    <select id="textPosition" class="w-full p-2 rounded-lg">
                                        <option value="bottom-center">Alt-Orta</option>
                                        <option value="top-center">Üst-Orta</option>
                                        <option value="center-center">Orta</option>
                                    </select>
                                </div>
                            </div>

                            <div class="control-section">
                                <label class="block text-sm font-medium text-gray-200 mb-2">Filigran (Watermark)</label>
                                <input type="file" id="watermarkLoader" accept="image/png, image/jpeg" class="block w-full text-sm text-gray-300 file:mr-4 file:py-2 file:px-4 file:rounded-lg file:border-0 file:text-sm file:font-semibold file:bg-teal-500/30 file:text-teal-50 hover:file:bg-teal-500/50 cursor-pointer rounded-lg">
                                <div id="watermarkControls" class="hidden grid grid-cols-2 md:grid-cols-4 gap-4 mt-4 text-xs text-gray-300">
                                     <div><label>Opaklık</label><input type="range" id="watermarkOpacity" min="0" max="100" value="50" class="w-full"></div>
                                     <div><label>Boyut</label><input type="range" id="watermarkSize" min="5" max="100" value="20" class="w-full"></div>
                                     <select id="watermarkPosition" class="w-full p-2 rounded-lg col-span-2">
                                        <option value="bottom-right">Sağ Alt</option>
                                        <option value="bottom-left">Sol Alt</option>
                                        <option value="top-right">Sağ Üst</option>
                                        <option value="top-left">Sol Üst</option>
                                        <option value="center">Orta</option>
                                     </select>
                                </div>
                            </div>
                        </div>

                    </div>
                </div>

                <div class="flex flex-col sm:flex-row items-center justify-between gap-4 pt-6 border-t border-white/20 mt-6">
                    <div class="flex gap-2">
                        <button id="undoBtn" disabled title="Geri Al" class="bg-black/20 text-white font-bold p-3 rounded-lg hover:bg-black/30 disabled:opacity-50 disabled:cursor-not-allowed"><i class="gg-undo"></i></button>
                        <button id="redoBtn" disabled title="İleri Al" class="bg-black/20 text-white font-bold p-3 rounded-lg hover:bg-black/30 disabled:opacity-50 disabled:cursor-not-allowed"><i class="gg-redo"></i></button>
                    </div>
                    <div class="flex-grow flex gap-2 w-full sm:w-auto">
                        <button id="saveProjectBtn" class="w-full bg-emerald-600 text-white font-bold py-3 px-4 rounded-lg hover:bg-emerald-700 disabled:bg-gray-500 disabled:cursor-not-allowed">Projeyi Kaydet</button>
                        <button id="loadProjectBtn" class="w-full bg-sky-600 text-white font-bold py-3 px-4 rounded-lg hover:bg-sky-700">Projelerim</button>
                    </div>
                    <button id="downloadBtn" disabled class="w-full sm:w-auto bg-violet-600 text-white font-bold py-3 px-4 rounded-lg hover:bg-violet-700 focus:outline-none focus:ring-4 focus:ring-violet-400 transition-all duration-300 disabled:bg-gray-500 disabled:cursor-not-allowed shadow-lg shadow-violet-500/50">
                        İndir
                    </button>
                </div>
            </div>
        </div>

        <div class="w-full lg:sticky lg:top-8 h-max">
            <div id="previewArea" class="glass-card rounded-2xl shadow-xl p-4 min-h-[400px] lg:min-h-[calc(100vh-4rem)] flex items-center justify-center">
                <div id="previewPlaceholder" class="text-center text-gray-400">
                    <svg xmlns="http://www.w3.org/2000/svg" class="mx-auto h-16 w-16" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="1" d="M4 16l4.586-4.586a2 2 0 012.828 0L16 16m-2-2l-1-1m6-3a9 9 0 11-18 0 9 9 0 0118 0z" /></svg>
                    <p class="font-semibold text-lg mt-4">Önizleme Alanı</p>
                    <p class="text-sm">Bir fotoğraf yüklediğinizde burada görünecektir.</p>
                </div>
                <div id="canvasWrapper" class="hidden w-full h-full items-center justify-center">
                    <canvas id="canvas" class="max-w-full max-h-full"></canvas>
                </div>
            </div>
        </div>
    </div>

    
<div id="projectsModal" class="modal-overlay fixed inset-0 bg-black bg-opacity-60 flex items-center justify-center p-4 z-50 hidden">
        <div class="modal-content glass-card w-full max-w-4xl rounded-2xl shadow-2xl p-6 md:p-8 transform scale-95">
            <div class="flex justify-between items-center mb-6">
                <h2 class="text-2xl font-bold text-white">Projelerim</h2>
                <button id="closeModalBtn" class="text-gray-300 hover:text-white text-3xl font-bold">&times;</button>
            </div>
            <div id="projectList" class="max-h-[60vh] overflow-y-auto pr-2">
                <!-- Projeler JS ile eklenecek -->
            </div>
        </div>
    </div>
    
    
<div id="toast" class="px-6 py-3 bg-emerald-500 text-white font-semibold rounded-lg shadow-lg">
        <p id="toastMessage"></p>
    </div>

    <script>
        // --- BU UYGULAMA GEMINI TARAFINDAN GELİŞTİRİLMİŞTİR ---
        // --- GÜNCELLEME: Işık efekti pozlama sorunu kullanıcı geri bildirimine göre düzeltildi. ---
        
        const imageLoader = document.getElementById('imageLoader');
        const collageImageLoader = document.getElementById('collageImageLoader');
        const bottomImageLoader = document.getElementById('bottomImageLoader');
        const topImageLoader = document.getElementById('topImageLoader');
        const downloadBtn = document.getElementById('downloadBtn');
        const saveProjectBtn = document.getElementById('saveProjectBtn');
        const loadProjectBtn = document.getElementById('loadProjectBtn');
        const undoBtn = document.getElementById('undoBtn');
        const redoBtn = document.getElementById('redoBtn');
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const allUIInputs = document.querySelectorAll('input, select');
        const previewPlaceholder = document.getElementById('previewPlaceholder');
        const canvasWrapper = document.getElementById('canvasWrapper');
        const projectsModal = document.getElementById('projectsModal');
        const closeModalBtn = document.getElementById('closeModalBtn');
        const projectListContainer = document.getElementById('projectList');
        const collageUploaderDiv = document.getElementById('collageUploader');
        const doubleExposureUploaderDiv = document.getElementById('doubleExposureUploader');
        const collageThumbnailsWrapper = document.getElementById('collageThumbnailsWrapper');
        const collageThumbnailsContainer = document.getElementById('collageThumbnailsContainer');
        const polaroidFrameContainer = document.getElementById('polaroidFrameContainer');
        const polaroidColorSection = document.getElementById('polaroidColorSection');
        const lightPatternContainer = document.getElementById('lightPatternContainer');
        const blurAmountContainer = document.getElementById('blurAmountContainer');

        let db;
        let state = {};
        let history = [];
        let historyIndex = -1;
        let mainImage = null;
        let topImage = null;
        let bottomImage = null;
        let collageImages = [];
        let watermarkImage = null;
        let originalFileName = 'fotoğraf';
        
        let isPanning = false;
        let isModifierDown = false;
        let panStart = { x: 0, y: 0 };
        let activePanTarget = { type: null, index: -1 };
        let initialImageOffset = { x: 0, y: 0 }; 
        let draggedThumbnailIndex = null;
        let frameImageAssets = {};
        
        let isDraggingMagnifyFrame = false;
        let magnifyDragOffset = { x: 0, y: 0 };
        
        let isDraggingPopOutText = false;
        let popOutTextDragOffset = { x: 0, y: 0 };

        const lightPatterns = {
            'blinds': { name: 'Jaluzi' },
            'window': { name: 'Pencere' },
            'lines': { name: 'Çizgiler' },
            'diagonal-lines': { name: 'Çapraz' },
            'grid': { name: 'Izgara' },
            'god-rays': { name: 'Hüzme' },
            'bokeh': { name: 'Bokeh' },
            'leak1': { name: 'Sızıntı 1' },
            'leak2': { name: 'Sızıntı 2' },
            'spotlight': { name: 'Spot Işığı' },
        };

        const presets = {
            'original': null, 
            'square': { width: 1080, height: 1080 }, 
            'portrait45': { width: 1080, height: 1350 },
            'story': { width: 1080, height: 1920 },
            'horizontal': { width: 1080, height: 566 },
            'profile': { width: 320, height: 320 }
        };
        
        const polaroidFrameSpecs = {
            'classic': { name: 'Klasik', type: 'color', defaultColor: '#ffffff', textColor: '#2d3748', layout: 'classic' },
            'equal': { name: 'Eşit Kenar', type: 'color', defaultColor: '#ffffff', textColor: '#2d3748', layout: 'equal' },
            'top-heavy': { name: 'Ters Polaroid', type: 'color', defaultColor: '#ffffff', textColor: '#2d3748', layout: 'top-heavy' },
            'dark': { name: 'Siyah', type: 'color', defaultColor: '#2d3748', textColor: '#e2e8f0', layout: 'classic' },
            'vintage': { name: 'Vintage', type: 'color', defaultColor: '#fffae5', textColor: '#5a4a3a', layout: 'classic' },
            'film-kare': { name: 'Film Karesi', type: 'special', value: '#000000', textColor: '#e0e0e0', layout: 'equal' },
            'sprocket-light': { name: 'Film Şeridi (Açık)', type: 'effect', effectColor: 'rgba(255,255,255,0.8)', layout: 'equal' },
            'sprocket-dark': { name: 'Film Şeridi (Koyu)', type: 'effect', effectColor: 'rgba(0,0,0,0.7)', layout: 'equal' },
            'watercolor': { name: 'Suluboya', type: 'pattern', value: 'https://www.toptal.com/designers/subtlepatterns/uploads/watercolor.png', textColor: '#3a5a78', layout: 'classic' },
            'floral': { name: 'Çiçekli', type: 'pattern', value: 'https://www.toptal.com/designers/subtlepatterns/uploads/flowers.png', textColor: '#2a4b2a', layout: 'classic' },
            'galaxy': { name: 'Galaksi', type: 'pattern', value: 'https://images.pexels.com/photos/1169754/pexels-photo-1169754.jpeg?auto=compress&cs=tinysrgb&w=1260&h=750&dpr=1', textColor: '#e0e0ff', layout: 'classic' },
            'grunge': { name: 'Eskitme', type: 'pattern', value: 'https://www.toptal.com/designers/subtlepatterns/uploads/paper-fibers.png', textColor: '#4a4a4a', layout: 'classic' },
        };
        
        Object.keys(polaroidFrameSpecs).forEach(key => {
            polaroidFrameSpecs[key].aspectRatio = 88 / 107;
            if (polaroidFrameSpecs[key].layout === 'classic') {
                 polaroidFrameSpecs[key].photoPadding = 0.05;
            }
        });

        function getDefaultState() {
            return {
                mode: 'single', fit: 'contain', sizePreset: 'square',
                padding: { top: 0, right: 0, bottom: 0, left: 0 }, syncPadding: true,
                bgType: 'solid', color1: '#000000', color2: '#4a5568', bgBlurAmount: 15,
                imageOffset: { x: 0, y: 0 },
                imageAdjustments: {
                    exposure: 0,
                },
                collage: { 
                    gap: 10, 
                    layout: 'auto',
                    cornerRadius: 0,
                    imageOffsets: []
                },
                polaroid: {
                    frame: 'classic',
                    frameColor: '#ffffff',
                    text: '',
                    rotation: 5,
                    zoom: 100
                },
                magnify: {
                    frameX: 100, frameY: 100,
                    frameW: 300, frameH: 450,
                    zoom: 1.5, blur: 10,
                    borderColor: '#ffffff', borderWidth: 10
                },
                doubleExposure: {
                    opacity: 50,
                    blendMode: 'screen',
                    topImageOffset: { x: 0, y: 0 },
                    bottomImageOffset: { x: 0, y: 0 }
                },
                lightEffect: {
                    pattern: 'blinds',
                    opacity: 100,
                    color: '#FFFFFF',
                    angle: 0,
                    scale: 100,
                    blendMode: 'screen',
                    offset: { x: 0, y: 0 }
                },
                popOut: {
                    backgroundEffect: 'grayscale',
                    size: 70,
                    borderWidth: 5,
                    borderColor: '#FFFFFF',
                    text: 'New Post',
                    font: 'Playfair Display',
                    textX: null,
                    textY: null,
                    blurAmount: 10 // Pop-out moduna özel bulanıklık değeri
                },
                text: { content: '', color: '#FFFFFF', size: 48, font: 'Inter', position: 'bottom-center' },
                watermark: { opacity: 50, size: 20, position: 'bottom-right' }
            };
        }
        
        function syncStateWithUI() {
            // Modu belirle
            const activeModeBtn = document.querySelector('.mode-btn.active');
            if (activeModeBtn) {
                state.mode = activeModeBtn.id.replace('ModeBtn', '');
            }

            // Tekli mod ayarları
            const newFit = document.getElementById('fitContainBtn').classList.contains('active') ? 'contain' : 'cover';
            if (state.fit !== newFit) state.imageOffset = { x: 0, y: 0 };
            state.fit = newFit;
            
            const newPreset = document.getElementById('sizePreset').value;
             if (state.sizePreset !== newPreset) {
                state.imageOffset = { x: 0, y: 0 };
                if(state.collage.imageOffsets) {
                    state.collage.imageOffsets.forEach(offset => { offset.x = 0; offset.y = 0; });
                }
                // Reset popout text position on canvas resize
                state.popOut.textX = null;
                state.popOut.textY = null;
            }
            state.sizePreset = newPreset;
            
            state.syncPadding = document.getElementById('syncPadding').checked;
            state.padding = {
                top: parseInt(document.getElementById('paddingTop').value, 10),
                right: parseInt(document.getElementById('paddingRight').value, 10),
                bottom: parseInt(document.getElementById('paddingBottom').value, 10),
                left: parseInt(document.getElementById('paddingLeft').value, 10)
            };
            state.bgType = document.querySelector('input[name="bgType"]:checked').value;
            state.color1 = document.getElementById('color1').value;
            state.color2 = document.getElementById('color2').value;
            state.bgBlurAmount = parseInt(document.getElementById('bgBlurAmount').value, 10);

            // Genel Ayarlamalar
            state.imageAdjustments.exposure = parseInt(document.getElementById('exposure').value, 10);
            
            // Kolaj ayarları
            state.collage.gap = parseInt(document.getElementById('collageGap').value, 10);
            state.collage.cornerRadius = parseInt(document.getElementById('cornerRadius').value, 10);
            state.collage.layout = document.querySelector('#collageLayoutContainer .active')?.dataset.layout;
            
            // Polaroid ayarları
            state.polaroid.frame = document.querySelector('#polaroidFrameContainer .active')?.dataset.frame;
            state.polaroid.frameColor = document.getElementById('polaroidFrameColor').value;
            state.polaroid.text = document.getElementById('polaroidText').value;
            state.polaroid.rotation = parseInt(document.getElementById('polaroidRotation').value, 10);
            state.polaroid.zoom = parseInt(document.getElementById('polaroidZoom').value, 10);

            // Büyüteç ayarları
            state.magnify = {
                frameX: state.magnify.frameX, // Pozisyon sürükleme ile güncellenir
                frameY: state.magnify.frameY,
                frameW: parseInt(document.getElementById('magnifyFrameWidth').value, 10),
                frameH: parseInt(document.getElementById('magnifyFrameHeight').value, 10),
                zoom: parseFloat(document.getElementById('magnifyZoom').value),
                blur: parseInt(document.getElementById('magnifyBlur').value, 10),
                borderColor: document.getElementById('magnifyBorderColor').value,
                borderWidth: parseInt(document.getElementById('magnifyBorderWidth').value, 10)
            };

            // Çift Pozlama ayarları
            state.doubleExposure.opacity = parseInt(document.getElementById('doubleExposureOpacity').value, 10);
            state.doubleExposure.blendMode = document.getElementById('blendMode').value;

            // Işık Efekti ayarları
            state.lightEffect.pattern = document.querySelector('#lightPatternContainer .active')?.dataset.pattern;
            state.lightEffect.opacity = parseInt(document.getElementById('lightEffectOpacity').value, 10);
            state.lightEffect.color = document.getElementById('lightEffectColor').value;
            state.lightEffect.angle = parseInt(document.getElementById('lightEffectAngle').value, 10);
            state.lightEffect.scale = parseInt(document.getElementById('lightEffectScale').value, 10);
            state.lightEffect.blendMode = document.getElementById('lightEffectBlendMode').value;

            // Pop-Out ayarları
            state.popOut.backgroundEffect = document.getElementById('popOutBackgroundEffect').value;
            state.popOut.size = parseInt(document.getElementById('popOutSize').value, 10);
            state.popOut.borderWidth = parseInt(document.getElementById('popOutBorderWidth').value, 10);
            state.popOut.borderColor = document.getElementById('popOutBorderColor').value;
            state.popOut.text = document.getElementById('popOutText').value;
            state.popOut.font = document.getElementById('popOutFont').value;
            state.popOut.blurAmount = parseInt(document.getElementById('popOutBlurAmount').value, 10);

            // Genel araçlar
            state.text = {
                content: document.getElementById('textInput').value,
                color: document.getElementById('textColor').value,
                size: parseInt(document.getElementById('textSize').value, 10),
                font: document.getElementById('textFont').value,
                position: document.getElementById('textPosition').value,
            };
            state.watermark = {
                opacity: parseInt(document.getElementById('watermarkOpacity').value, 10),
                size: parseInt(document.getElementById('watermarkSize').value, 10),
                position: document.getElementById('watermarkPosition').value,
            };
        }

        function updateUIFromState(s) {
            document.querySelectorAll('.mode-btn').forEach(btn => {
                const mode = btn.id.replace('ModeBtn', '');
                btn.classList.toggle('active', s.mode === mode);
            });

            const isMagnify = s.mode === 'magnify';
            const isPolaroid = s.mode === 'polaroid';
            const isCollage = s.mode === 'collage';
            const isSingle = s.mode === 'single';
            const isDoubleExposure = s.mode === 'doubleExposure';
            const isLightEffect = s.mode === 'lightEffect';
            const isPopOut = s.mode === 'popOut';

            const hasImage = mainImage || (collageImages && collageImages.length > 0) || (topImage && bottomImage);
            document.getElementById('imageAdjustments').style.display = hasImage ? 'block' : 'none';

            document.getElementById('canvasSizeSettings').style.display = !isPolaroid ? 'block' : 'none';
            document.getElementById('backgroundStyleSettings').style.display = isSingle || isCollage || isDoubleExposure ? 'block' : 'none';
            document.getElementById('standardSettings').style.display = isSingle || isCollage ? 'block' : 'none';
            document.getElementById('polaroidSettings').style.display = isPolaroid ? 'block' : 'none';
            document.getElementById('collageSettings').style.display = isCollage ? 'block' : 'none';
            document.getElementById('magnifySettings').style.display = isMagnify ? 'block' : 'none';
            document.getElementById('doubleExposureSettings').style.display = isDoubleExposure ? 'block' : 'none';
            document.getElementById('lightEffectSettings').style.display = isLightEffect ? 'block' : 'none';
            document.getElementById('popOutSettings').style.display = isPopOut ? 'block' : 'none';
            document.getElementById('generalTools').style.display = isSingle || isCollage ? 'block' : 'none';
            
            if (isPolaroid) {
                 const frameSpec = polaroidFrameSpecs[s.polaroid.frame];
                 polaroidColorSection.style.display = frameSpec && frameSpec.type === 'color' ? 'block' : 'none';
                 if (frameSpec && frameSpec.type === 'effect') {
                     document.getElementById('backgroundStyleSettings').style.display = 'none';
                 }
            }

            document.getElementById('fitFillContainer').style.visibility = (isSingle || isLightEffect || isPopOut) ? 'visible' : 'hidden';
            document.getElementById('colorPickers').style.display = s.bgType === 'transparent' ? 'none' : 'grid';
            document.getElementById('color2').style.display = s.bgType === 'gradient' ? 'block' : 'none';
            blurAmountContainer.style.display = s.bgType === 'blur' ? 'block' : 'none';


            document.getElementById('fitContainBtn').classList.toggle('active', s.fit === 'contain');
            document.getElementById('fitCoverBtn').classList.toggle('active', s.fit === 'cover');
            document.getElementById('sizePreset').value = s.sizePreset;
            
            document.getElementById('exposure').value = s.imageAdjustments.exposure;
            document.getElementById('exposureValue').textContent = s.imageAdjustments.exposure;

            document.getElementById('paddingTop').value = s.padding.top; 
            document.getElementById('paddingRight').value = s.padding.right; 
            document.getElementById('paddingBottom').value = s.padding.bottom; 
            document.getElementById('paddingLeft').value = s.padding.left;
            document.querySelectorAll('.padding-slider').forEach(sl => {
                document.getElementById(sl.id + 'Value').textContent = `${sl.value}px`;
            });

            document.getElementById('syncPadding').checked = s.syncPadding;
            ['bgSolid', 'bgGradient', 'bgBlur', 'bgTransparent'].forEach(id => {
                document.getElementById(id).checked = s.bgType === id.replace('bg', '').toLowerCase();
            });
            document.getElementById('color1').value = s.color1; 
            document.getElementById('color2').value = s.color2;
            document.getElementById('bgBlurAmount').value = s.bgBlurAmount;
            document.getElementById('bgBlurAmountValue').textContent = s.bgBlurAmount;
            
            document.getElementById('collageGap').value = s.collage.gap;
            document.getElementById('cornerRadius').value = s.collage.cornerRadius;
            document.querySelectorAll('#collageLayoutContainer button').forEach(b => b.classList.toggle('active', b.dataset.layout === s.collage.layout));
            
            document.querySelectorAll('#polaroidFrameContainer button').forEach(b => b.classList.toggle('active', b.dataset.frame === s.polaroid.frame));
            document.getElementById('polaroidFrameColor').value = s.polaroid.frameColor;
            document.getElementById('polaroidText').value = s.polaroid.text;
            document.getElementById('polaroidRotation').value = s.polaroid.rotation;
            document.getElementById('polaroidZoom').value = s.polaroid.zoom;
            
            document.getElementById('magnifyBlur').value = s.magnify.blur;
            document.getElementById('magnifyZoom').value = s.magnify.zoom;
            document.getElementById('magnifyFrameWidth').value = s.magnify.frameW;
            document.getElementById('magnifyFrameHeight').value = s.magnify.frameH;
            document.getElementById('magnifyBorderColor').value = s.magnify.borderColor;
            document.getElementById('magnifyBorderWidth').value = s.magnify.borderWidth;

            document.getElementById('doubleExposureOpacity').value = s.doubleExposure.opacity;
            document.getElementById('doubleExposureOpacityValue').textContent = `${s.doubleExposure.opacity}%`;
            document.getElementById('blendMode').value = s.doubleExposure.blendMode;

            document.querySelectorAll('#lightPatternContainer button').forEach(b => b.classList.toggle('active', b.dataset.pattern === s.lightEffect.pattern));
            document.getElementById('lightEffectOpacity').value = s.lightEffect.opacity;
            document.getElementById('lightEffectColor').value = s.lightEffect.color;
            document.getElementById('lightEffectAngle').value = s.lightEffect.angle;
            document.getElementById('lightEffectScale').value = s.lightEffect.scale;
            document.getElementById('lightEffectBlendMode').value = s.lightEffect.blendMode;

            // Pop-Out UI
            document.getElementById('popOutBackgroundEffect').value = s.popOut.backgroundEffect;
            document.getElementById('popOutSize').value = s.popOut.size;
            document.getElementById('popOutBorderWidth').value = s.popOut.borderWidth;
            document.getElementById('popOutBorderColor').value = s.popOut.borderColor;
            document.getElementById('popOutText').value = s.popOut.text;
            document.getElementById('popOutFont').value = s.popOut.font;
            document.getElementById('popOutBlurContainer').style.display = s.popOut.backgroundEffect === 'blur' ? 'block' : 'none';
            document.getElementById('popOutBlurAmount').value = s.popOut.blurAmount;
            document.getElementById('popOutBlurAmountValue').textContent = s.popOut.blurAmount;


            document.getElementById('textInput').value = s.text.content; 
            document.getElementById('textColor').value = s.text.color; 
            document.getElementById('textSize').value = s.text.size; 
            document.getElementById('textFont').value = s.text.font; 
            document.getElementById('textPosition').value = s.text.position;
            document.getElementById('watermarkOpacity').value = s.watermark.opacity; 
            document.getElementById('watermarkSize').value = s.watermark.size; 
            document.getElementById('watermarkPosition').value = s.watermark.position;
            
            document.getElementById('singleUploader').style.display = isSingle || isPolaroid || isMagnify || isLightEffect || isPopOut ? 'block' : 'none';
            collageUploaderDiv.style.display = isCollage ? 'block' : 'none';
            doubleExposureUploaderDiv.style.display = isDoubleExposure ? 'block' : 'none';

            document.getElementById('imageLoaderLabel').textContent = `1. ${isCollage ? 'Kolaj Fotoğrafları' : isDoubleExposure ? 'Katmanları Seçin' : 'Fotoğraf Seçin'}`;
            document.querySelector('#sizePreset option[value="original"]').disabled = isCollage || isPolaroid || isMagnify || isDoubleExposure || isLightEffect || isPopOut;
            if ((isPolaroid || isMagnify || isDoubleExposure || isLightEffect || isPopOut) && s.sizePreset === 'original') {
                s.sizePreset = 'square'; // Varsayılan boyut
                document.getElementById('sizePreset').value = 'square';
            }
        }

        function updateAndDraw(saveToHistory = true) {
            syncStateWithUI(); 
            if (saveToHistory) {
                saveStateToHistory();
            }
            updateUIFromState(state);
            drawPreview();

            const hasImage = mainImage || (state.mode === 'collage' && collageImages.length > 0) || (state.mode === 'doubleExposure' && topImage && bottomImage);
            saveProjectBtn.disabled = !hasImage;
            downloadBtn.disabled = !hasImage;
        }

        function saveStateToHistory() {
            history = history.slice(0, historyIndex + 1);
            // Don't save transient dragging states
            const stateToSave = JSON.parse(JSON.stringify(state));
            history.push(stateToSave);
            historyIndex++;
            updateUndoRedoButtons();
        }

        function undo() {
            if (historyIndex > 0) {
                historyIndex--;
                state = JSON.parse(JSON.stringify(history[historyIndex]));
                updateUIFromState(state);
                drawPreview();
                if(state.mode === 'collage') displayCollageThumbnails();
                updateUndoRedoButtons();
            }
        }

        function redo() {
            if (historyIndex < history.length - 1) {
                historyIndex++;
                state = JSON.parse(JSON.stringify(history[historyIndex]));
                updateUIFromState(state);
                drawPreview();
                if(state.mode === 'collage') displayCollageThumbnails();
                updateUndoRedoButtons();
            }
        }
        
        function updateUndoRedoButtons() {
            undoBtn.disabled = historyIndex <= 0;
            redoBtn.disabled = historyIndex >= history.length - 1;
        }
        
        function setupEventListeners() {
            document.querySelectorAll('.mode-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    const newMode = btn.id.replace('ModeBtn', '');
                    if (state.mode !== newMode) {
                        document.querySelector('.mode-btn.active').classList.remove('active');
                        btn.classList.add('active');
                        switchMode(newMode);
                    }
                });
            });
            
            document.getElementById('fitContainBtn').addEventListener('click', () => { setFitMode('contain'); });
            document.getElementById('fitCoverBtn').addEventListener('click', () => { setFitMode('cover'); });
            
            document.querySelectorAll('.padding-slider').forEach(s => s.addEventListener('input', handlePaddingSlider));
            document.getElementById('syncPadding').addEventListener('change', () => updateAndDraw());

            document.querySelectorAll('input[name="bgType"]').forEach(radio => radio.addEventListener('change', () => {
                updateAndDraw();
            }));

            document.querySelectorAll('#collageLayoutContainer button').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    document.querySelector('#collageLayoutContainer .active')?.classList.remove('active');
                    e.currentTarget.classList.add('active');
                    updateAndDraw();
                });
            });
            
            polaroidFrameContainer.addEventListener('click', (e) => {
                const button = e.target.closest('.frame-btn');
                if (button) {
                    document.querySelector('#polaroidFrameContainer .active')?.classList.remove('active');
                    button.classList.add('active');
                    
                    const frameKey = button.dataset.frame;
                    const frameSpec = polaroidFrameSpecs[frameKey];
                    
                    if (frameSpec.type === 'color') {
                        state.polaroid.frameColor = frameSpec.defaultColor;
                    } else if (frameSpec.type === 'effect') {
                        document.getElementById('bgBlur').checked = true;
                    }
                    
                    updateAndDraw();
                }
            });

            lightPatternContainer.addEventListener('click', (e) => {
                const button = e.target.closest('.pattern-btn');
                if (button) {
                    document.querySelector('#lightPatternContainer .active')?.classList.remove('active');
                    button.classList.add('active');
                    updateAndDraw();
                }
            });

            allUIInputs.forEach(el => {
                const eventType = (el.type === 'range' || el.type === 'color') ? 'input' : 'change';
                 if (!el.classList.contains('padding-slider')) {
                    el.addEventListener(eventType, () => updateAndDraw(el.type !== 'range'));
                }
            });
            
            imageLoader.addEventListener('change', (e) => handleImageUpload(e.target.files[0]));
            collageImageLoader.addEventListener('change', (e) => handleCollageUpload(e.target.files));
            topImageLoader.addEventListener('change', (e) => handleLayerUpload(e.target.files[0], 'top'));
            bottomImageLoader.addEventListener('change', (e) => handleLayerUpload(e.target.files[0], 'bottom'));
            document.getElementById('swapLayersBtn').addEventListener('click', swapLayers);
            document.getElementById('watermarkLoader').addEventListener('change', handleWatermarkUpload);

            document.body.addEventListener('drop', e => { e.preventDefault(); e.stopPropagation(); });
            document.body.addEventListener('dragover', e => { e.preventDefault(); e.stopPropagation(); });

            document.querySelector('#singleUploader').addEventListener('drop', e => {
                 e.preventDefault(); e.stopPropagation(); e.currentTarget.classList.remove('drag-over');
                handleImageUpload(e.dataTransfer.files[0]);
            });
            document.querySelector('#collageUploader .upload-area').addEventListener('drop', e => {
                e.preventDefault(); e.stopPropagation(); e.currentTarget.classList.remove('drag-over');
                handleCollageUpload(e.dataTransfer.files);
            });

            downloadBtn.addEventListener('click', downloadImage);
            saveProjectBtn.addEventListener('click', saveProject);
            loadProjectBtn.addEventListener('click', showProjectsModal);
            closeModalBtn.addEventListener('click', hideProjectsModal);
            projectsModal.addEventListener('click', (e) => { if(e.target === projectsModal) hideProjectsModal(); });
            undoBtn.addEventListener('click', undo);
            redoBtn.addEventListener('click', redo);
            
            window.addEventListener('keydown', e => { if (e.key === 'Meta' || e.key === 'Control') { isModifierDown = true; updateCursor(); } });
            window.addEventListener('keyup', e => { if (e.key === 'Meta' || e.key === 'Control') { isModifierDown = false; updateCursor(); } });
            
            canvasWrapper.addEventListener('mousedown', e => {
                const hasImage = mainImage || (state.mode === 'collage' && collageImages.length > 0) || (state.mode === 'doubleExposure' && topImage && bottomImage);
                if (!hasImage) return;

                const canvasRect = canvas.getBoundingClientRect();
                const mouse = {
                    x: (e.clientX - canvasRect.left) * (canvas.width / canvasRect.width),
                    y: (e.clientY - canvasRect.top) * (canvas.height / canvasRect.height)
                };
                panStart = { x: e.clientX, y: e.clientY };
                
                // Check for PopOut text drag first
                if (state.mode === 'popOut' && state.popOut.text) {
                    const metrics = getPopOutTextMetrics(canvas.width, canvas.height);
                    const textX = state.popOut.textX;
                    const textY = state.popOut.textY;
                    const textWidth = metrics.width;
                    const textHeight = metrics.actualBoundingBoxAscent + metrics.actualBoundingBoxDescent;

                    const x1 = textX - textWidth / 2;
                    const x2 = textX + textWidth / 2;
                    const y1 = textY - metrics.actualBoundingBoxAscent;
                    const y2 = textY + metrics.actualBoundingBoxDescent;

                    if (mouse.x >= x1 && mouse.x <= x2 && mouse.y >= y1 && mouse.y <= y2) {
                        isDraggingPopOutText = true;
                        popOutTextDragOffset = {
                            x: mouse.x - textX,
                            y: mouse.y - textY
                        };
                        canvasWrapper.style.cursor = 'grabbing';
                        return; // Prioritize text dragging
                    }
                }

                if (isModifierDown) {
                    if (state.mode === 'lightEffect') {
                        isPanning = true;
                        activePanTarget = { type: 'lightEffect' };
                        initialImageOffset = { ...state.lightEffect.offset };
                        canvasWrapper.style.cursor = 'grabbing';
                    } else if (['single', 'polaroid', 'magnify', 'popOut'].includes(state.mode)) {
                        isPanning = true;
                        activePanTarget = { type: 'main' };
                        initialImageOffset = { ...state.imageOffset };
                        canvasWrapper.style.cursor = 'grabbing';
                    } else if (state.mode === 'doubleExposure') {
                        isPanning = true;
                        activePanTarget = { type: 'doubleExposure_top' };
                        initialImageOffset = { ...state.doubleExposure.topImageOffset };
                        canvasWrapper.style.cursor = 'grabbing';
                    } else if (state.mode === 'collage') { 
                        const p = state.padding;
                        const area = { x: p.left, y: p.top, w: canvas.width - p.left - p.right, h: canvas.height - p.top - p.bottom };
                        const layout = getCollageLayout(state.collage.layout, collageImages, area, state.collage.gap);
                        
                        let clickedIndex = -1;
                        for (let i = layout.length - 1; i >= 0; i--) {
                            const rect = layout[i];
                            let hit = false;
                            if (rect.rotation) {
                                const cx = rect.x + rect.w / 2; const cy = rect.y + rect.h / 2; const angle = -rect.rotation * Math.PI / 180;
                                const tmx = mouse.x - cx; const tmy = mouse.y - cy;
                                const rmx = tmx * Math.cos(angle) - tmy * Math.sin(angle); const rmy = tmx * Math.sin(angle) + tmy * Math.cos(angle);
                                if (rmx >= -rect.w / 2 && rmx <= rect.w / 2 && rmy >= -rect.h / 2 && rmy <= rect.h / 2) hit = true;
                            } else if (rect.shape === 'circle') {
                                const cx = rect.x + rect.w / 2; const cy = rect.y + rect.h / 2; const radius = Math.min(rect.w, rect.h) / 2;
                                const dist = Math.sqrt(Math.pow(mouse.x - cx, 2) + Math.pow(mouse.y - cy, 2));
                                if (dist <= radius) hit = true;
                            } else {
                                if (mouse.x >= rect.x && mouse.x <= rect.x + rect.w && mouse.y >= rect.y && mouse.y <= rect.y + rect.h) hit = true;
                            }
                            if (hit) { clickedIndex = i; break; }
                        }

                        if (clickedIndex > -1) {
                            isPanning = true;
                            activePanTarget = { type: 'collage', index: clickedIndex };
                            initialImageOffset = { ...state.collage.imageOffsets[clickedIndex] };
                            canvasWrapper.style.cursor = 'grabbing';
                        }
                    }
                } else if (state.mode === 'magnify') {
                    const { frameX, frameY, frameW, frameH } = state.magnify;
                    if (mouse.x > frameX && mouse.x < frameX + frameW && mouse.y > frameY && mouse.y < frameY + frameH) {
                        isDraggingMagnifyFrame = true;
                        magnifyDragOffset = { x: mouse.x - frameX, y: mouse.y - frameY };
                        canvasWrapper.style.cursor = 'grabbing';
                    }
                }
            });
            
            window.addEventListener('mousemove', e => {
                const canvasRect = canvas.getBoundingClientRect();
                if (canvasRect.width === 0) return;
                const mouseX = (e.clientX - canvasRect.left) * (canvas.width / canvasRect.width);
                const mouseY = (e.clientY - canvasRect.top) * (canvas.height / canvasRect.height);

                if (isDraggingPopOutText) {
                    state.popOut.textX = mouseX - popOutTextDragOffset.x;
                    state.popOut.textY = mouseY - popOutTextDragOffset.y;
                    drawPreview();
                    return;
                }

                if (isDraggingMagnifyFrame) {
                    state.magnify.frameX = mouseX - magnifyDragOffset.x;
                    state.magnify.frameY = mouseY - magnifyDragOffset.y;
                    state.magnify.frameX = Math.max(0, Math.min(state.magnify.frameX, canvas.width - state.magnify.frameW));
                    state.magnify.frameY = Math.max(0, Math.min(state.magnify.frameY, canvas.height - state.magnify.frameH));
                    drawPreview();
                    return;
                }

                if (!isPanning) return;
                e.preventDefault();

                const previewScale = canvas.width / canvasRect.width;
                const dx_canvas = (e.clientX - panStart.x) * previewScale;
                const dy_canvas = (e.clientY - panStart.y) * previewScale;
                
                if (activePanTarget.type === 'lightEffect') {
                    state.lightEffect.offset.x = initialImageOffset.x + dx_canvas;
                    state.lightEffect.offset.y = initialImageOffset.y + dy_canvas;
                    drawPreview();
                    return;
                }

                let targetImage, container, currentOffset, zoom = 1;

                if (activePanTarget.type === 'main') {
                    targetImage = mainImage;
                    let p = { top: 0, right: 0, bottom: 0, left: 0 };
                    if (state.mode === 'single') p = state.padding;
                    
                    container = { w: canvas.width - p.left - p.right, h: canvas.height - p.top - p.bottom };
                    currentOffset = state.imageOffset;
                    
                    if (state.mode === 'polaroid') {
                        const frameDetails = getPolaroidFrameDetails(canvas.width, canvas.height);
                        container = { w: frameDetails.photoW, h: frameDetails.photoH };
                        zoom = state.polaroid.zoom / 100;
                    }
                } else if (activePanTarget.type === 'doubleExposure_top') {
                    targetImage = topImage;
                    container = { w: canvas.width, h: canvas.height };
                    currentOffset = state.doubleExposure.topImageOffset;
                } else if (activePanTarget.type === 'collage') {
                    const p = state.padding;
                    const area = { x: p.left, y: p.top, w: canvas.width - p.left - p.right, h: canvas.height - p.top - p.bottom };
                    const layout = getCollageLayout(state.collage.layout, collageImages, area, state.collage.gap);
                    if (!layout[activePanTarget.index]) return;
                    container = layout[activePanTarget.index];
                    targetImage = collageImages[activePanTarget.index];
                    currentOffset = state.collage.imageOffsets[activePanTarget.index];
                } else {
                    return;
                }

                if (!targetImage || !container || container.w <= 0) return;

                const imgRatio = targetImage.width / targetImage.height;
                const areaRatio = container.w / container.h;
                let renderScale;
                let fit = 'cover';
                if (activePanTarget.type === 'main' && state.mode === 'single') fit = state.fit;

                if (fit === 'cover') {
                    if (imgRatio > areaRatio) { renderScale = container.h / (targetImage.height / zoom); } 
                    else { renderScale = container.w / (targetImage.width / zoom); }
                } else { // contain
                     if (imgRatio > areaRatio) { renderScale = container.w / (targetImage.width / zoom); } 
                     else { renderScale = container.h / (targetImage.height / zoom); }
                }

                const dx_source = dx_canvas / renderScale;
                const dy_source = dy_canvas / renderScale;
                
                let newOffset = {
                    x: initialImageOffset.x - dx_source,
                    y: initialImageOffset.y - dy_source,
                };
                
                let sW, sH;
                if (fit === 'cover') {
                    if (imgRatio > areaRatio) { sH = targetImage.height; sW = sH * areaRatio; } 
                    else { sW = targetImage.width; sH = sW / areaRatio; }
                } else {
                    if (imgRatio > areaRatio) { sW = targetImage.width; sH = sW / areaRatio; }
                    else { sH = targetImage.height; sW = sH * areaRatio; }
                }
                
                sW /= zoom; sH /= zoom;

                const maxOffsetX = Math.max(0, (targetImage.width - sW));
                const maxOffsetY = Math.max(0, (targetImage.height - sH));
                newOffset.x = Math.max(-maxOffsetX/2, Math.min(maxOffsetX/2, newOffset.x));
                newOffset.y = Math.max(-maxOffsetY/2, Math.min(maxOffsetY/2, newOffset.y));

                if (activePanTarget.type === 'main') {
                    state.imageOffset = newOffset;
                } else if (activePanTarget.type === 'doubleExposure_top') {
                    state.doubleExposure.topImageOffset = newOffset;
                } else if (activePanTarget.type === 'collage') {
                    state.collage.imageOffsets[activePanTarget.index] = newOffset;
                }

                drawPreview();
            });

            window.addEventListener('mouseup', () => {
                if (isPanning || isDraggingMagnifyFrame || isDraggingPopOutText) {
                    isPanning = false;
                    isDraggingMagnifyFrame = false;
                    isDraggingPopOutText = false;
                    activePanTarget = { type: null, index: -1 };
                    updateCursor();
                    saveStateToHistory();
                }
            });
            canvasWrapper.addEventListener('mouseenter', updateCursor);
            canvasWrapper.addEventListener('mouseleave', () => { canvasWrapper.style.cursor = 'default'; });
            
            collageThumbnailsContainer.addEventListener('click', (e) => {
                if(e.target.classList.contains('delete-thumb-btn')) {
                    const indexToDelete = parseInt(e.target.dataset.index, 10);
                    deleteCollageImage(indexToDelete);
                }
            });
        }
        
        function switchMode(mode) {
            // Reset images when switching modes to avoid conflicts
            if (mode !== 'doubleExposure') {
                topImage = null;
                bottomImage = null;
                topImageLoader.value = null;
                bottomImageLoader.value = null;
                state.doubleExposure.topImageOffset = { x: 0, y: 0 };
                state.doubleExposure.bottomImageOffset = { x: 0, y: 0 };
            }
            if (mode !== 'collage') {
                collageImages = [];
                collageImageLoader.value = null;
                collageThumbnailsContainer.innerHTML = '';
                collageThumbnailsWrapper.classList.add('hidden');
                state.collage.imageOffsets = [];
            }
            
            if (!mainImage && !topImage && !bottomImage && collageImages.length === 0) {
                previewPlaceholder.classList.remove('hidden');
                canvasWrapper.classList.add('hidden');
                ctx.clearRect(0, 0, canvas.width, canvas.height);
            }
            
            state.mode = mode;
            updateUIFromState(state);
            updateAndDraw(); 
            saveStateToHistory();
        }

        function setFitMode(fit) {
            document.getElementById('fitContainBtn').classList.toggle('active', fit === 'contain');
            document.getElementById('fitCoverBtn').classList.toggle('active', fit === 'cover');
            updateAndDraw();
        }

        function updateCursor() {
            if (isDraggingMagnifyFrame || isPanning || isDraggingPopOutText) {
                 canvasWrapper.style.cursor = 'grabbing';
                 return;
            } 
            
            const canPanMainImage = (state.mode === 'single' && state.fit === 'cover') || ['polaroid', 'magnify', 'popOut'].includes(state.mode);
            const canPanCollage = state.mode === 'collage' && collageImages.length > 0;
            const canPanDoubleExposure = state.mode === 'doubleExposure' && topImage;
            const canPanLightEffectPattern = state.mode === 'lightEffect' && mainImage;

            if (isModifierDown && mainImage && (canPanMainImage || canPanCollage || canPanDoubleExposure || canPanLightEffectPattern)) {
                canvasWrapper.style.cursor = 'grab';
            } else if (!isModifierDown && state.mode === 'magnify' && mainImage) {
                canvasWrapper.style.cursor = 'move';
            } else if (state.mode === 'popOut' && state.popOut.text) {
                canvasWrapper.style.cursor = 'grab';
            } else {
                canvasWrapper.style.cursor = 'default';
            }
        }

        function handlePaddingSlider(e) {
            const value = e.target.value;
            if (document.getElementById('syncPadding').checked) {
                document.querySelectorAll('.padding-slider').forEach(s => s.value = value);
            }
            updateAndDraw(false); 
        }
        document.querySelectorAll('.padding-slider').forEach(s => s.addEventListener('change', () => updateAndDraw(true)));


        function handleImageUpload(file) {
            if (!file) return;
            originalFileName = file.name.split('.').slice(0, -1).join('.') || 'fotoğraf';
            const reader = new FileReader();
            reader.onload = e => {
                mainImage = new Image();
                mainImage.onload = () => {
                    previewPlaceholder.classList.add('hidden');
                    canvasWrapper.style.display = 'flex';
                    canvasWrapper.classList.remove('hidden');
                    state.imageOffset = { x: 0, y: 0 };
                     if (state.mode === 'magnify') {
                         const preset = presets[state.sizePreset] || { width: 1080, height: 1080 };
                         state.magnify.frameX = (preset.width - state.magnify.frameW) / 2;
                         state.magnify.frameY = (preset.height - state.magnify.frameH) / 2;
                    }
                    if (state.mode === 'popOut') {
                        state.popOut.textX = null; // Reset for centering
                        state.popOut.textY = null;
                    }
                    updateAndDraw();
                };
                mainImage.src = e.target.result;
            };
            reader.readAsDataURL(file);
        }

        function handleLayerUpload(file, layer) {
            if (!file) return;
            originalFileName = 'cift-pozlama';
            const reader = new FileReader();
            reader.onload = e => {
                const img = new Image();
                img.onload = () => {
                    if (layer === 'top') {
                        topImage = img;
                        state.doubleExposure.topImageOffset = { x: 0, y: 0 };
                    } else {
                        bottomImage = img;
                        state.doubleExposure.bottomImageOffset = { x: 0, y: 0 };
                    }
                    
                    if (topImage && bottomImage) {
                        previewPlaceholder.classList.add('hidden');
                        canvasWrapper.style.display = 'flex';
                        canvasWrapper.classList.remove('hidden');
                    }
                    updateAndDraw();
                };
                img.src = e.target.result;
            };
            reader.readAsDataURL(file);
        }
        
        function swapLayers() {
            if (!topImage || !bottomImage) {
                showToast("Lütfen önce her iki katman için de resim seçin.", "error");
                return;
            }
            [topImage, bottomImage] = [bottomImage, topImage];
            [topImageLoader.files, bottomImageLoader.files] = [bottomImageLoader.files, topImageLoader.files]; // This might not work perfectly due to security
            showToast("Katmanlar değiştirildi.", "info");
            updateAndDraw();
        }
        
        function handleCollageUpload(files) {
            if (!files || files.length === 0) return;
            originalFileName = 'kolaj';
            const readers = Array.from(files).map(file => {
                return new Promise(resolve => {
                    const reader = new FileReader();
                    reader.onload = e => {
                        const img = new Image();
                        img.onload = () => resolve(img);
                        img.src = e.target.result;
                    };
                    reader.readAsDataURL(file);
                });
            });
            Promise.all(readers).then(images => {
                collageImages = collageImages.concat(images);
                const newOffsets = images.map(() => ({ x: 0, y: 0 }));
                state.collage.imageOffsets = state.collage.imageOffsets.concat(newOffsets);

                if (collageImages.length > 0) {
                    previewPlaceholder.classList.add('hidden');
                    canvasWrapper.style.display = 'flex';
                    canvasWrapper.classList.remove('hidden');
                    displayCollageThumbnails();
                    updateAndDraw();
                }
            });
        }
        
        function deleteCollageImage(index) {
            if (index > -1 && index < collageImages.length) {
                collageImages.splice(index, 1);
                state.collage.imageOffsets.splice(index, 1);
                
                if (collageImages.length === 0) {
                    previewPlaceholder.classList.remove('hidden');
                    canvasWrapper.classList.add('hidden');
                }
                
                displayCollageThumbnails();
                updateAndDraw();
                saveStateToHistory();
            }
        }

        function displayCollageThumbnails() {
            collageThumbnailsWrapper.classList.toggle('hidden', collageImages.length === 0);
            collageThumbnailsContainer.innerHTML = '';
            collageImages.forEach((img, index) => {
                const thumbItem = document.createElement('div');
                thumbItem.className = 'thumbnail-item';
                thumbItem.dataset.index = index;
                thumbItem.draggable = true;
                thumbItem.innerHTML = `
                    <img src="${img.src}" alt="Kolaj resmi ${index + 1}">
                    <button class="delete-thumb-btn" data-index="${index}" title="Resmi Sil">&times;</button>
                `;
                collageThumbnailsContainer.appendChild(thumbItem);
            });
            addDragDropListenersToThumbnails();
        }

        function addDragDropListenersToThumbnails() {
            const thumbnails = document.querySelectorAll('.thumbnail-item');
            thumbnails.forEach(thumb => {
                thumb.addEventListener('dragstart', handleDragStart);
                thumb.addEventListener('dragend', handleDragEnd);
                thumb.addEventListener('dragover', handleDragOver);
                thumb.addEventListener('dragleave', handleDragLeave);
                thumb.addEventListener('drop', handleDrop);
            });
        }

        function handleDragStart(e) {
            draggedThumbnailIndex = parseInt(e.target.closest('.thumbnail-item').dataset.index);
            e.target.closest('.thumbnail-item').classList.add('dragging');
        }

        function handleDragEnd(e) {
            e.target.closest('.thumbnail-item').classList.remove('dragging');
        }
        
        function handleDragOver(e) {
            e.preventDefault();
            const targetItem = e.target.closest('.thumbnail-item');
            if (targetItem) targetItem.classList.add('drag-over-thumb');
        }

        function handleDragLeave(e) {
             const targetItem = e.target.closest('.thumbnail-item');
            if (targetItem) targetItem.classList.remove('drag-over-thumb');
        }

        function handleDrop(e) {
            e.preventDefault();
            const targetItem = e.target.closest('.thumbnail-item');
            if (!targetItem) return;
            targetItem.classList.remove('drag-over-thumb');
            const droppedOnIndex = parseInt(targetItem.dataset.index);

            if (draggedThumbnailIndex === droppedOnIndex) return;

            const draggedImage = collageImages.splice(draggedThumbnailIndex, 1)[0];
            const draggedOffset = state.collage.imageOffsets.splice(draggedThumbnailIndex, 1)[0];
            
            collageImages.splice(droppedOnIndex, 0, draggedImage);
            state.collage.imageOffsets.splice(droppedOnIndex, 0, draggedOffset);
            
            displayCollageThumbnails();
            updateAndDraw();
        }

        function handleWatermarkUpload(e) {
            const file = e.target.files[0];
            if (!file) {
                watermarkImage = null;
                document.getElementById('watermarkControls').classList.add('hidden');
                updateAndDraw(); return;
            }
            const reader = new FileReader();
            reader.onload = res => {
                watermarkImage = new Image();
                watermarkImage.onload = () => {
                    document.getElementById('watermarkControls').classList.remove('hidden');
                    updateAndDraw();
                }
                watermarkImage.src = res.target.result;
            }
            reader.readAsDataURL(file);
        }

        function drawPreview() {
            const hasImage = mainImage || (state.mode === 'collage' && collageImages.length > 0) || (state.mode === 'doubleExposure' && topImage && bottomImage);
            if (!hasImage) {
                previewPlaceholder.classList.remove('hidden');
                canvasWrapper.classList.add('hidden');
                return;
            };

            const preset = presets[state.sizePreset];
            if (state.sizePreset === 'original' && mainImage && state.mode === 'single') {
                canvas.width = mainImage.width + state.padding.left + state.padding.right;
                canvas.height = mainImage.height + state.padding.top + state.padding.bottom;
            } else if (preset) {
                canvas.width = preset.width;
                canvas.height = preset.height;
            } else { 
                canvas.width = 1080;
                canvas.height = 1080;
            }
            
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            if (state.mode === 'polaroid') {
                const frameSpec = polaroidFrameSpecs[state.polaroid.frame];
                if (frameSpec && frameSpec.type === 'effect') {
                    state.bgType = 'blur';
                    document.getElementById('bgBlur').checked = true;
                }
            }

            if (state.mode !== 'magnify' && state.mode !== 'lightEffect' && state.mode !== 'popOut') {
                drawBackground(ctx, canvas.width, canvas.height);
            }
            drawMainContent(ctx, canvas.width, canvas.height);
            if (state.mode === 'single' || state.mode === 'collage') {
                 drawTextAndWatermark(ctx, canvas.width, canvas.height);
            }
        }

        function drawBackground(targetCtx, w, h) {
            targetCtx.save();
            if (state.bgType === 'solid') {
                targetCtx.fillStyle = state.color1;
                targetCtx.fillRect(0, 0, w, h);
            } else if (state.bgType === 'gradient') {
                const gradient = targetCtx.createLinearGradient(0, 0, w, h);
                gradient.addColorStop(0, state.color1);
                gradient.addColorStop(1, state.color2);
                targetCtx.fillStyle = gradient;
                targetCtx.fillRect(0, 0, w, h);
            } else if (state.bgType === 'blur' && (mainImage || collageImages.length > 0 || bottomImage)) {
                const imgToBlur = mainImage || collageImages[0] || bottomImage;
                targetCtx.fillStyle = state.color1;
                targetCtx.fillRect(0, 0, w, h);
                targetCtx.save();
                targetCtx.filter = `blur(${state.bgBlurAmount}px) brightness(${1 + state.imageAdjustments.exposure / 100})`;
                const imgRatio = imgToBlur.width / imgToBlur.height;
                const canvasRatio = w / h;
                let finalW = w, finalH = h;
                if(imgRatio > canvasRatio) { finalH = w / imgRatio; } else { finalW = h * imgRatio; }
                const x = (w - finalW) / 2; const y = (h - finalH) / 2;
                targetCtx.drawImage(imgToBlur, x, y, finalW, finalH);
                targetCtx.restore();
            } else if (state.bgType === 'transparent') {
                // Do nothing, canvas is already cleared.
            } else {
                targetCtx.fillStyle = '#cccccc';
                targetCtx.fillRect(0, 0, w, h);
            }
            targetCtx.restore();
        }

        function drawMainContent(targetCtx, w, h, scale = 1) {
            targetCtx.save();
            
            if (state.mode === 'polaroid' && mainImage) {
                drawPolaroidFrame(targetCtx, w, h, scale);
            } else if (state.mode === 'magnify' && mainImage) {
                drawMagnifyEffectOnContext(targetCtx, w, h, mainImage, state.magnify);
            } else if (state.mode === 'doubleExposure' && topImage && bottomImage) {
                drawDoubleExposureEffect(targetCtx, w, h, scale);
            } else if (state.mode === 'lightEffect' && mainImage) {
                drawLightEffect(targetCtx, w, h, scale);
            } else if (state.mode === 'popOut' && mainImage) {
                drawPopOutEffect(targetCtx, w, h, scale);
            } else {
                const p = { top: state.padding.top * scale, right: state.padding.right * scale, bottom: state.padding.bottom * scale, left: state.padding.left * scale };
                const drawableW = w - p.left - p.right;
                const drawableH = h - p.top - p.bottom;
                if (drawableW <= 0 || drawableH <= 0) { targetCtx.restore(); return; }

                if (state.mode === 'single' && mainImage) {
                    targetCtx.save();
                    targetCtx.filter = `brightness(${1 + state.imageAdjustments.exposure / 100})`;
                    if (state.fit === 'contain') {
                        const containerRatio = drawableW / drawableH;
                        const imgRatio = mainImage.width / mainImage.height;
                        let finalW, finalH;
                        if (imgRatio > containerRatio) { finalW = drawableW; finalH = finalW / imgRatio; } 
                        else { finalH = drawableH; finalW = finalH * imgRatio; }
                        const x = p.left + (drawableW - finalW) / 2;
                        const y = p.top + (drawableH - finalH) / 2;
                        drawRoundedImage(targetCtx, mainImage, x, y, finalW, finalH, 0, 'contain');
                    } else { // 'cover'
                        const offset = state.imageOffset || { x: 0, y: 0 };
                        drawRoundedImage(targetCtx, mainImage, p.left, p.top, drawableW, drawableH, 0, 'cover', offset);
                    }
                    targetCtx.restore();
                } else if (state.mode === 'collage' && collageImages.length > 0) {
                    drawCollageLayout(targetCtx, w, h, scale);
                }
            }
            targetCtx.restore();
        }

        /**
         * DÜZELTME 3: Işık Efekti Mantığı (Additive Blend)
         * Bu fonksiyon, kullanıcının renk ve yoğunluk beklentisini karşılamak için yeniden düzenlenmiştir.
         * Mantık:
         * 1. Ana tuval üzerine, pozlama ayarı uygulanmış olan ana resim çizilir.
         * 2. Geçici bir tuval üzerinde, kullanıcının seçtiği RENK ile ışık deseni oluşturulur.
         * 3. Bu renkli desen katmanı, ana resmin üzerine, kullanıcının seçtiği
         * aydınlatıcı harmanlama modu ('screen', 'color-dodge' vb.) ile çizilir.
         * 4. Opaklık, bu aydınlatma efektinin genel yoğunluğunu kontrol eder.
         * Bu yöntem, renkli bir ışığın karanlık bir yüzeyi aydınlatması efektini doğru bir şekilde simüle eder.
         */
        function drawLightEffect(targetCtx, w, h, scale = 1) {
            if (!mainImage) return;
            targetCtx.save();

            const s = state.lightEffect;
            const exposure = state.imageAdjustments.exposure;

            // 1. Adım: Pozlama ayarı yapılmış ana resmi çiz.
            targetCtx.filter = `brightness(${1 + exposure / 100})`;
            drawRoundedImage(targetCtx, mainImage, 0, 0, w, h, 0, state.fit, state.imageOffset);
            targetCtx.filter = 'none'; // Sonraki işlemler için filtreyi sıfırla

            // 2. Adım: Renkli ışık desenini geçici bir tuvalde oluştur.
            const patternCanvas = generateLightPattern(s.pattern, w, h, s.color);

            // 3. Adım: Renkli ışık katmanını, aydınlatıcı bir harmanlama moduyla ana resmin üzerine çiz.
            targetCtx.globalAlpha = s.opacity / 100;
            targetCtx.globalCompositeOperation = s.blendMode;

            // Desen üzerinde kullanıcının seçtiği açı/ölçek gibi dönüşümleri uygula
            targetCtx.translate(w / 2, h / 2);
            targetCtx.rotate(s.angle * Math.PI / 180);
            const scaleFactor = s.scale / 100;
            targetCtx.scale(scaleFactor, scaleFactor);
            targetCtx.translate(-w / 2, -h / 2);
            
            targetCtx.drawImage(patternCanvas, s.offset.x, s.offset.y, w, h);

            targetCtx.restore();
        }

        function generateLightPattern(pattern, width, height, color) {
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = width;
            tempCanvas.height = height;
            const tempCtx = tempCanvas.getContext('2d');
            tempCtx.fillStyle = color;

            switch (pattern) {
                case 'blinds':
                    for (let i = -height; i < height * 2; i += 40) { tempCtx.fillRect(0, i, width, 20); }
                    break;
                case 'window':
                    const barWidth = Math.min(width, height) * 0.05;
                    tempCtx.fillRect(width / 2 - barWidth / 2, 0, barWidth, height);
                    tempCtx.fillRect(0, height / 2 - barWidth / 2, width, barWidth);
                    break;
                case 'lines':
                    for (let i = 0; i < width * 2; i += 15) { tempCtx.fillRect(i, -height, 3, height*2); }
                    break;
                case 'diagonal-lines':
                    tempCtx.lineWidth = 8;
                    tempCtx.strokeStyle = color;
                    for (let i = -width; i < width * 1.5; i += 25) {
                        tempCtx.beginPath();
                        tempCtx.moveTo(i, 0);
                        tempCtx.lineTo(i + height, height);
                        tempCtx.stroke();
                    }
                    break;
                case 'grid':
                    for (let i = 0; i < width; i += 50) { tempCtx.fillRect(i, 0, 2, height); }
                    for (let j = 0; j < height; j += 50) { tempCtx.fillRect(0, j, width, 2); }
                    break;
                case 'god-rays':
                    const centerX = width / 2;
                    for (let i = 0; i < 36; i++) {
                        tempCtx.save();
                        tempCtx.translate(centerX, -100);
                        tempCtx.rotate((i * 10 + (Math.random() - 0.5) * 5) * Math.PI / 180);
                        const gradient = tempCtx.createLinearGradient(0, 0, 0, height * 1.5);
                        gradient.addColorStop(0, color);
                        gradient.addColorStop(0.5 + Math.random() * 0.3, 'transparent');
                        tempCtx.fillStyle = gradient;
                        tempCtx.fillRect(-width * 0.02, 0, width * 0.04, height * 1.5);
                        tempCtx.restore();
                    }
                    break;
                case 'bokeh':
                     for (let i = 0; i < 50; i++) {
                        const x = Math.random() * width;
                        const y = Math.random() * height;
                        const radius = Math.random() * 50 + 10;
                        tempCtx.globalAlpha = Math.random() * 0.5 + 0.1;
                        tempCtx.beginPath();
                        tempCtx.arc(x, y, radius, 0, Math.PI * 2);
                        tempCtx.fill();
                    }
                    tempCtx.globalAlpha = 1.0;
                    break;
                case 'leak1':
                    const gradient1 = tempCtx.createRadialGradient(0, 0, 0, 0, 0, Math.max(width, height) * 0.7);
                    gradient1.addColorStop(0, color);
                    gradient1.addColorStop(1, 'transparent');
                    tempCtx.fillStyle = gradient1;
                    tempCtx.fillRect(0, 0, width, height);
                    break;
                case 'leak2':
                    const gradient2 = tempCtx.createRadialGradient(width, height, 0, width, height, Math.max(width, height));
                    gradient2.addColorStop(0, color);
                    gradient2.addColorStop(0.5, 'transparent');
                    tempCtx.fillStyle = gradient2;
                    tempCtx.fillRect(0, 0, width, height);
                    break;
                case 'spotlight':
                    const gradient3 = tempCtx.createRadialGradient(width/2, height/2, 0, width/2, height/2, Math.min(width,height)/2.5);
                    gradient3.addColorStop(0, color);
                    gradient3.addColorStop(1, 'transparent');
                    tempCtx.fillStyle = gradient3;
                    tempCtx.fillRect(0, 0, width, height);
                    break;
            }
            return tempCanvas;
        }

        function drawDoubleExposureEffect(targetCtx, w, h, scale = 1) {
            if (!topImage || !bottomImage) return;

            const exposure = state.imageAdjustments.exposure;
            const exposureFilter = `brightness(${1 + exposure / 100})`;

            // Alt katmanı pozlama ile geçici bir tuvale çiz
            const bottomCanvas = document.createElement('canvas');
            bottomCanvas.width = w;
            bottomCanvas.height = h;
            const bottomCtx = bottomCanvas.getContext('2d');
            bottomCtx.filter = exposureFilter;
            drawRoundedImage(bottomCtx, bottomImage, 0, 0, w, h, 0, 'cover', state.doubleExposure.bottomImageOffset);

            // Üst katmanı pozlama ile geçici bir tuvale çiz
            const topCanvas = document.createElement('canvas');
            topCanvas.width = w;
            topCanvas.height = h;
            const topCtx = topCanvas.getContext('2d');
            topCtx.filter = exposureFilter;
            drawRoundedImage(topCtx, topImage, 0, 0, w, h, 0, 'cover', state.doubleExposure.topImageOffset);

            // Katmanları ana tuval üzerinde birleştir
            targetCtx.save();
            targetCtx.drawImage(bottomCanvas, 0, 0);
            targetCtx.globalCompositeOperation = state.doubleExposure.blendMode;
            targetCtx.globalAlpha = state.doubleExposure.opacity / 100;
            targetCtx.drawImage(topCanvas, 0, 0);
            targetCtx.restore();
        }

        function drawMagnifyEffectOnContext(targetCtx, w, h, image, mState) {
            if (!image) return;
            const { frameX, frameY, frameW, frameH, zoom, blur, borderColor, borderWidth } = mState;
            const offset = state.imageOffset || { x: 0, y: 0 };
            const exposureFilter = `brightness(${1 + state.imageAdjustments.exposure / 100})`;
            
            // Arkaplanı çiz
            targetCtx.save();
            let filters = [];
            if (blur > 0) filters.push(`blur(${blur}px)`);
            filters.push(exposureFilter);
            targetCtx.filter = filters.join(' ');
            drawRoundedImage(targetCtx, image, 0, 0, w, h, 0, 'cover', offset);
            targetCtx.restore();

            // Odaklanmış ön planı çiz
            targetCtx.save();
            targetCtx.beginPath();
            targetCtx.rect(frameX, frameY, frameW, frameH);
            targetCtx.clip();
            const centerX = frameX + frameW / 2;
            const centerY = frameY + frameH / 2;
            targetCtx.translate(centerX, centerY);
            targetCtx.scale(zoom, zoom);
            targetCtx.translate(-centerX, -centerY);
            
            targetCtx.save();
            targetCtx.filter = exposureFilter;
            drawRoundedImage(targetCtx, image, 0, 0, w, h, 0, 'cover', offset);
            targetCtx.restore();
            
            targetCtx.restore();

            // Çerçeveyi çiz
            if (borderWidth > 0) {
                targetCtx.strokeStyle = borderColor;
                targetCtx.lineWidth = borderWidth;
                targetCtx.strokeRect(frameX, frameY, frameW, frameH);
            }
        }

        function getPopOutBackgroundFilter(effect) {
            switch(effect) {
                case 'grayscale': return 'grayscale(100%)';
                case 'blur': return `blur(${state.popOut.blurAmount}px)`;
                case 'sepia': return 'sepia(100%)';
                default: return 'none';
            }
        }
        
        function getPopOutTextMetrics(w, h) {
            const s = state.popOut;
            const fontSize = w * 0.05;
            ctx.font = `bold ${fontSize}px '${s.font}'`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            const metrics = ctx.measureText(s.text);
            
            return {
                width: metrics.width,
                actualBoundingBoxAscent: metrics.actualBoundingBoxAscent,
                actualBoundingBoxDescent: metrics.actualBoundingBoxDescent,
                x: state.popOut.textX,
                y: state.popOut.textY
            };
        }

        function drawPopOutEffect(targetCtx, w, h, scale = 1) {
            if (!mainImage) return;
            const s = state.popOut;
            const exposureFilter = `brightness(${1 + state.imageAdjustments.exposure / 100})`;

            // 1. Arkaplanı çiz
            targetCtx.save();
            const bgEffect = getPopOutBackgroundFilter(s.backgroundEffect);
            targetCtx.filter = `${bgEffect} ${exposureFilter}`.trim();
            drawRoundedImage(targetCtx, mainImage, 0, 0, w, h, 0, 'cover', state.imageOffset);
            targetCtx.restore();

            // 2. Ön planı çiz
            const fgSizeRatio = s.size / 100;
            const fgW = w * fgSizeRatio;
            const fgH = h * fgSizeRatio;
            const fgX = (w - fgW) / 2;
            const fgY = (h - fgH) / 2;
            const borderWidth = s.borderWidth * scale;

            if (borderWidth > 0) {
                targetCtx.fillStyle = s.borderColor;
                targetCtx.shadowColor = 'rgba(0,0,0,0.3)';
                targetCtx.shadowBlur = 20 * scale;
                targetCtx.shadowOffsetY = 5 * scale;
                targetCtx.fillRect(fgX - borderWidth, fgY - borderWidth, fgW + (borderWidth * 2), fgH + (borderWidth * 2));
                targetCtx.shadowColor = 'transparent';
            }

            targetCtx.save();
            targetCtx.filter = exposureFilter;
            drawRoundedImage(targetCtx, mainImage, fgX, fgY, fgW, fgH, 0, 'cover', state.imageOffset);
            targetCtx.restore();
            
            if (s.text) {
                const fontSize = w * 0.05;
                targetCtx.font = `bold ${fontSize}px '${s.font}'`;
                targetCtx.fillStyle = '#FFFFFF';
                targetCtx.textAlign = 'center';
                targetCtx.textBaseline = 'middle';
                targetCtx.shadowColor = 'rgba(0,0,0,0.5)';
                targetCtx.shadowBlur = 5 * scale;
                targetCtx.shadowOffsetX = 1 * scale;
                targetCtx.shadowOffsetY = 1 * scale;
                
                let textX, textY;
                if (scale > 1) {
                    textX = s.textX === null ? w / 2 : s.textX * scale;
                    textY = s.textY === null ? h - (h * 0.1) : s.textY * scale;
                } else {
                    if (s.textX === null || s.textY === null) {
                        s.textX = w / 2;
                        s.textY = h - (h * 0.1);
                    }
                    textX = s.textX;
                    textY = s.textY;
                }
                
                targetCtx.fillText(s.text, textX, textY);
                targetCtx.shadowColor = 'transparent';
            }
        }

        function getPolaroidFrameDetails(canvasW, canvasH) {
            const frameSpec = polaroidFrameSpecs[state.polaroid.frame];
            const margin = Math.min(canvasW, canvasH) * 0.1;
            const availableW = canvasW - 2 * margin;
            const availableH = canvasH - 2 * margin;

            let frameW, frameH;
            if (availableW / frameSpec.aspectRatio <= availableH) {
                frameW = availableW;
                frameH = frameW / frameSpec.aspectRatio;
            } else {
                frameH = availableH;
                frameW = frameH * frameSpec.aspectRatio;
            }
            
            const p = frameSpec.photoPadding || 0.05;
            const photoW = frameW * (1 - 2 * p);
            const photoH = photoW;
            const photoX = (canvasW - frameW) / 2 + frameW * p;
            const photoY = (canvasH - frameH) / 2 + frameW * p;

            return { frameW, frameH, photoX, photoY, photoW, photoH };
        }

        function drawPolaroidFrame(targetCtx, w, h, scale) {
            const frameSpec = polaroidFrameSpecs[state.polaroid.frame];
            if (!frameSpec) return;

            targetCtx.save();
            
            if (frameSpec.type === 'effect') {
                const margin = Math.min(w, h) * 0.05;
                const photoW = w - 2 * margin;
                const photoH = h - 2 * margin;
                const photoX = margin;
                const photoY = margin;
                
                targetCtx.save();
                targetCtx.filter = `brightness(${1 + state.imageAdjustments.exposure / 100})`;
                drawRoundedImage(targetCtx, mainImage, photoX, photoY, photoW, photoH, 0, 'cover', state.imageOffset, state.polaroid.zoom / 100);
                targetCtx.restore();

                targetCtx.strokeStyle = 'rgba(255,255,255,0.9)';
                targetCtx.lineWidth = margin * 0.05;
                targetCtx.strokeRect(photoX, photoY, photoW, photoH);
                targetCtx.fillStyle = frameSpec.effectColor;
                const holeW = photoW * 0.02;
                const holeH = photoH * 0.04;
                const holeMargin = holeW * 1.5;
                for (let i = photoY + holeMargin; i < photoY + photoH - holeMargin; i += holeH * 1.5) {
                    targetCtx.fillRect(photoX + holeMargin, i, holeW, holeH);
                    targetCtx.fillRect(photoX + photoW - holeMargin - holeW, i, holeW, holeH);
                }
                targetCtx.restore();
                return;
            }

            const margin = Math.min(w, h) * 0.1;
            const availableW = w - 2 * margin;
            const availableH = h - 2 * margin;
            let frameW, frameH;
            if (availableW / frameSpec.aspectRatio <= availableH) {
                frameW = availableW;
                frameH = frameW / frameSpec.aspectRatio;
            } else {
                frameH = availableH;
                frameW = frameH * frameSpec.aspectRatio;
            }
            const frameX = (w - frameW) / 2;
            const frameY = (h - frameH) / 2;
            
            targetCtx.translate(frameX + frameW / 2, frameY + frameH / 2);
            targetCtx.rotate(state.polaroid.rotation * Math.PI / 180);
            targetCtx.translate(-(frameX + frameW / 2), -(frameY + frameH / 2));

            targetCtx.shadowColor = 'rgba(0,0,0,0.4)';
            targetCtx.shadowBlur = 30 * scale;
            targetCtx.shadowOffsetX = 5 * scale;
            targetCtx.shadowOffsetY = 10 * scale;

            if (frameSpec.type === 'color') {
                targetCtx.fillStyle = state.polaroid.frameColor;
            } else if (frameSpec.type === 'pattern' && frameImageAssets[frameSpec.value] && frameImageAssets[frameSpec.value].complete) {
                targetCtx.fillStyle = targetCtx.createPattern(frameImageAssets[frameSpec.value], 'repeat');
            } else {
                targetCtx.fillStyle = frameSpec.value || '#ffffff';
            }
            targetCtx.fillRect(frameX, frameY, frameW, frameH);
            
            targetCtx.shadowColor = 'transparent';

            let photoX, photoY, photoW, photoH;
            const layout = frameSpec.layout || 'classic';

            if (layout === 'equal') {
                const p = 0.05;
                photoX = frameX + frameW * p;
                photoY = frameY + frameH * p;
                photoW = frameW * (1 - 2 * p);
                photoH = frameH * (1 - 2 * p);
            } else if (layout === 'top-heavy') {
                const pX = 0.05; const pTop = 0.25; const pBottom = 0.05;
                photoX = frameX + frameW * pX;
                photoY = frameY + frameH * pTop;
                photoW = frameW * (1 - 2 * pX);
                photoH = frameH - (frameH * pTop) - (frameH * pBottom);
            } else { // 'classic'
                const p = frameSpec.photoPadding;
                photoX = frameX + frameW * p;
                photoY = frameY + frameW * p;
                photoW = frameW * (1 - 2 * p);
                photoH = photoW;
            }
            
            targetCtx.fillStyle = '#1a202c';
            targetCtx.fillRect(photoX, photoY, photoW, photoH);
            
            targetCtx.save();
            targetCtx.filter = `brightness(${1 + state.imageAdjustments.exposure / 100})`;
            drawRoundedImage(targetCtx, mainImage, photoX, photoY, photoW, photoH, 0, 'cover', state.imageOffset, state.polaroid.zoom / 100);
            targetCtx.restore();

            if (frameSpec.type === 'special' && state.polaroid.frame === 'film-kare') {
                targetCtx.save();
                targetCtx.fillStyle = frameSpec.textColor;
                targetCtx.font = `bold ${frameW * 0.025}px 'Roboto Mono', monospace`;
                targetCtx.textAlign = 'center';
                targetCtx.textBaseline = 'middle';
                targetCtx.translate(photoX + photoW + (frameW - (photoX + photoW - frameX))/2, photoY + photoH / 2);
                targetCtx.rotate(Math.PI / 2);
                targetCtx.fillText('KODAK HITS', 0, 0);
                targetCtx.restore();
                targetCtx.save();
                targetCtx.translate(photoX - (photoX - frameX)/2, photoY + photoH / 2);
                targetCtx.rotate(-Math.PI / 2);
                targetCtx.fillText('KODAK HITS', 0, 0);
                targetCtx.restore();
            }

            if(state.polaroid.text) {
                targetCtx.fillStyle = frameSpec.textColor;
                targetCtx.font = `${frameW * 0.05}px 'Caveat', cursive`;
                targetCtx.textAlign = 'center';
                targetCtx.textBaseline = 'middle';
                const bottomEdgeOfPhoto = photoY + photoH;
                const bottomEdgeOfFrame = frameY + frameH;
                const spaceBelowPhoto = bottomEdgeOfFrame - bottomEdgeOfPhoto;
                if (spaceBelowPhoto > (frameW * 0.06)) {
                    const textY = bottomEdgeOfPhoto + spaceBelowPhoto / 2;
                    targetCtx.fillText(state.polaroid.text, frameX + frameW / 2, textY, frameW * 0.9);
                }
            }

            targetCtx.restore();
        }

        function drawCollageLayout(targetCtx, w, h, scale) {
            const p = { top: state.padding.top * scale, right: state.padding.right * scale, bottom: state.padding.bottom * scale, left: state.padding.left * scale };
            const gap = state.collage.gap * scale;
            const cornerRadius = state.collage.cornerRadius * scale;
            const area = { x: p.left, y: p.top, w: w - p.left - p.right, h: h - p.top - p.bottom };
            const layout = getCollageLayout(state.collage.layout, collageImages, area, gap);
            
            if (state.collage.layout === 'film-strip' && collageImages.length > 0) {
                targetCtx.fillStyle = '#222';
                const framePadding = area.h * 0.1;
                targetCtx.fillRect(area.x, area.y + framePadding, area.w, area.h - 2 * framePadding);
                
                const holeSize = framePadding * 0.4;
                const holeMargin = framePadding * 0.3;
                targetCtx.fillStyle = '#ddd';
                for(let i = area.x + holeMargin; i < area.x + area.w - holeMargin; i += holeSize * 2.5) {
                    targetCtx.fillRect(i, area.y + framePadding + holeMargin, holeSize, holeSize);
                    targetCtx.fillRect(i, area.y + area.h - framePadding - holeMargin - holeSize, holeSize, holeSize);
                }
            }

            collageImages.slice(0, layout.length).forEach((img, i) => {
                const rect = layout[i];
                if (rect && rect.w > 0 && rect.h > 0) {
                    const offset = state.collage.imageOffsets[i] || { x: 0, y: 0 };
                    
                    targetCtx.save();
                    targetCtx.filter = `brightness(${1 + state.imageAdjustments.exposure / 100})`;
                    if (rect.rotation) {
                        targetCtx.translate(rect.x + rect.w / 2, rect.y + rect.h / 2);
                        targetCtx.rotate(rect.rotation * Math.PI / 180);
                        targetCtx.shadowColor = 'rgba(0,0,0,0.4)';
                        targetCtx.shadowBlur = 15 * scale;
                        targetCtx.shadowOffsetY = 5 * scale;
                        targetCtx.fillStyle = '#fff';
                        const p = rect.w * 0.05;
                        targetCtx.fillRect(-(rect.w/2), -(rect.h/2), rect.w, rect.h);
                        drawRoundedImage(targetCtx, img, -(rect.w/2)+p, -(rect.h/2)+p, rect.w-2*p, rect.h*0.8-p, 0, 'cover', offset);
                    } else {
                        drawRoundedImage(targetCtx, img, rect.x, rect.y, rect.w, rect.h, cornerRadius, 'cover', offset, 1, rect.shape);
                    }
                    targetCtx.restore();
                }
            });
        }
        
        function getCollageLayout(type, images, area, gap) {
            const rects = [];
            const numImages = images.length;
            if (numImages === 0) return rects;
            const addRect = (x, y, w, h, shape = 'rect', rotation = 0) => rects.push({ x: Math.round(x), y: Math.round(y), w: Math.round(w), h: Math.round(h), shape, rotation });

            if (type === 'auto') {
                if (numImages === 1) type = 'columns';
                else if (numImages === 2) type = 'columns';
                else if (numImages === 3) type = 'asym-mosaic';
                else if (numImages === 4) type = 'grid';
                else if (numImages === 5) type = 'center-circle';
                else type = 'masonry';
            }

            switch (type) {
                case 'masonry':
                    const cols_masonry = numImages > 6 ? 3 : 2;
                    const colWidth_masonry = (area.w - (cols_masonry - 1) * gap) / cols_masonry;
                    let colHeights_masonry = Array(cols_masonry).fill(area.y);
                    images.forEach(img => {
                        const shortestColIndex = colHeights_masonry.indexOf(Math.min(...colHeights_masonry));
                        const imgHeight = (img.height / img.width) * colWidth_masonry;
                        addRect(area.x + shortestColIndex * (colWidth_masonry + gap), colHeights_masonry[shortestColIndex], colWidth_masonry, imgHeight);
                        colHeights_masonry[shortestColIndex] += imgHeight + gap;
                    });
                    break;
                case 'film-strip':
                    const framePaddingRatio = 0.15;
                    const itemH = area.h * (1 - 2 * framePaddingRatio);
                    if (itemH <= 0) break;
                    const totalWidth = images.reduce((acc, img) => acc + (img.width / img.height * itemH), 0);
                    const neededGap = (numImages - 1) * gap;
                    const scale = totalWidth > 0 ? (area.w - neededGap) / totalWidth : 0;
                    let currentX = area.x;
                    images.forEach(img => {
                        const itemW = (img.width / img.height * itemH) * scale;
                        addRect(currentX, area.y + area.h * framePaddingRatio, itemW, itemH);
                        currentX += itemW + gap;
                    });
                    break;
                case 'center-circle':
                    if (numImages > 0) {
                        const centerSize = Math.min(area.w, area.h) * 0.5;
                        addRect(area.x + (area.w - centerSize) / 2, area.y + (area.h - centerSize) / 2, centerSize, centerSize, 'circle');
                        const others = numImages - 1;
                        if (others > 0) {
                            const thumbSize = Math.min(area.w, area.h) * 0.2;
                            if (others >= 1) addRect(area.x + gap, area.y + gap, thumbSize, thumbSize);
                            if (others >= 2) addRect(area.x + area.w - thumbSize - gap, area.y + gap, thumbSize, thumbSize);
                            if (others >= 3) addRect(area.x + gap, area.y + area.h - thumbSize - gap, thumbSize, thumbSize);
                            if (others >= 4) addRect(area.x + area.w - thumbSize - gap, area.y + area.h - thumbSize - gap, thumbSize, thumbSize);
                        }
                    }
                    break;
                case 'asym-mosaic':
                     if (numImages === 1) { addRect(area.x, area.y, area.w, area.h); }
                    else if (numImages === 2) { const w = (area.w - gap) / 2; addRect(area.x, area.y, w, area.h); addRect(area.x + w + gap, area.y, w, area.h); }
                    else { 
                        const w1 = area.w * 0.6 - gap / 2;
                        const w2 = area.w * 0.4 - gap / 2;
                        addRect(area.x, area.y, w1, area.h);
                        const sideCount = numImages - 1;
                        const thumbH = (area.h - (sideCount - 1) * gap) / sideCount;
                        for (let i = 0; i < sideCount; i++) {
                            addRect(area.x + w1 + gap, area.y + i * (thumbH + gap), w2, thumbH);
                        }
                    }
                    break;
                case 'scattered-polaroids':
                    for (let i = 0; i < numImages; i++) {
                        const w = area.w / (numImages > 4 ? 3.5 : 2.5);
                        const h = w / (88/107);
                        const x = area.x + Math.random() * (area.w - w);
                        const y = area.y + Math.random() * (area.h - h);
                        const rot = Math.random() * 30 - 15;
                        addRect(x, y, w, h, 'rect', rot);
                    }
                    break;
                case 'columns':
                    const colW = (area.w - (numImages - 1) * gap) / numImages;
                    for (let i=0; i<numImages; i++) { addRect(area.x + i * (colW + gap), area.y, colW, area.h); }
                    break;
                case 'rows':
                    const rowH = (area.h - (numImages - 1) * gap) / numImages;
                    for (let i=0; i<numImages; i++) { addRect(area.x, area.y + i * (rowH + gap), area.w, rowH); }
                    break;
                case 'grid':
                    const cols = numImages === 3 ? 3 : Math.ceil(Math.sqrt(numImages * (area.w / area.h)));
                    const rows = numImages === 3 ? 1 : Math.ceil(numImages / cols);
                    const cellW = (area.w - (cols - 1) * gap) / cols;
                    const cellH = (area.h - (rows - 1) * gap) / rows;
                    for (let i = 0; i < numImages; i++) {
                        const c = i % cols; const r = Math.floor(i / cols);
                        addRect(area.x + c * (cellW + gap), area.y + r * (cellH + gap), cellW, cellH);
                    }
                    break;
                 case 'hero':
                    if (numImages > 1) {
                        const heroW = area.w * 0.66 - gap / 2;
                        addRect(area.x, area.y, heroW, area.h);
                        const sideCount = numImages - 1;
                        const thumbW = area.w - heroW - gap;
                        const thumbH = (area.h - (sideCount - 1) * gap) / sideCount;
                        for (let i = 0; i < sideCount; i++) {
                            addRect(area.x + heroW + gap, area.y + i * (thumbH + gap), thumbW, thumbH);
                        }
                    } else { addRect(area.x, area.y, area.w, area.h); }
                    break;
                case 'center-focus':
                    if (numImages === 1) { addRect(area.x, area.y, area.w, area.h); }
                    else if (numImages === 2) { const h = (area.h - gap)/2; addRect(area.x, area.y, area.w, h); addRect(area.x, area.y+h+gap, area.w, h); }
                    else {
                        const centerW = area.w * 0.5; const centerH = area.h * 0.5;
                        addRect(area.x + area.w * 0.25, area.y + area.h * 0.25, centerW, centerH);
                        const others = numImages - 1;
                        if (others > 0) {
                            const sideW = area.w * 0.25 - gap / 2;
                            const sideH = (area.h - (Math.ceil(others/2)-1) * gap) / Math.ceil(others/2);
                            for (let i=0; i < others; i++) {
                                if(i < Math.ceil(others/2)) addRect(area.x, area.y + i*(sideH+gap), sideW, sideH);
                                else addRect(area.x + area.w - sideW, area.y + (i-Math.ceil(others/2))*(sideH+gap), sideW, sideH);
                            }
                        }
                    }
                    break;
                case 'overlap':
                    for (let i = 0; i < numImages; i++) {
                        const overlapX = (i * 50); const overlapY = (i * 30);
                        const w = area.w - (numImages-1)*50; const h = area.h - (numImages-1)*30;
                        addRect(area.x + overlapX, area.y + overlapY, w, h);
                    }
                    break;
                case 'diagonal':
                    if (numImages === 1) { addRect(area.x, area.y, area.w, area.h); break; }
                    let x = area.x, y = area.y;
                    const w = (area.w - (numImages-1) * gap) / numImages;
                    const h = (area.h - (numImages-1) * gap) / numImages;
                    for (let i = 0; i < numImages; i++) {
                        addRect(x, y, w, h);
                        x += w + gap; y += h + gap;
                    }
                    break;
                case 'three-stack':
                    if (numImages === 1) { addRect(area.x, area.y, area.w, area.h); }
                    else if (numImages === 2) { const h = (area.h-gap)/2; addRect(area.x, area.y, area.w, h); addRect(area.x, area.y+h+gap, area.w, h); }
                    else { const h1 = area.h/2 - gap/2; const h2 = area.h/2 - gap/2; const w = (area.w - gap)/2; addRect(area.x, area.y, area.w, h1); addRect(area.x, area.y+h1+gap, w, h2); addRect(area.x+w+gap, area.y+h1+gap, w, h2); }
                    break;
                case 'pano':
                    if (numImages > 1) {
                        const panoH = area.h * 0.6 - gap / 2;
                        addRect(area.x, area.y, area.w, panoH);
                        const sideCount = numImages - 1;
                        const thumbH = area.h - panoH - gap;
                        const thumbW = (area.w - (sideCount - 1) * gap) / sideCount;
                        for (let i = 0; i < sideCount; i++) {
                            addRect(area.x + i * (thumbW + gap), area.y + panoH + gap, thumbW, thumbH);
                        }
                    } else { addRect(area.x, area.y, area.w, area.h); }
                    break;
                case 'mosaic':
                    if (numImages === 1) { addRect(area.x, area.y, area.w, area.h); }
                    else if (numImages === 2) { if(area.w > area.h) { const w = (area.w-gap)/2; addRect(area.x, area.y, w, area.h); addRect(area.x + w + gap, area.y, w, area.h); } else { const h = (area.h-gap)/2; addRect(area.x, area.y, area.w, h); addRect(area.x, area.y + h + gap, area.w, h); } } 
                    else if (numImages === 3) { if(area.w > area.h) { const w1=area.w*0.66-gap/2; const w2=area.w*0.33-gap/2; addRect(area.x, area.y, w1, area.h); addRect(area.x+w1+gap, area.y, w2, area.h/2-gap/2); addRect(area.x+w1+gap, area.y+area.h/2+gap/2, w2, area.h/2-gap/2); } else { const h1=area.h*0.66-gap/2; const h2=area.h*0.33-gap/2; addRect(area.x, area.y, area.w, h1); addRect(area.x, area.y+h1+gap, area.w/2-gap/2, h2); addRect(area.x+w2+gap/2, area.y+h1+gap, area.w/2-gap/2, h2); } }
                    else { const cols = Math.ceil(Math.sqrt(numImages)); const rows = Math.ceil(numImages / cols); const cellW = (area.w - (cols-1)*gap)/cols; const cellH = (area.h - (rows-1)*gap)/rows; for (let i = 0; i < numImages; i++) { const c=i%cols; const r=Math.floor(i/cols); addRect(area.x+c*(cellW+gap), area.y+r*(cellH+gap), cellW, cellH); } }
                    break;
                default:
                    const def_cols = numImages > 4 ? Math.ceil(Math.sqrt(numImages)) : (numImages > 1 ? 2 : 1);
                    const def_rows = Math.ceil(numImages / def_cols);
                    const cellW_def = (area.w - (def_cols - 1) * gap) / def_cols;
                    const cellH_def = (area.h - (def_rows - 1) * gap) / def_rows;
                    for (let i = 0; i < numImages; i++) { const c = i % def_cols; const r = Math.floor(i / def_cols); addRect(area.x + c * (cellW_def + gap), area.y + r * (cellH_def + gap), cellW_def, cellH_def); }
                    break;
            }
            return rects;
        }
        
        function drawRoundedImage(ctx, img, x, y, w, h, r, fit = 'contain', offset = { x: 0, y: 0 }, zoom = 1, shape = 'rect') {
            ctx.save();
            
            ctx.beginPath();
            if (shape === 'circle') {
                ctx.arc(x + w / 2, y + h / 2, Math.min(w, h) / 2, 0, Math.PI * 2, true);
            } else { // rounded rectangle
                ctx.moveTo(x + r, y); 
                ctx.arcTo(x + w, y, x + w, y + h, r); 
                ctx.arcTo(x + w, y + h, x, y + h, r); 
                ctx.arcTo(x, y + h, x, y, r); 
                ctx.arcTo(x, y, x + w, y, r);
            }
            ctx.closePath();
            ctx.clip();
            
            let sX = 0, sY = 0, sW = img.width, sH = img.height;
            if (fit === 'cover') {
                const imgRatio = img.width / img.height;
                const areaRatio = w / h;
                if (imgRatio > areaRatio) {
                    sH = img.height;
                    sW = sH * areaRatio;
                } else {
                    sW = img.width;
                    sH = sW / areaRatio;
                }

                sW /= zoom;
                sH /= zoom;
                
                sX = (img.width - sW) / 2 + (offset.x || 0);
                sY = (img.height - sH) / 2 + (offset.y || 0);

                sX = Math.max(0, Math.min(sX, img.width - sW));
                sY = Math.max(0, Math.min(sY, img.height - sH));
            }
            
            ctx.drawImage(img, sX, sY, sW, sH, x, y, w, h);
            ctx.restore();
        }

        function drawTextAndWatermark(targetCtx, w, h, scale = 1) {
            targetCtx.save();
            const margin = 20 * scale;
            if (state.text.content) {
                targetCtx.fillStyle = state.text.color;
                targetCtx.font = `bold ${state.text.size * scale}px ${state.text.font}`;
                targetCtx.textAlign = 'center';
                let x = w / 2, y;
                if (state.text.position.includes('top')) y = margin;
                else if (state.text.position.includes('bottom')) y = h - margin;
                else y = h / 2;
                if (state.text.position.includes('left')) { targetCtx.textAlign = 'left'; x = margin; }
                else if (state.text.position.includes('right')) { targetCtx.textAlign = 'right'; x = w - margin; }
                if (state.text.position.includes('top')) targetCtx.textBaseline = 'top';
                else if (state.text.position.includes('bottom')) targetCtx.textBaseline = 'bottom';
                else targetCtx.textBaseline = 'middle';
                targetCtx.shadowColor = 'rgba(0,0,0,0.5)'; targetCtx.shadowBlur = 5; targetCtx.shadowOffsetX = 2; targetCtx.shadowOffsetY = 2;
                targetCtx.fillText(state.text.content, x, y);
            }
            if (watermarkImage) {
                targetCtx.globalAlpha = state.watermark.opacity / 100;
                const wmRatio = watermarkImage.width / watermarkImage.height;
                const wmSize = (w * (state.watermark.size / 100));
                const wmWidth = wmSize; const wmHeight = wmWidth / wmRatio;
                let x, y;
                if (state.watermark.position.includes('left')) x = margin;
                else if (state.watermark.position.includes('right')) x = w - wmWidth - margin;
                else x = (w - wmWidth) / 2;
                if (state.watermark.position.includes('top')) y = margin;
                else if (state.watermark.position.includes('bottom')) y = h - wmHeight - margin;
                else y = (h - wmHeight) / 2;
                targetCtx.drawImage(watermarkImage, x, y, wmWidth, wmHeight);
            }
            targetCtx.restore();
        }

        function downloadImage() {
            downloadBtn.disabled = true;
            downloadBtn.textContent = 'Oluşturuluyor...';
            setTimeout(() => {
                const tempCanvas = document.createElement('canvas');
                const tempCtx = tempCanvas.getContext('2d');
                const qualityMultiplier = 2.5;
                const preset = presets[state.sizePreset];
                
                if (!preset && !(state.sizePreset === 'original' && mainImage && state.mode === 'single')) {
                     showToast("Lütfen bir kanvas boyutu seçin.", "error");
                     downloadBtn.disabled = false;
                     downloadBtn.textContent = 'İndir';
                     return;
                }

                if (state.mode === 'magnify' && mainImage) {
                    tempCanvas.width = preset.width * qualityMultiplier;
                    tempCanvas.height = preset.height * qualityMultiplier;
                    const scaleX = tempCanvas.width / canvas.width;
                    const scaleY = tempCanvas.height / canvas.height;
                    const renderMagnifyState = {
                        ...state.magnify,
                        frameX: state.magnify.frameX * scaleX, frameY: state.magnify.frameY * scaleY,
                        frameW: state.magnify.frameW * scaleX, frameH: state.magnify.frameH * scaleY,
                        borderWidth: state.magnify.borderWidth * Math.min(scaleX, scaleY),
                        blur: state.magnify.blur * Math.min(scaleX, scaleY)
                    };
                    drawMagnifyEffectOnContext(tempCtx, tempCanvas.width, tempCanvas.height, mainImage, renderMagnifyState);
                } else if (state.sizePreset === 'original' && mainImage && state.mode === 'single') {
                    tempCanvas.width = (mainImage.width + state.padding.left + state.padding.right) * qualityMultiplier;
                    tempCanvas.height = (mainImage.height + state.padding.top + state.padding.bottom) * qualityMultiplier;
                    tempCtx.clearRect(0, 0, tempCanvas.width, tempCanvas.height);
                    drawBackground(tempCtx, tempCanvas.width, tempCanvas.height);
                    drawMainContent(tempCtx, tempCanvas.width, tempCanvas.height, qualityMultiplier);
                    drawTextAndWatermark(tempCtx, tempCanvas.width, tempCanvas.height, qualityMultiplier);
                } else if (preset) {
                    tempCanvas.width = preset.width * qualityMultiplier;
                    tempCanvas.height = preset.height * qualityMultiplier;
                    tempCtx.clearRect(0, 0, tempCanvas.width, tempCanvas.height);
                    if (!['lightEffect', 'popOut'].includes(state.mode)) {
                        drawBackground(tempCtx, tempCanvas.width, tempCanvas.height);
                    }
                    drawMainContent(tempCtx, tempCanvas.width, tempCanvas.height, qualityMultiplier);
                    if (!['polaroid', 'doubleExposure', 'lightEffect', 'magnify', 'popOut'].includes(state.mode)) {
                        drawTextAndWatermark(tempCtx, tempCanvas.width, tempCanvas.height, qualityMultiplier);
                    }
                } else {
                     downloadBtn.disabled = false;
                     downloadBtn.textContent = 'İndir';
                     return;
                }

                const link = document.createElement('a');
                link.href = tempCanvas.toDataURL('image/png', 1.0);
                link.download = `${originalFileName}-${state.mode}-duzenlenmis.png`;
                link.click();
                downloadBtn.disabled = false;
                downloadBtn.textContent = 'İndir';
            }, 100);
        }
        
        function initDB() {
            const request = indexedDB.open('PhotoEditorDB', 1);
            request.onerror = (e) => console.error("Veritabanı hatası:", e.target.errorCode);
            request.onsuccess = (e) => { db = e.target.result; };
            request.onupgradeneeded = (e) => {
                const store = e.target.result.createObjectStore('projects', { keyPath: 'id', autoIncrement: true });
                store.createIndex('name', 'name', { unique: false });
            };
        }

        async function saveProject() {
            if (!db) { showToast("Veritabanı hazır değil.", "error"); return; }
            const projectName = prompt("Projenize bir isim verin:", "Yeni Projem " + new Date().toLocaleDateString());
            if (!projectName) return;
            const imageToBlob = async (img) => {
                if (!img || !img.src) return null;
                 if (img.src.startsWith('blob:')) return fetch(img.src).then(r => r.blob());
                return await fetch(img.src).then(r => r.blob());
            };
            syncStateWithUI();
            const projectData = {
                name: projectName,
                state: state,
                mainImage: await imageToBlob(mainImage),
                topImage: await imageToBlob(topImage),
                bottomImage: await imageToBlob(bottomImage),
                collageImages: await Promise.all(collageImages.map(img => imageToBlob(img))),
                watermarkImage: await imageToBlob(watermarkImage),
                savedAt: new Date()
            };
            const transaction = db.transaction(['projects'], 'readwrite');
            transaction.oncomplete = () => showToast(`'${projectName}' projesi kaydedildi!`);
            transaction.onerror = (e) => { console.error("Kaydetme hatası:", e.target.error); showToast("Proje kaydedilemedi.", "error"); };
            transaction.objectStore('projects').add(projectData);
        }

        async function showProjectsModal() {
            if (!db) { showToast("Veritabanı hazır değil.", "error"); return; }
            projectsModal.classList.remove('hidden');
            document.body.style.overflow = 'hidden';
            projectsModal.querySelector('.modal-content').classList.remove('scale-95');
            const store = db.transaction(['projects'], 'readonly').objectStore('projects');
            const request = store.getAll();
            request.onerror = (e) => console.error("Projeler yüklenemedi:", e.target.error);
            request.onsuccess = () => {
                const projects = request.result.sort((a, b) => new Date(b.savedAt) - new Date(a.savedAt));
                projectListContainer.innerHTML = projects.length === 0 ? `<p class="text-center text-gray-400">Kaydedilmiş proje bulunamadı.</p>` : '';
                projects.forEach(p => {
                    let previewUrl = 'https://placehold.co/100x75/4a5568/ffffff?text=O%CC%88nizleme';
                    if (p.mainImage) previewUrl = URL.createObjectURL(p.mainImage);
                    else if (p.bottomImage) previewUrl = URL.createObjectURL(p.bottomImage);
                    else if (p.collageImages && p.collageImages.length > 0) previewUrl = URL.createObjectURL(p.collageImages[0]);
                    const projectEl = document.createElement('div');
                    projectEl.className = 'glass-card flex items-center p-4 rounded-lg mb-4 hover:bg-white/10 transition-colors duration-200';
                    projectEl.innerHTML = `
                        <img src="${previewUrl}" class="w-24 h-24 object-cover rounded-md mr-4 bg-gray-700" onload="URL.revokeObjectURL(this.src)">
                        <div class="flex-grow">
                            <h3 class="font-bold text-lg text-white">${p.name}</h3>
                            <p class="text-sm text-gray-300">${new Date(p.savedAt).toLocaleString('tr-TR')}</p>
                        </div>
                        <div class="flex flex-col gap-2">
                            <button data-id="${p.id}" class="load-btn bg-sky-600 text-white px-4 py-2 rounded-md hover:bg-sky-700">Yükle</button>
                            <button data-id="${p.id}" class="delete-btn bg-red-600 text-white px-4 py-2 rounded-md hover:bg-red-700">Sil</button>
                        </div>
                    `;
                    projectListContainer.appendChild(projectEl);
                });
            };
        }
        
        projectListContainer.addEventListener('click', (e) => {
            const id = e.target.dataset.id;
            if (!id) return;
            if (e.target.classList.contains('load-btn')) { loadProjectById(parseInt(id)); } 
            else if (e.target.classList.contains('delete-btn')) {
                 if (confirm("Bu projeyi silmek istediğinizden emin misiniz? Bu işlem geri alınamaz.")) {
                     deleteProjectById(parseInt(id));
                 }
            }
        });

        function hideProjectsModal() {
            projectsModal.querySelector('.modal-content').classList.add('scale-95');
            projectsModal.classList.add('hidden');
            document.body.style.overflow = 'auto';
        }

        async function loadProjectById(id) {
            const request = db.transaction(['projects'], 'readonly').objectStore('projects').get(id);
            request.onerror = (e) => console.error("Proje yüklenemedi:", e.target.error);
            request.onsuccess = () => {
                const pData = request.result;
                if (!pData) return;
                state = { ...getDefaultState(), ...pData.state };
                history = []; historyIndex = -1;
                saveStateToHistory();

                const blobToImage = (blob) => !blob ? Promise.resolve(null) : new Promise(resolve => {
                    const img = new Image();
                    img.onload = () => resolve(img);
                    img.onerror = () => resolve(null);
                    img.src = URL.createObjectURL(blob);
                });
                
                Promise.all([
                    blobToImage(pData.mainImage),
                    blobToImage(pData.topImage),
                    blobToImage(pData.bottomImage),
                    Promise.all((pData.collageImages || []).map(b => blobToImage(b))),
                    blobToImage(pData.watermarkImage)
                ]).then(([loadedMain, loadedTop, loadedBottom, loadedCollage, loadedWatermark]) => {
                    mainImage = loadedMain;
                    topImage = loadedTop;
                    bottomImage = loadedBottom;
                    collageImages = loadedCollage;
                    watermarkImage = loadedWatermark;
                    
                    if (state.mode === 'collage' && (!state.collage.imageOffsets || state.collage.imageOffsets.length !== collageImages.length)) {
                        state.collage.imageOffsets = collageImages.map(() => ({ x: 0, y: 0 }));
                    }

                    updateUIFromState(state);
                    const hasImage = mainImage || (state.mode === 'collage' && collageImages.length > 0) || (state.mode === 'doubleExposure' && topImage && bottomImage);
                    if(hasImage) {
                        previewPlaceholder.classList.add('hidden');
                        canvasWrapper.style.display = 'flex';
                        canvasWrapper.classList.remove('hidden');
                        if (state.mode === 'collage') displayCollageThumbnails();
                    }
                    if(watermarkImage) {
                         document.getElementById('watermarkControls').classList.remove('hidden');
                    } else {
                         document.getElementById('watermarkControls').classList.add('hidden');
                         document.getElementById('watermarkLoader').value = '';
                    }
                    
                    updateAndDraw();
                    hideProjectsModal();
                    showToast(`'${pData.name}' projesi yüklendi.`);
                });
            };
        }

        function deleteProjectById(id) {
            const request = db.transaction(['projects'], 'readwrite').objectStore('projects').delete(id);
            request.onsuccess = () => {
                showToast("Proje silindi.", "info");
                showProjectsModal();
            };
            request.onerror = (e) => {
                console.error("Silme hatası:", e.target.error);
                showToast("Proje silinemedi.", "error");
            };
        }
        
        function showToast(message, type = 'success') {
            const toast = document.getElementById('toast');
            const toastMessage = document.getElementById('toastMessage');
            toastMessage.textContent = message;
            toast.className = 'px-6 py-3 text-white font-semibold rounded-lg shadow-lg z-50';
            if(type === 'success') toast.classList.add('bg-emerald-500');
            else if (type === 'error') toast.classList.add('bg-red-500');
            else if (type === 'info') toast.classList.add('bg-sky-500');
            toast.classList.add('show');
            setTimeout(() => { toast.classList.remove('show'); }, 3000);
        }
        
        function preloadFrameAssets() {
            for (const key in polaroidFrameSpecs) {
                const spec = polaroidFrameSpecs[key];
                if (spec.type === 'pattern') {
                    const img = new Image();
                    img.crossOrigin = "Anonymous";
                    img.src = spec.value;
                    img.onload = () => updateAndDraw();
                    frameImageAssets[spec.value] = img;
                }
            }
        }

        function populatePolaroidFrames() {
            polaroidFrameContainer.innerHTML = '';
            for (const key in polaroidFrameSpecs) {
                const spec = polaroidFrameSpecs[key];
                const button = document.createElement('button');
                button.className = 'frame-btn rounded-lg p-1';
                button.dataset.frame = key;
                
                const preview = document.createElement('div');
                preview.className = 'frame-preview flex items-center justify-center rounded-sm';
                if (spec.type === 'pattern') {
                    preview.style.backgroundImage = `url(${spec.value})`;
                } else {
                    preview.style.backgroundColor = spec.defaultColor || spec.value || '#ccc';
                }
                
                const imgPlaceholder = document.createElement('div');
                imgPlaceholder.className = 'frame-preview-img';
                
                const span = document.createElement('span');
                span.className = 'text-xs mt-1 block text-gray-200';
                span.textContent = spec.name;
                
                preview.appendChild(imgPlaceholder);
                button.appendChild(preview);
                button.appendChild(span);
                polaroidFrameContainer.appendChild(button);
            }
        }
        
        function populateLightPatterns() {
            lightPatternContainer.innerHTML = '';
            for (const key in lightPatterns) {
                const pattern = lightPatterns[key];
                const button = document.createElement('button');
                button.className = 'pattern-btn rounded-lg p-1 text-center';
                button.dataset.pattern = key;

                const previewCanvas = document.createElement('canvas');
                previewCanvas.width = 60;
                previewCanvas.height = 60;
                previewCanvas.className = 'bg-gray-700 rounded-md mx-auto pointer-events-none';
                const previewCtx = previewCanvas.getContext('2d');
                previewCtx.save();
                previewCtx.scale(0.2, 0.2); // Scale down for preview
                const patternImg = generateLightPattern(key, 300, 300, '#FFF');
                previewCtx.drawImage(patternImg, 0, 0);
                previewCtx.restore();
                
                const span = document.createElement('span');
                span.className = 'text-xs mt-1 block text-gray-200';
                span.textContent = pattern.name;

                button.appendChild(previewCanvas);
                button.appendChild(span);
                lightPatternContainer.appendChild(button);
            }
        }

        function init() {
            initDB();
            populatePolaroidFrames();
            populateLightPatterns();
            preloadFrameAssets();
            state = getDefaultState();
            updateUIFromState(state);
            updateAndDraw();
            saveStateToHistory();
            setupEventListeners();
        }
        
        window.onload = init;
    </script>
</body>
</html>
