<!DOCTYPE html>
<html lang="tr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Profesyonel Fotoğraf Editörü ve Kolaj</title>
    
    <script src="https://cdn.tailwindcss.com"></script>
    
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://css.gg/css" rel="stylesheet" />
    <link href="https://fonts.googleapis.com/css2?family=Caveat:wght@500&family=Inter:wght@400;500;600;700&family=Playfair+Display:wght@700&family=Roboto+Mono&display=swap" rel="stylesheet">
    <style>
        body { 
            font-family: 'Inter', sans-serif; 
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: #1a202c;
        }

        .glass-card {
            background: rgba(255, 255, 255, 0.15);
            -webkit-backdrop-filter: blur(20px) saturate(180%);
            backdrop-filter: blur(20px) saturate(180%);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .control-section { padding-top: 1.5rem; margin-top: 1.5rem; border-top: 1px solid rgba(255, 255, 255, 0.2); }
        .focus-ring:focus { box-shadow: 0 0 0 3px rgba(124, 58, 237, 0.5); outline: none; }
        .mode-btn, .fit-btn, .layout-btn { background-color: rgba(0, 0, 0, 0.1); color: #e2e8f0; transition: all 0.2s ease-in-out; }
        .mode-btn:hover, .fit-btn:hover, .layout-btn:hover { background-color: rgba(0, 0, 0, 0.2); }
        .mode-btn.active, .fit-btn.active, .layout-btn.active { background-color: rgba(20, 10, 50, 0.6); color: white; box-shadow: 0 4px 15px -1px rgba(0, 0, 0, 0.2); }
        .upload-area { transition: all 0.2s ease-in-out; border-color: rgba(255, 255, 255, 0.3);}
        .upload-area.drag-over { border-color: #a78bfa; background-color: rgba(167, 139, 250, 0.2); }

        select, input[type="text"], input[type="number"] { background-color: rgba(0, 0, 0, 0.15); border: 1px solid rgba(255, 255, 255, 0.2); color: white; }
        select option { background: #2d3748; color: white; }
        ::placeholder { color: #a0aec0; }
        
        input[type="color"] { -webkit-appearance: none; -moz-appearance: none; appearance: none; width: 100%; height: 40px; padding: 0; border: 1px solid rgba(255, 255, 255, 0.2); border-radius: 0.5rem; background-color: transparent; cursor: pointer; }
        input[type="color"]::-webkit-color-swatch-wrapper { padding: 4px; }
        input[type="color"]::-webkit-color-swatch { border: none; border-radius: 0.375rem; }

        input[type=range] { -webkit-appearance: none; background: transparent; width: 100%; }
        input[type=range]:focus { outline: none; }
        input[type=range]::-webkit-slider-runnable-track { width: 100%; height: 6px; cursor: pointer; background: rgba(0, 0, 0, 0.2); border-radius: 3px; }
        input[type=range]::-webkit-slider-thumb { -webkit-appearance: none; height: 20px; width: 20px; border-radius: 50%; background: #f7fafc; cursor: pointer; margin-top: -7px; box-shadow: 0 0 5px rgba(0,0,0,0.3); transition: transform .1s ease-in-out; }
        input[type=range]::-webkit-slider-thumb:hover { transform: scale(1.1); }
        input[type=range]::-moz-range-track { width: 100%; height: 6px; cursor: pointer; background: rgba(0, 0, 0, 0.2); border-radius: 3px; }
        input[type=range]::-moz-range-thumb { height: 20px; width: 20px; border-radius: 50%; background: #f7fafc; cursor: pointer; }

        .peer:checked ~ label { background-color: rgba(20, 10, 50, 0.6); color: white; border-color: transparent; }

        /* Polaroid Çerçeve Stilleri */
        .frame-btn { border: 2px solid transparent; transition: all 0.2s ease-in-out; overflow: hidden; }
        .frame-btn.active { border-color: #a78bfa; transform: scale(1.05); box-shadow: 0 0 15px rgba(167, 139, 250, 0.5); }
        .frame-preview { width: 60px; height: 72px; border: 2px solid #4a5568; background-size: cover; background-position: center; }
        .frame-preview-img { width: 80%; height: 70%; background: #718096; }

        /* Modal Stilleri */
        .modal-overlay { transition: opacity 0.3s ease; }
        .modal-content { transition: transform 0.3s ease; }
        
        /* Toast Bildirim Stilleri */
        #toast {
            position: fixed; bottom: -100px; left: 50%; transform: translateX(-50%);
            transition: bottom 0.5s ease-in-out; z-index: 100;
        }
        #toast.show { bottom: 30px; }

        /* Kolaj Sıralama ve Silme Stilleri */
        #collageThumbnailsContainer {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            padding: 10px;
            border-radius: 0.5rem;
            background-color: rgba(0,0,0,0.1);
        }
        .thumbnail-item {
            position: relative;
            cursor: grab;
            border: 2px solid transparent;
            border-radius: 0.375rem;
            transition: transform 0.2s, border-color 0.2s;
        }
        .thumbnail-item img {
            width: 60px;
            height: 60px;
            object-fit: cover;
            border-radius: 0.25rem;
            display: block;
        }
        .thumbnail-item.dragging {
            opacity: 0.5;
            transform: scale(1.1);
            border-color: #a78bfa;
        }
        .thumbnail-item.drag-over-thumb {
            border-color: #c4b5fd;
        }
        .delete-thumb-btn {
            position: absolute;
            top: -8px;
            right: -8px;
            width: 24px;
            height: 24px;
            background-color: rgba(239, 68, 68, 0.9);
            color: white;
            border: 2px solid white;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            font-weight: bold;
            line-height: 1;
            cursor: pointer;
            opacity: 0;
            transform: scale(0.8);
            transition: opacity 0.2s, transform 0.2s;
            z-index: 10;
        }
        .thumbnail-item:hover .delete-thumb-btn {
            opacity: 1;
            transform: scale(1);
        }
    </style>
</head>
<body class="p-4 lg:p-8">

    <div class="w-full max-w-8xl mx-auto grid grid-cols-1 lg:grid-cols-2 lg:gap-8 xl:gap-12">
        
        <div class="w-full glass-card rounded-2xl shadow-xl p-6 md:p-8 h-max">
            <div class="space-y-6">
                <div class="text-center">
                    <h1 class="text-3xl md:text-4xl font-bold text-white">Profesyonel Editör</h1>
                    <p class="mt-2 text-gray-300">Fotoğraflarınıza sanatsal dokunuşlar katın.</p>
                </div>
                
                <div class="grid grid-cols-4 gap-2 p-1 bg-black/10 rounded-lg">
                     <button id="singleModeBtn" class="mode-btn active py-2 rounded-md font-semibold">Tekli</button>
                     <button id="collageModeBtn" class="mode-btn py-2 rounded-md font-semibold">Kolaj</button>
                     <button id="polaroidModeBtn" class="mode-btn py-2 rounded-md font-semibold">Polaroid</button>
                     <button id="magnifierModeBtn" class="mode-btn py-2 rounded-md font-semibold">Büyüteç</button>
                </div>

                <div class="space-y-4">
                    <div>
                        <label id="imageLoaderLabel" class="block text-sm font-medium text-gray-200 mb-2">1. Fotoğraf Seçin (Kaydırmak için Alt tuşuna basın)</label>
                        <div id="singleUploader" class="upload-area p-4 border-2 border-dashed rounded-lg text-center">
                             <input type="file" id="imageLoader" accept="image/*" class="block w-full text-sm text-gray-300 file:mr-4 file:py-2 file:px-4 file:rounded-lg file:border-0 file:text-sm file:font-semibold file:bg-violet-500/30 file:text-violet-50 hover:file:bg-violet-500/50 cursor-pointer focus-ring rounded-lg">
                        </div>
                        <div id="collageUploader" class="hidden">
                            <div class="upload-area p-4 border-2 border-dashed rounded-lg text-center mb-4">
                                <input type="file" id="collageImageLoader" accept="image/*" multiple class="block w-full text-sm text-gray-300 file:mr-4 file:py-2 file:px-4 file:rounded-lg file:border-0 file:text-sm file:font-semibold file:bg-purple-500/30 file:text-purple-50 hover:file:bg-purple-500/50 cursor-pointer focus-ring rounded-lg">
                            </div>
                            <div id="collageThumbnailsWrapper" class="hidden">
                                <label class="block text-sm font-medium text-gray-200 mb-2">Resimleri Sırala (Sürükle) veya Sil (X)</label>
                                <div id="collageThumbnailsContainer"></div>
                            </div>
                        </div>
                    </div>

                    <div id="settingsPanel" class="pt-4">
                        <h2 class="text-lg font-semibold text-gray-100 mb-4 text-center">2. Düzenleme Araçları</h2>

                        <div id="sizeAndBackgroundSettings">
                             <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
                                <div>
                                    <label for="sizePreset" class="text-xs text-gray-300 mb-2 block">Kanvas Boyutu</label>
                                    <select id="sizePreset" class="w-full h-12 px-3 rounded-lg focus-ring">
                                        <option value="original">Orijinal Boyut</option>
                                        <optgroup label="Sosyal Medya">
                                            <option value="square" selected>Kare Post (1:1 - 1080x1080)</option>
                                            <option value="portrait45">Dikey Post (4:5 - 1080x1350)</option>
                                            <option value="story">Hikaye/Reels (9:16 - 1080x1920)</option>
                                            <option value="horizontal">Yatay Post (1.91:1 - 1080x566)</option>
                                            <option value="profile">Profil Fotoğrafı (1:1 - 320x320)</option>
                                        </optgroup>
                                    </select>
                                </div>
                                <div id="fitFillContainer">
                                    <label class="text-xs text-gray-300 mb-2 block">Fotoğraf Yerleşimi</label>
                                    <div class="grid grid-cols-2 gap-2 p-1 bg-black/10 rounded-lg h-12 items-center">
                                         <button id="fitContainBtn" class="fit-btn active py-2 rounded-md font-semibold text-sm">Sığdır</button>
                                         <button id="fitCoverBtn" class="fit-btn py-2 rounded-md font-semibold text-sm">Doldur</button>
                                    </div>
                                </div>
                            </div>
                            <div class="control-section">
                                <label class="block text-sm font-medium text-gray-200 mb-2">Arkaplan Stili</label>
                                <div class="grid grid-cols-4 gap-2">
                                    <div><input type="radio" name="bgType" id="bgSolid" value="solid" checked class="hidden peer"><label for="bgSolid" class="block text-center cursor-pointer rounded-lg border border-white/20 p-2 text-gray-200 text-sm">Renk</label></div>
                                    <div><input type="radio" name="bgType" id="bgGradient" value="gradient" class="hidden peer"><label for="bgGradient" class="block text-center cursor-pointer rounded-lg border border-white/20 p-2 text-gray-200 text-sm">Gradyan</label></div>
                                    <div><input type="radio" name="bgType" id="bgBlur" value="blur" class="hidden peer"><label for="bgBlur" class="block text-center cursor-pointer rounded-lg border border-white/20 p-2 text-gray-200 text-sm">Bulanık</label></div>
                                    <div><input type="radio" name="bgType" id="bgTransparent" value="transparent" class="hidden peer"><label for="bgTransparent" class="block text-center cursor-pointer rounded-lg border border-white/20 p-2 text-gray-200 text-sm">Transparan</label></div>
                                </div>
                                <div id="colorPickers" class="mt-4 grid grid-cols-2 gap-4">
                                    <input type="color" id="color1" value="#000000">
                                    <input type="color" id="color2" value="#4a5568" class="hidden">
                                </div>
                            </div>
                        </div>

                        <div id="standardSettings">
                            <div class="control-section">
                                 <label class="block text-sm font-medium text-gray-200">Dış Kenar Boşlukları (Padding)</label>
                                 <div class="flex items-center justify-start mt-2 mb-4"><input type="checkbox" id="syncPadding" checked class="h-4 w-4 rounded border-gray-500 text-violet-400 bg-transparent focus:ring-violet-500"><label for="syncPadding" class="ml-2 block text-sm text-gray-200">Tümünü eşitle</label></div>
                                <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-x-6 gap-y-4">
                                    <div><div class="flex justify-between items-center mb-1"><label for="paddingTop" class="text-xs text-gray-300">Üst</label><span id="paddingTopValue" class="text-sm font-semibold text-violet-300">0px</span></div><input type="range" id="paddingTop" value="0" min="0" max="300" class="padding-slider w-full"></div>
                                    <div><div class="flex justify-between items-center mb-1"><label for="paddingRight" class="text-xs text-gray-300">Sağ</label><span id="paddingRightValue" class="text-sm font-semibold text-violet-300">0px</span></div><input type="range" id="paddingRight" value="0" min="0" max="300" class="padding-slider w-full"></div>
                                    <div><div class="flex justify-between items-center mb-1"><label for="paddingBottom" class="text-xs text-gray-300">Alt</label><span id="paddingBottomValue" class="text-sm font-semibold text-violet-300">0px</span></div><input type="range" id="paddingBottom" value="0" min="0" max="300" class="padding-slider w-full"></div>
                                    <div><div class="flex justify-between items-center mb-1"><label for="paddingLeft" class="text-xs text-gray-300">Sol</label><span id="paddingLeftValue" class="text-sm font-semibold text-violet-300">0px</span></div><input type="range" id="paddingLeft" value="0" min="0" max="300" class="padding-slider w-full"></div>
                                </div>
                            </div>
                        </div>
                        
                        <div id="polaroidSettings" class="hidden">
                            <div class="control-section">
                                <label class="block text-sm font-medium text-gray-200 mb-3">Çerçeve Stili</label>
                                <div id="polaroidFrameContainer" class="grid grid-cols-3 sm:grid-cols-4 lg:grid-cols-5 gap-4">
                                    <!-- Çerçeveler JS ile eklenecek -->
                                </div>
                            </div>
                            <div class="control-section" id="polaroidColorSection">
                                <label for="polaroidFrameColor" class="block text-sm font-medium text-gray-200 mb-2">Çerçeve Rengi</label>
                                <input type="color" id="polaroidFrameColor" value="#ffffff">
                            </div>
                             <div class="control-section">
                                <label for="polaroidText" class="block text-sm font-medium text-gray-200 mb-2">El Yazısı Not</label>
                                <input type="text" id="polaroidText" placeholder="Kısa bir not ekle..." class="w-full p-2 rounded-lg" style="font-family: 'Caveat', cursive; font-size: 20px;">
                            </div>
                             <div class="control-section">
                                <label for="polaroidRotation" class="block text-sm font-medium text-gray-200 mb-2">Döndürme Açısı</label>
                                <input type="range" id="polaroidRotation" min="-15" max="15" value="5" class="w-full">
                            </div>
                             <div class="control-section">
                                <label for="polaroidZoom" class="block text-sm font-medium text-gray-200 mb-2">Yakınlaştırma</label>
                                <input type="range" id="polaroidZoom" min="100" max="300" value="100" class="w-full">
                            </div>
                        </div>

                        <div id="magnifierSettings" class="hidden">
                            <div class="control-section">
                                <label class="block text-sm font-medium text-gray-200 mb-3">Büyüteç Ayarları</label>
                                <div class="space-y-4">
                                    <div>
                                        <label for="magnifierFrameWidth" class="text-xs text-gray-300 mb-1 block">Çerçeve Genişliği</label>
                                        <input type="range" id="magnifierFrameWidth" min="20" max="100" value="60" class="w-full">
                                    </div>
                                    <div>
                                        <label for="magnifierAspectRatio" class="text-xs text-gray-300 mb-1 block">Çerçeve Oranı</label>
                                        <select id="magnifierAspectRatio" class="w-full h-10 px-3 rounded-lg focus-ring text-sm">
                                            <option value="1/1">Kare (1:1)</option>
                                            <option value="4/5">Dikey (4:5)</option>
                                            <option value="9/16">Hikaye (9:16)</option>
                                            <option value="16/9">Geniş (16:9)</option>
                                            <option value="free">Serbest</option>
                                        </select>
                                    </div>
                                    <div>
                                        <label for="magnifierZoom" class="text-xs text-gray-300 mb-1 block">Yakınlaştırma</label>
                                        <input type="range" id="magnifierZoom" min="100" max="500" value="150" class="w-full">
                                    </div>
                                    <div>
                                        <label for="magnifierBlur" class="text-xs text-gray-300 mb-1 block">Arkaplan Bulanıklığı</label>
                                        <input type="range" id="magnifierBlur" min="0" max="40" value="10" class="w-full">
                                    </div>
                                </div>
                            </div>
                        </div>

                        <div id="collageSettings" class="hidden control-section">
                             <label class="block text-sm font-medium text-gray-200 mb-4">Kolaj Ayarları</label>
                             <div class="grid grid-cols-1 gap-6 text-gray-300 text-xs">
                                <div>
                                    <label class="mb-1 block">İç Boşluk (Gap)</label>
                                    <input type="range" id="collageGap" value="10" min="0" max="100" class="w-full">
                                </div>
                                <div>
                                    <label class="mb-1 block">Köşe Yumuşatma</label>
                                    <input type="range" id="cornerRadius" min="0" max="100" value="0" class="w-full">
                                </div>
                                <div>
                                    <label class="mb-2 block">Kolaj Yerleşimi</label>
                                    <div class="flex flex-wrap gap-2" id="collageLayoutContainer">
                                        <button data-layout="auto" class="layout-btn active text-sm px-3 py-1 rounded">Oto</button>
                                        <button data-layout="grid" class="layout-btn text-sm px-3 py-1 rounded">Izgara</button>
                                        <button data-layout="hero" class="layout-btn text-sm px-3 py-1 rounded">Hero</button>
                                        <button data-layout="columns" class="layout-btn text-sm px-3 py-1 rounded">Sütun</button>
                                        <button data-layout="rows" class="layout-btn text-sm px-3 py-1 rounded">Sıra</button>
                                        <button data-layout="mosaic" class="layout-btn text-sm px-3 py-1 rounded">Mozaik</button>
                                        <button data-layout="center-focus" class="layout-btn text-sm px-3 py-1 rounded">Odak</button>
                                        <button data-layout="overlap" class="layout-btn text-sm px-3 py-1 rounded">Üst Üste</button>
                                        <button data-layout="diagonal" class="layout-btn text-sm px-3 py-1 rounded">Çapraz</button>
                                        <button data-layout="three-stack" class="layout-btn text-sm px-3 py-1 rounded">Üçlü Yığın</button>
                                        <button data-layout="pano" class="layout-btn text-sm px-3 py-1 rounded">Panoramik</button>
                                    </div>
                                </div>
                             </div>
                        </div>

                        <div id="generalTools">
                            <div class="control-section">
                                <label class="block text-sm font-medium text-gray-200 mb-2">Metin Ekle</label>
                                <input type="text" id="textInput" placeholder="Metninizi buraya yazın..." class="w-full p-2 rounded-lg">
                                <div class="grid grid-cols-2 md:grid-cols-4 gap-4 mt-4">
                                    <input type="color" id="textColor" value="#FFFFFF" title="Metin Rengi">
                                    <input type="number" id="textSize" value="48" title="Metin Boyutu" class="w-full p-2 rounded-lg">
                                    <select id="textFont" class="w-full p-2 rounded-lg">
                                        <option value="Inter">Inter</option>
                                        <option value="Playfair Display">Playfair</option>
                                        <option value="Roboto Mono">Mono</option>
                                        <option value="Caveat">Caveat</option>
                                    </select>
                                    <select id="textPosition" class="w-full p-2 rounded-lg">
                                        <option value="bottom-center">Alt-Orta</option>
                                        <option value="top-center">Üst-Orta</option>
                                        <option value="center-center">Orta</option>
                                    </select>
                                </div>
                            </div>

                            <div class="control-section">
                                <label class="block text-sm font-medium text-gray-200 mb-2">Filigran (Watermark)</label>
                                <input type="file" id="watermarkLoader" accept="image/png, image/jpeg" class="block w-full text-sm text-gray-300 file:mr-4 file:py-2 file:px-4 file:rounded-lg file:border-0 file:text-sm file:font-semibold file:bg-teal-500/30 file:text-teal-50 hover:file:bg-teal-500/50 cursor-pointer rounded-lg">
                                <div id="watermarkControls" class="hidden grid grid-cols-2 md:grid-cols-4 gap-4 mt-4 text-xs text-gray-300">
                                     <div><label>Opaklık</label><input type="range" id="watermarkOpacity" min="0" max="100" value="50" class="w-full"></div>
                                     <div><label>Boyut</label><input type="range" id="watermarkSize" min="5" max="100" value="20" class="w-full"></div>
                                     <select id="watermarkPosition" class="w-full p-2 rounded-lg col-span-2">
                                        <option value="bottom-right">Sağ Alt</option>
                                        <option value="bottom-left">Sol Alt</option>
                                        <option value="top-right">Sağ Üst</option>
                                        <option value="top-left">Sol Üst</option>
                                        <option value="center">Orta</option>
                                     </select>
                                </div>
                            </div>
                        </div>

                    </div>
                </div>

                <div class="flex flex-col sm:flex-row items-center justify-between gap-4 pt-6 border-t border-white/20 mt-6">
                    <div class="flex gap-2">
                        <button id="undoBtn" disabled title="Geri Al" class="bg-black/20 text-white font-bold p-3 rounded-lg hover:bg-black/30 disabled:opacity-50 disabled:cursor-not-allowed"><i class="gg-undo"></i></button>
                        <button id="redoBtn" disabled title="İleri Al" class="bg-black/20 text-white font-bold p-3 rounded-lg hover:bg-black/30 disabled:opacity-50 disabled:cursor-not-allowed"><i class="gg-redo"></i></button>
                    </div>
                    <div class="flex-grow flex gap-2 w-full sm:w-auto">
                        <button id="saveProjectBtn" class="w-full bg-emerald-600 text-white font-bold py-3 px-4 rounded-lg hover:bg-emerald-700 disabled:bg-gray-500 disabled:cursor-not-allowed">Projeyi Kaydet</button>
                        <button id="loadProjectBtn" class="w-full bg-sky-600 text-white font-bold py-3 px-4 rounded-lg hover:bg-sky-700">Projelerim</button>
                    </div>
                    <button id="downloadBtn" disabled class="w-full sm:w-auto bg-violet-600 text-white font-bold py-3 px-4 rounded-lg hover:bg-violet-700 focus:outline-none focus:ring-4 focus:ring-violet-400 transition-all duration-300 disabled:bg-gray-500 disabled:cursor-not-allowed shadow-lg shadow-violet-500/50">
                        İndir
                    </button>
                </div>
            </div>
        </div>

        <div class="w-full lg:sticky lg:top-8 h-max">
            <div id="previewArea" class="glass-card rounded-2xl shadow-xl p-4 min-h-[400px] lg:min-h-[calc(100vh-4rem)] flex items-center justify-center">
                <div id="previewPlaceholder" class="text-center text-gray-400">
                    <svg xmlns="http://www.w3.org/2000/svg" class="mx-auto h-16 w-16" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="1" d="M4 16l4.586-4.586a2 2 0 012.828 0L16 16m-2-2l-1-1m6-3a9 9 0 11-18 0 9 9 0 0118 0z" /></svg>
                    <p class="font-semibold text-lg mt-4">Önizleme Alanı</p>
                    <p class="text-sm">Bir fotoğraf yüklediğinizde burada görünecektir.</p>
                </div>
                <div id="canvasWrapper" class="hidden w-full h-full items-center justify-center">
                    <canvas id="canvas" class="max-w-full max-h-full"></canvas>
                </div>
            </div>
        </div>
    </div>

    
<div id="projectsModal" class="modal-overlay fixed inset-0 bg-black bg-opacity-60 flex items-center justify-center p-4 z-50 hidden">
        <div class="modal-content glass-card w-full max-w-4xl rounded-2xl shadow-2xl p-6 md:p-8 transform scale-95">
            <div class="flex justify-between items-center mb-6">
                <h2 class="text-2xl font-bold text-white">Projelerim</h2>
                <button id="closeModalBtn" class="text-gray-300 hover:text-white text-3xl font-bold">&times;</button>
            </div>
            <div id="projectList" class="max-h-[60vh] overflow-y-auto pr-2 grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-4">
                

</div>
        </div>
    </div>
    
    
<div id="toast" class="px-6 py-3 bg-emerald-500 text-white font-semibold rounded-lg shadow-lg">
        <p id="toastMessage"></p>
    </div>

    <script>
        // --- BU UYGULAMA GEMINI TARAFINDAN GELİŞTİRİLMİŞTİR ---
        // --- YENİ: İsteğiniz üzerine hareketli ve yakınlaştırmalı "Büyüteç" modu eklendi. ---
        
        const imageLoader = document.getElementById('imageLoader');
        const collageImageLoader = document.getElementById('collageImageLoader');
        const downloadBtn = document.getElementById('downloadBtn');
        const saveProjectBtn = document.getElementById('saveProjectBtn');
        const loadProjectBtn = document.getElementById('loadProjectBtn');
        const undoBtn = document.getElementById('undoBtn');
        const redoBtn = document.getElementById('redoBtn');
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const allUIInputs = document.querySelectorAll('input, select');
        const previewPlaceholder = document.getElementById('previewPlaceholder');
        const canvasWrapper = document.getElementById('canvasWrapper');
        const projectsModal = document.getElementById('projectsModal');
        const closeModalBtn = document.getElementById('closeModalBtn');
        const projectListContainer = document.getElementById('projectList');
        const collageUploaderDiv = document.getElementById('collageUploader');
        const singleUploaderDiv = document.getElementById('singleUploader');
        const collageThumbnailsWrapper = document.getElementById('collageThumbnailsWrapper');
        const collageThumbnailsContainer = document.getElementById('collageThumbnailsContainer');
        const polaroidFrameContainer = document.getElementById('polaroidFrameContainer');
        const polaroidColorSection = document.getElementById('polaroidColorSection');

        let db;
        let state = {};
        let history = [];
        let historyIndex = -1;
        let mainImage = null;
        let collageImages = [];
        let watermarkImage = null;
        let originalFileName = 'fotoğraf';
        
        let isPanning = false;
        let isModifierDown = false;
        let panStart = { x: 0, y: 0 };
        let activePanTarget = { type: null, index: -1 };
        let initialImageOffset = { x: 0, y: 0 }; 
        let draggedThumbnailIndex = null;
        let frameImageAssets = {};
        let isDraggingMagnifier = false;
        let dragStartOffset = { x: 0, y: 0 };

        const presets = {
            'original': null, 
            'square': { width: 1080, height: 1080 }, 
            'portrait45': { width: 1080, height: 1350 },
            'story': { width: 1080, height: 1920 },
            'horizontal': { width: 1080, height: 566 },
            'profile': { width: 320, height: 320 }
        };
        
        const polaroidFrameSpecs = {
            'classic': { name: 'Klasik', type: 'color', defaultColor: '#ffffff', textColor: '#2d3748', layout: 'classic' },
            'equal': { name: 'Eşit Kenar', type: 'color', defaultColor: '#ffffff', textColor: '#2d3748', layout: 'equal' },
            'top-heavy': { name: 'Ters Polaroid', type: 'color', defaultColor: '#ffffff', textColor: '#2d3748', layout: 'top-heavy' },
            'dark': { name: 'Siyah', type: 'color', defaultColor: '#2d3748', textColor: '#e2e8f0', layout: 'classic' },
            'vintage': { name: 'Vintage', type: 'color', defaultColor: '#fffae5', textColor: '#5a4a3a', layout: 'classic' },
            'film-kare': { name: 'Film Karesi', type: 'special', value: '#000000', textColor: '#e0e0e0', layout: 'equal' },
            'sprocket-light': { name: 'Film Şeridi (Açık)', type: 'effect', effectColor: 'rgba(255,255,255,0.8)', layout: 'equal' },
            'sprocket-dark': { name: 'Film Şeridi (Koyu)', type: 'effect', effectColor: 'rgba(0,0,0,0.7)', layout: 'equal' },
            'watercolor': { name: 'Suluboya', type: 'pattern', value: 'https://www.toptal.com/designers/subtlepatterns/uploads/watercolor.png', textColor: '#3a5a78', layout: 'classic' },
            'floral': { name: 'Çiçekli', type: 'pattern', value: 'https://www.toptal.com/designers/subtlepatterns/uploads/flowers.png', textColor: '#2a4b2a', layout: 'classic' },
            'galaxy': { name: 'Galaksi', type: 'pattern', value: 'https://images.pexels.com/photos/1169754/pexels-photo-1169754.jpeg?auto=compress&cs=tinysrgb&w=1260&h=750&dpr=1', textColor: '#e0e0ff', layout: 'classic' },
            'grunge': { name: 'Eskitme', type: 'pattern', value: 'https://www.toptal.com/designers/subtlepatterns/uploads/paper-fibers.png', textColor: '#4a4a4a', layout: 'classic' },
        };
        
        Object.keys(polaroidFrameSpecs).forEach(key => {
            polaroidFrameSpecs[key].aspectRatio = 88 / 107;
            if (polaroidFrameSpecs[key].layout === 'classic') {
                 polaroidFrameSpecs[key].photoPadding = 0.05;
            }
        });

        function getDefaultState() {
            return {
                mode: 'single', fit: 'contain', sizePreset: 'square',
                padding: { top: 0, right: 0, bottom: 0, left: 0 }, syncPadding: true,
                bgType: 'solid', color1: '#000000', color2: '#4a5568',
                imageOffset: { x: 0, y: 0 },
                collage: { 
                    gap: 10, 
                    layout: 'auto',
                    cornerRadius: 0,
                    imageOffsets: []
                },
                polaroid: {
                    frame: 'classic',
                    frameColor: '#ffffff',
                    text: '',
                    rotation: 5,
                    zoom: 100
                },
                magnifier: {
                    frameWidthRatio: 60,
                    aspectRatio: '1/1',
                    zoom: 150,
                    blur: 10,
                    frameX: 0,
                    frameY: 0,
                    isCentered: true
                },
                text: { content: '', color: '#FFFFFF', size: 48, font: 'Inter', position: 'bottom-center' },
                watermark: { opacity: 50, size: 20, position: 'bottom-right' }
            };
        }
        
        function syncStateWithUI() {
            const newFit = document.getElementById('fitContainBtn').classList.contains('active') ? 'contain' : 'cover';
            if (state.fit !== newFit) state.imageOffset = { x: 0, y: 0 };
            state.fit = newFit;
            
            const newPreset = document.getElementById('sizePreset').value;
             if (state.sizePreset !== newPreset) {
                state.imageOffset = { x: 0, y: 0 };
                if(state.collage.imageOffsets) {
                    state.collage.imageOffsets.forEach(offset => { offset.x = 0; offset.y = 0; });
                }
            }
            state.sizePreset = newPreset;

            if (document.getElementById('singleModeBtn').classList.contains('active')) state.mode = 'single';
            else if (document.getElementById('collageModeBtn').classList.contains('active')) state.mode = 'collage';
            else if (document.getElementById('polaroidModeBtn').classList.contains('active')) state.mode = 'polaroid';
            else if (document.getElementById('magnifierModeBtn').classList.contains('active')) state.mode = 'magnifier';
            
            state.syncPadding = document.getElementById('syncPadding').checked;
            state.padding = {
                top: parseInt(document.getElementById('paddingTop').value, 10),
                right: parseInt(document.getElementById('paddingRight').value, 10),
                bottom: parseInt(document.getElementById('paddingBottom').value, 10),
                left: parseInt(document.getElementById('paddingLeft').value, 10)
            };
            state.bgType = document.querySelector('input[name="bgType"]:checked').value;
            state.color1 = document.getElementById('color1').value;
            state.color2 = document.getElementById('color2').value;
            
            state.collage.gap = parseInt(document.getElementById('collageGap').value, 10);
            state.collage.cornerRadius = parseInt(document.getElementById('cornerRadius').value, 10);
            state.collage.layout = document.querySelector('#collageLayoutContainer .active')?.dataset.layout;
            
            state.polaroid.frame = document.querySelector('#polaroidFrameContainer .active')?.dataset.frame;
            state.polaroid.frameColor = document.getElementById('polaroidFrameColor').value;
            state.polaroid.text = document.getElementById('polaroidText').value;
            state.polaroid.rotation = parseInt(document.getElementById('polaroidRotation').value, 10);
            state.polaroid.zoom = parseInt(document.getElementById('polaroidZoom').value, 10);

            state.magnifier.frameWidthRatio = parseInt(document.getElementById('magnifierFrameWidth').value, 10);
            state.magnifier.aspectRatio = document.getElementById('magnifierAspectRatio').value;
            state.magnifier.zoom = parseInt(document.getElementById('magnifierZoom').value, 10);
            state.magnifier.blur = parseInt(document.getElementById('magnifierBlur').value, 10);

            state.text = {
                content: document.getElementById('textInput').value,
                color: document.getElementById('textColor').value,
                size: parseInt(document.getElementById('textSize').value, 10),
                font: document.getElementById('textFont').value,
                position: document.getElementById('textPosition').value,
            };
            state.watermark = {
                opacity: parseInt(document.getElementById('watermarkOpacity').value, 10),
                size: parseInt(document.getElementById('watermarkSize').value, 10),
                position: document.getElementById('watermarkPosition').value,
            };
        }

        function updateUIFromState(s) {
            document.getElementById('singleModeBtn').classList.toggle('active', s.mode === 'single');
            document.getElementById('collageModeBtn').classList.toggle('active', s.mode === 'collage');
            document.getElementById('polaroidModeBtn').classList.toggle('active', s.mode === 'polaroid');
            document.getElementById('magnifierModeBtn').classList.toggle('active', s.mode === 'magnifier');
            
            singleUploaderDiv.style.display = s.mode === 'single' || s.mode === 'polaroid' || s.mode === 'magnifier' ? 'block' : 'none';
            collageUploaderDiv.style.display = s.mode === 'collage' ? 'block' : 'none';

            const frameSpec = polaroidFrameSpecs[s.polaroid.frame];
            polaroidColorSection.style.display = s.mode === 'polaroid' && frameSpec && frameSpec.type === 'color' ? 'block' : 'none';
            document.getElementById('sizeAndBackgroundSettings').style.display = (s.mode === 'polaroid' && frameSpec && frameSpec.type === 'effect') || s.mode === 'magnifier' ? 'none' : 'block';

            document.getElementById('standardSettings').style.display = s.mode === 'single' || s.mode === 'collage' ? 'block' : 'none';
            document.getElementById('polaroidSettings').style.display = s.mode === 'polaroid' ? 'block' : 'none';
            document.getElementById('magnifierSettings').style.display = s.mode === 'magnifier' ? 'block' : 'none';
            document.getElementById('collageSettings').style.display = s.mode === 'collage' ? 'block' : 'none';
            document.getElementById('generalTools').style.display = s.mode === 'single' || s.mode === 'collage' ? 'block' : 'none';
            document.getElementById('fitFillContainer').style.visibility = s.mode === 'single' ? 'visible' : 'hidden';
            
            document.getElementById('sizePreset').value = s.sizePreset;
            
            document.getElementById('magnifierFrameWidth').value = s.magnifier.frameWidthRatio;
            document.getElementById('magnifierAspectRatio').value = s.magnifier.aspectRatio;
            document.getElementById('magnifierZoom').value = s.magnifier.zoom;
            document.getElementById('magnifierBlur').value = s.magnifier.blur;
        }

        function updateAndDraw(saveToHistory = true) {
            syncStateWithUI(); 
            if (saveToHistory) {
                saveStateToHistory();
            }
            updateUIFromState(state);
            drawPreview();

            const hasImage = (state.mode === 'single' && mainImage) || (state.mode === 'polaroid' && mainImage) || (state.mode === 'collage' && collageImages.length > 0) || (state.mode === 'magnifier' && mainImage);
            saveProjectBtn.disabled = !hasImage;
            downloadBtn.disabled = !hasImage;
        }

        function saveStateToHistory() {
            history = history.slice(0, historyIndex + 1);
            history.push(JSON.parse(JSON.stringify(state)));
            historyIndex++;
            updateUndoRedoButtons();
        }

        function undo() {
            if (historyIndex > 0) {
                historyIndex--;
                state = JSON.parse(JSON.stringify(history[historyIndex]));
                updateUIFromState(state);
                drawPreview();
                if(state.mode === 'collage') displayCollageThumbnails();
                updateUndoRedoButtons();
            }
        }

        function redo() {
            if (historyIndex < history.length - 1) {
                historyIndex++;
                state = JSON.parse(JSON.stringify(history[historyIndex]));
                updateUIFromState(state);
                drawPreview();
                if(state.mode === 'collage') displayCollageThumbnails();
                updateUndoRedoButtons();
            }
        }
        
        function updateUndoRedoButtons() {
            undoBtn.disabled = historyIndex <= 0;
            redoBtn.disabled = historyIndex >= history.length - 1;
        }
        
        function setupEventListeners() {
            document.getElementById('singleModeBtn').addEventListener('click', () => { if (state.mode !== 'single') switchMode('single'); });
            document.getElementById('collageModeBtn').addEventListener('click', () => { if (state.mode !== 'collage') switchMode('collage'); });
            document.getElementById('polaroidModeBtn').addEventListener('click', () => { if (state.mode !== 'polaroid') switchMode('polaroid'); });
            document.getElementById('magnifierModeBtn').addEventListener('click', () => { if (state.mode !== 'magnifier') switchMode('magnifier'); });
            
            document.getElementById('fitContainBtn').addEventListener('click', () => { setFitMode('contain'); });
            document.getElementById('fitCoverBtn').addEventListener('click', () => { setFitMode('cover'); });
            
            document.querySelectorAll('.padding-slider').forEach(s => s.addEventListener('input', handlePaddingSlider));
            document.getElementById('syncPadding').addEventListener('change', () => updateAndDraw());

            document.querySelectorAll('input[name="bgType"]').forEach(radio => radio.addEventListener('change', (e) => {
                document.getElementById('color2').style.display = e.target.value === 'gradient' ? 'block' : 'none';
                updateAndDraw();
            }));

            document.querySelectorAll('#collageLayoutContainer button').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    document.querySelector('#collageLayoutContainer .active')?.classList.remove('active');
                    e.currentTarget.classList.add('active');
                    updateAndDraw();
                });
            });
            
            polaroidFrameContainer.addEventListener('click', (e) => {
                const button = e.target.closest('.frame-btn');
                if (button) {
                    document.querySelector('#polaroidFrameContainer .active')?.classList.remove('active');
                    button.classList.add('active');
                    
                    const frameKey = button.dataset.frame;
                    const frameSpec = polaroidFrameSpecs[frameKey];
                    
                    if (frameSpec.type === 'color') {
                        state.polaroid.frameColor = frameSpec.defaultColor;
                        document.getElementById('polaroidFrameColor').value = frameSpec.defaultColor;
                    } else if (frameSpec.type === 'effect') {
                        document.getElementById('bgBlur').checked = true;
                    }
                    
                    updateAndDraw();
                }
            });

            allUIInputs.forEach(el => {
                const eventType = (el.type === 'range' || el.type === 'color') ? 'input' : 'change';
                 if (!el.classList.contains('padding-slider')) {
                    el.addEventListener(eventType, () => updateAndDraw(el.type !== 'range'));
                }
            });
            
            imageLoader.addEventListener('change', (e) => handleImageUpload(e.target.files[0]));
            collageImageLoader.addEventListener('change', (e) => handleCollageUpload(e.target.files));
            document.getElementById('watermarkLoader').addEventListener('change', handleWatermarkUpload);
            
            downloadBtn.addEventListener('click', downloadImage);
            saveProjectBtn.addEventListener('click', saveProject);
            loadProjectBtn.addEventListener('click', showProjectsModal);
            closeModalBtn.addEventListener('click', hideProjectsModal);
            projectsModal.addEventListener('click', (e) => { if(e.target === projectsModal) hideProjectsModal(); });
            undoBtn.addEventListener('click', undo);
            redoBtn.addEventListener('click', redo);
            
            canvasWrapper.addEventListener('mousedown', e => {
                const hasImage = (state.mode === 'single' && mainImage) || (state.mode === 'polaroid' && mainImage) || (state.mode === 'collage' && collageImages.length > 0) || (state.mode === 'magnifier' && mainImage);
                if (!hasImage) return;

                if (state.mode === 'magnifier') {
                    const canvasRect = canvas.getBoundingClientRect();
                    const mouseX = (e.clientX - canvasRect.left) * (canvas.width / canvasRect.width);
                    const mouseY = (e.clientY - canvasRect.top) * (canvas.height / canvasRect.height);
                    const { frameX, frameY, frameW, frameH } = getMagnifierFrameRect();
                    if (mouseX > frameX && mouseX < frameX + frameW && mouseY > frameY && mouseY < frameY + frameH) {
                        isDraggingMagnifier = true;
                        dragStartOffset.x = mouseX - frameX;
                        dragStartOffset.y = mouseY - frameY;
                        canvasWrapper.style.cursor = 'grabbing';
                    }
                    return;
                }

                if (!isModifierDown) return;
                panStart = { x: e.clientX, y: e.clientY };
                
                if (state.mode === 'single' || state.mode === 'polaroid') {
                    isPanning = true;
                    activePanTarget = { type: state.mode, index: -1 };
                    initialImageOffset = { ...state.imageOffset };
                } else if (state.mode === 'collage') { 
                    const canvasRect = canvas.getBoundingClientRect();
                    const mouse = {
                        x: (e.clientX - canvasRect.left) * (canvas.width / canvasRect.width),
                        y: (e.clientY - canvasRect.top) * (canvas.height / canvasRect.height)
                    };
                    const p = state.padding;
                    const area = { x: p.left, y: p.top, w: canvas.width - p.left - p.right, h: canvas.height - p.top - p.bottom };
                    const layout = getCollageLayout(state.collage.layout, collageImages.length, area, state.collage.gap);
                    const clickedIndex = layout.findIndex(rect => mouse.x >= rect.x && mouse.x <= rect.x + rect.w && mouse.y >= rect.y && mouse.y <= rect.y + rect.h);
                    if (clickedIndex > -1) {
                        isPanning = true;
                        activePanTarget = { type: 'collage', index: clickedIndex };
                        initialImageOffset = { ...state.collage.imageOffsets[clickedIndex] };
                    }
                }
                 if(isPanning) canvasWrapper.style.cursor = 'grabbing';
            });
            
            window.addEventListener('mousemove', e => {
                if (isDraggingMagnifier) {
                    const canvasRect = canvas.getBoundingClientRect();
                    const mouseX = (e.clientX - canvasRect.left) * (canvas.width / canvasRect.width);
                    const mouseY = (e.clientY - canvasRect.top) * (canvas.height / canvasRect.height);
                    
                    state.magnifier.frameX = mouseX - dragStartOffset.x;
                    state.magnifier.frameY = mouseY - dragStartOffset.y;
                    state.magnifier.isCentered = false;
                    
                    const { frameW, frameH } = getMagnifierFrameRect();
                    state.magnifier.frameX = Math.max(0, Math.min(canvas.width - frameW, state.magnifier.frameX));
                    state.magnifier.frameY = Math.max(0, Math.min(canvas.height - frameH, state.magnifier.frameY));

                    drawPreview();
                    return;
                }

                if (!isPanning) return;
                e.preventDefault();

                const previewRect = canvas.getBoundingClientRect();
                if (previewRect.width === 0) return;

                const previewScale = canvas.width / previewRect.width;
                const dx_canvas = (e.clientX - panStart.x) * previewScale;
                const dy_canvas = (e.clientY - panStart.y) * previewScale;
                
                let targetImage, container, zoom = 1;

                if (activePanTarget.type === 'single') {
                    targetImage = mainImage;
                    const p = state.padding;
                    container = { w: canvas.width - p.left - p.right, h: canvas.height - p.top - p.bottom };
                } else if (activePanTarget.type === 'polaroid') {
                    targetImage = mainImage;
                    const { photoW, photoH } = getPolaroidFrameDetails(canvas.width, canvas.height);
                    container = { w: photoW, h: photoH };
                    zoom = state.polaroid.zoom / 100;
                } else if (activePanTarget.type === 'collage') {
                    const p = state.padding;
                    const area = { x: p.left, y: p.top, w: canvas.width - p.left - p.right, h: canvas.height - p.top - p.bottom };
                    const layout = getCollageLayout(state.collage.layout, collageImages.length, area, state.collage.gap);
                    container = layout[activePanTarget.index];
                    targetImage = collageImages[activePanTarget.index];
                } else {
                    return;
                }

                if (!targetImage || !container || container.w <= 0) return;

                const imgRatio = targetImage.width / targetImage.height;
                const areaRatio = container.w / container.h;
                
                let renderScale;
                if (state.fit === 'cover' || activePanTarget.type === 'polaroid' || activePanTarget.type === 'collage') {
                     if (imgRatio > areaRatio) { 
                        renderScale = container.h / (targetImage.height / zoom);
                    } else { 
                        renderScale = container.w / (targetImage.width / zoom);
                    }
                } else { // contain
                    if (imgRatio > areaRatio) {
                        renderScale = container.w / (targetImage.width / zoom);
                    } else {
                        renderScale = container.h / (targetImage.height / zoom);
                    }
                }


                const dx_source = dx_canvas / renderScale;
                const dy_source = dy_canvas / renderScale;
                
                let newOffset = {
                    x: initialImageOffset.x - dx_source,
                    y: initialImageOffset.y - dy_source,
                };
                
                let sW, sH;
                if(imgRatio > areaRatio) { sH = targetImage.height; sW = sH * areaRatio; }
                else { sW = targetImage.width; sH = sW / areaRatio; }
                
                sW /= zoom; sH /= zoom;

                const maxOffsetX = Math.max(0, (targetImage.width - sW) / 2);
                const maxOffsetY = Math.max(0, (targetImage.height - sH) / 2);

                newOffset.x = Math.max(-maxOffsetX, Math.min(maxOffsetX, newOffset.x));
                newOffset.y = Math.max(-maxOffsetY, Math.min(maxOffsetY, newOffset.y));

                if (activePanTarget.type === 'single' || activePanTarget.type === 'polaroid') {
                    state.imageOffset = newOffset;
                } else {
                    state.collage.imageOffsets[activePanTarget.index] = newOffset;
                }

                drawPreview();
            });

            window.addEventListener('mouseup', () => {
                if (isDraggingMagnifier) {
                    isDraggingMagnifier = false;
                    updateCursor();
                    saveStateToHistory();
                }
                if (isPanning) {
                    isPanning = false;
                    activePanTarget = { type: null, index: -1 };
                    updateCursor();
                    saveStateToHistory();
                }
            });
            canvasWrapper.addEventListener('mouseenter', updateCursor);
            canvasWrapper.addEventListener('mouseleave', () => { canvasWrapper.style.cursor = 'default'; });

            window.addEventListener('keydown', e => {
                if (e.key === 'Alt') {
                    isModifierDown = true;
                    updateCursor();
                }
            });
            window.addEventListener('keyup', e => {
                if (e.key === 'Alt') {
                    isModifierDown = false;
                    updateCursor();
                }
            });
        }
        
        function switchMode(mode) {
            if((mode === 'magnifier' || mode === 'polaroid') && !mainImage) {
                showToast('Lütfen önce bir fotoğraf yükleyin.', 'error');
                return;
            }
            if(mode === 'collage' && collageImages.length === 0) {
                 showToast('Lütfen kolaj için en az bir fotoğraf yükleyin.', 'error');
                return;
            }
            state.magnifier.isCentered = true;
            
            state.mode = mode;
            updateUIFromState(state);
            updateAndDraw(); 
            saveStateToHistory();
        }

        function setFitMode(fit) {
            document.getElementById('fitContainBtn').classList.toggle('active', fit === 'contain');
            document.getElementById('fitCoverBtn').classList.toggle('active', fit === 'cover');
            updateAndDraw();
        }

        function updateCursor() {
            if (isDraggingMagnifier) {
                canvasWrapper.style.cursor = 'grabbing';
                return;
            }
            if(state.mode === 'magnifier' && mainImage) {
                canvasWrapper.style.cursor = 'grab';
                return;
            }
            const canPanSingle = state.mode === 'single' && mainImage && state.fit === 'cover';
            const canPanCollage = state.mode === 'collage' && collageImages.length > 0;
            const canPanPolaroid = state.mode === 'polaroid' && mainImage;

            if (isPanning) {
                 canvasWrapper.style.cursor = 'grabbing';
            } else if (isModifierDown && (canPanSingle || canPanCollage || canPanPolaroid)) {
                canvasWrapper.style.cursor = 'grab';
            } else {
                canvasWrapper.style.cursor = 'default';
            }
        }

        function handleImageUpload(file) {
            if (!file) return;
            originalFileName = file.name.split('.').slice(0, -1).join('.') || 'fotoğraf';
            const reader = new FileReader();
            reader.onload = e => {
                mainImage = new Image();
                mainImage.onload = () => {
                    previewPlaceholder.classList.add('hidden');
                    canvasWrapper.style.display = 'flex';
                    canvasWrapper.classList.remove('hidden');
                    state.imageOffset = { x: 0, y: 0 };
                    state.magnifier.isCentered = true;
                    updateAndDraw();
                };
                mainImage.src = e.target.result;
            };
            reader.readAsDataURL(file);
        }
        
        function drawPreview() {
            const hasImage = mainImage || collageImages.length > 0;
            if (!hasImage) {
                previewPlaceholder.classList.remove('hidden');
                canvasWrapper.classList.add('hidden');
                return;
            };

            const preset = presets[state.sizePreset];
            if (state.sizePreset === 'original' && mainImage && state.mode !== 'polaroid' && state.mode !== 'magnifier') {
                canvas.width = mainImage.width + state.padding.left + state.padding.right;
                canvas.height = mainImage.height + state.padding.top + state.padding.bottom;
            } else if (preset) {
                canvas.width = preset.width;
                canvas.height = preset.height;
            } else if (state.mode === 'polaroid' || state.mode === 'magnifier') {
                canvas.width = 1080;
                canvas.height = 1080;
            } else { 
                canvas.width = 1080;
                canvas.height = 1080;
            }
            
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            if (state.mode === 'magnifier' && mainImage) {
                 drawMagnifierEffect(ctx, canvas.width, canvas.height);
            } else {
                const frameSpec = polaroidFrameSpecs[state.polaroid.frame];
                if (state.mode === 'polaroid' && frameSpec && frameSpec.type === 'effect') {
                    state.bgType = 'blur';
                }
                drawBackground(ctx, canvas.width, canvas.height);
                drawMainContent(ctx, canvas.width, canvas.height);
                if (state.mode !== 'polaroid') {
                     drawTextAndWatermark(ctx, canvas.width, canvas.height);
                }
            }
        }

        function drawMainContent(targetCtx, w, h, scale = 1) {
            targetCtx.save();
            
            if (state.mode === 'polaroid' && mainImage) {
                drawPolaroidFrame(targetCtx, w, h, scale);
            } else if (state.mode === 'single' && mainImage) {
                 const p = { top: state.padding.top * scale, right: state.padding.right * scale, bottom: state.padding.bottom * scale, left: state.padding.left * scale };
                const drawableW = w - p.left - p.right;
                const drawableH = h - p.top - p.bottom;
                if (drawableW <= 0 || drawableH <= 0) { targetCtx.restore(); return; }
                if (state.fit === 'contain') {
                    const containerRatio = drawableW / drawableH;
                    const imgRatio = mainImage.width / mainImage.height;
                    let finalW, finalH;
                    if (imgRatio > containerRatio) { finalW = drawableW; finalH = finalW / imgRatio; } 
                    else { finalH = drawableH; finalW = finalH * imgRatio; }
                    const x = p.left + (drawableW - finalW) / 2;
                    const y = p.top + (drawableH - finalH) / 2;
                    drawRoundedImage(targetCtx, mainImage, x, y, finalW, finalH, 0, 'contain');
                } else { // 'cover'
                    const offset = state.imageOffset || { x: 0, y: 0 };
                    drawRoundedImage(targetCtx, mainImage, p.left, p.top, drawableW, drawableH, 0, 'cover', offset);
                }
            } else if (state.mode === 'collage' && collageImages.length > 0) {
                drawCollageLayout(targetCtx, w, h, scale);
            }
            
            targetCtx.restore();
        }
        
        function getMagnifierFrameRect() {
            const frameW = canvas.width * (state.magnifier.frameWidthRatio / 100);
            let frameH;
            if (state.magnifier.aspectRatio === 'free') {
                frameH = frameW; 
            } else {
                const [wRatio, hRatio] = state.magnifier.aspectRatio.split('/').map(Number);
                frameH = frameW * (hRatio / wRatio);
            }
            
            let frameX, frameY;
            if (state.magnifier.isCentered) {
                frameX = (canvas.width - frameW) / 2;
                frameY = (canvas.height - frameH) / 2;
                state.magnifier.frameX = frameX;
                state.magnifier.frameY = frameY;
            } else {
                frameX = state.magnifier.frameX;
                frameY = state.magnifier.frameY;
            }
            return { frameX, frameY, frameW, frameH };
        }

        function drawMagnifierEffect(targetCtx, w, h) {
            if (!mainImage) return;
            
            targetCtx.save();

            // 1. Draw blurred background
            targetCtx.filter = `blur(${state.magnifier.blur}px)`;
            const bgImgRatio = mainImage.width / mainImage.height;
            const canvasRatio = w / h;
            let bgW, bgH, bgX, bgY;
            if (bgImgRatio > canvasRatio) {
                bgH = h;
                bgW = bgH * bgImgRatio;
                bgX = (w - bgW) / 2;
                bgY = 0;
            } else {
                bgW = w;
                bgH = bgW / bgImgRatio;
                bgY = (h - bgH) / 2;
                bgX = 0;
            }
            targetCtx.drawImage(mainImage, bgX, bgY, bgW, bgH);
            targetCtx.filter = 'none';

            // 2. Get frame dimensions
            const { frameX, frameY, frameW, frameH } = getMagnifierFrameRect();

            // 3. Draw the focused, zoomed-in part
            targetCtx.save();
            targetCtx.beginPath();
            targetCtx.rect(frameX, frameY, frameW, frameH);
            targetCtx.clip();

            const zoom = state.magnifier.zoom / 100;
            
            const sW = mainImage.width / zoom;
            const sH = mainImage.height / zoom;
            const sX = (frameX - bgX) / bgW * mainImage.width - sW/2 + sW/(zoom*2);
            const sY = (frameY - bgY) / bgH * mainImage.height - sH/2 + sH/(zoom*2);
            
            targetCtx.drawImage(mainImage, sX, sY, sW, sH, frameX, frameY, frameW, frameH);
            targetCtx.restore();

            // 4. Draw the frame border
            targetCtx.strokeStyle = 'rgba(255, 255, 255, 0.8)';
            targetCtx.lineWidth = 4;
            targetCtx.strokeRect(frameX, frameY, frameW, frameH);

            targetCtx.restore();
        }

        function getPolaroidFrameDetails(w, h) {
            const frameSpec = polaroidFrameSpecs[state.polaroid.frame];
            if (!frameSpec) return {};

            const margin = Math.min(w, h) * 0.1;
            const availableW = w - 2 * margin;
            const availableH = h - 2 * margin;

            let frameW, frameH;
            if (availableW / frameSpec.aspectRatio <= availableH) {
                frameW = availableW;
                frameH = frameW / frameSpec.aspectRatio;
            } else {
                frameH = availableH;
                frameW = frameH * frameSpec.aspectRatio;
            }

            const frameX = (w - frameW) / 2;
            const frameY = (h - frameH) / 2;

            let photoX, photoY, photoW, photoH;
            const layout = frameSpec.layout || 'classic';

            if (layout === 'equal') {
                const p = 0.05;
                photoX = frameX + frameW * p;
                photoY = frameY + frameH * p;
                photoW = frameW * (1 - 2 * p);
                photoH = frameH * (1 - 2 * p);
            } else if (layout === 'top-heavy') {
                const pX = 0.05; const pTop = 0.25; const pBottom = 0.05;
                photoX = frameX + frameW * pX;
                photoY = frameY + frameH * pTop;
                photoW = frameW * (1 - 2 * pX);
                photoH = frameH - (frameH * pTop) - (frameH * pBottom);
            } else { // 'classic'
                const p = frameSpec.photoPadding;
                photoX = frameX + frameW * p;
                photoY = frameY + frameW * p;
                photoW = frameW * (1 - 2 * p);
                photoH = photoW;
            }
            return { frameX, frameY, frameW, frameH, photoX, photoY, photoW, photoH };
        }

        function drawPolaroidFrame(targetCtx, w, h, scale) {
            const frameSpec = polaroidFrameSpecs[state.polaroid.frame];
            if (!frameSpec) return;

            targetCtx.save();
            
            if (frameSpec.type === 'effect') {
                const margin = Math.min(w, h) * 0.05;
                const photoW = w - 2 * margin;
                const photoH = h - 2 * margin;
                const photoX = margin;
                const photoY = margin;
                drawRoundedImage(targetCtx, mainImage, photoX, photoY, photoW, photoH, 0, 'cover', state.imageOffset, state.polaroid.zoom / 100);
                targetCtx.strokeStyle = 'rgba(255,255,255,0.9)';
                targetCtx.lineWidth = margin * 0.05;
                targetCtx.strokeRect(photoX, photoY, photoW, photoH);
                targetCtx.fillStyle = frameSpec.effectColor;
                const holeW = photoW * 0.02;
                const holeH = photoH * 0.04;
                const holeMargin = holeW * 1.5;
                for (let i = photoY + holeMargin; i < photoY + photoH - holeMargin; i += holeH * 1.5) {
                    targetCtx.fillRect(photoX + holeMargin, i, holeW, holeH);
                    targetCtx.fillRect(photoX + photoW - holeMargin - holeW, i, holeW, holeH);
                }
                targetCtx.restore();
                return;
            }

            const { frameX, frameY, frameW, frameH, photoX, photoY, photoW, photoH } = getPolaroidFrameDetails(w, h);
            
            targetCtx.translate(frameX + frameW / 2, frameY + frameH / 2);
            targetCtx.rotate(state.polaroid.rotation * Math.PI / 180);
            targetCtx.translate(-(frameX + frameW / 2), -(frameY + frameH / 2));

            targetCtx.shadowColor = 'rgba(0,0,0,0.4)';
            targetCtx.shadowBlur = 30 * scale;
            targetCtx.shadowOffsetX = 5 * scale;
            targetCtx.shadowOffsetY = 10 * scale;

            if (frameSpec.type === 'color') {
                targetCtx.fillStyle = state.polaroid.frameColor;
            } else if (frameSpec.type === 'pattern' && frameImageAssets[spec.value] && frameImageAssets[spec.value].complete) {
                targetCtx.fillStyle = targetCtx.createPattern(frameImageAssets[spec.value], 'repeat');
            } else {
                targetCtx.fillStyle = frameSpec.value || '#ffffff';
            }
            targetCtx.fillRect(frameX, frameY, frameW, frameH);
            
            targetCtx.shadowColor = 'transparent';
            
            targetCtx.fillStyle = '#1a202c';
            targetCtx.fillRect(photoX, photoY, photoW, photoH);
            drawRoundedImage(targetCtx, mainImage, photoX, photoY, photoW, photoH, 0, 'cover', state.imageOffset, state.polaroid.zoom / 100);

            if (frameSpec.type === 'special' && state.polaroid.frame === 'film-kare') {
                targetCtx.save();
                targetCtx.fillStyle = frameSpec.textColor;
                targetCtx.font = `bold ${frameW * 0.025}px 'Roboto Mono', monospace`;
                targetCtx.textAlign = 'center';
                targetCtx.textBaseline = 'middle';
                
                targetCtx.translate(photoX + photoW + (frameW - (photoX + photoW - frameX))/2, photoY + photoH / 2);
                targetCtx.rotate(Math.PI / 2);
                targetCtx.fillText('KODAK HITS', 0, 0);
                targetCtx.restore();

                targetCtx.save();
                targetCtx.translate(photoX - (photoX - frameX)/2, photoY + photoH / 2);
                targetCtx.rotate(-Math.PI / 2);
                targetCtx.fillText('KODAK HITS', 0, 0);
                targetCtx.restore();
            }

            if(state.polaroid.text) {
                targetCtx.fillStyle = frameSpec.textColor;
                targetCtx.font = `${frameW * 0.05}px 'Caveat', cursive`;
                targetCtx.textAlign = 'center';
                targetCtx.textBaseline = 'middle';
                const bottomEdgeOfPhoto = photoY + photoH;
                const bottomEdgeOfFrame = frameY + frameH;
                const spaceBelowPhoto = bottomEdgeOfFrame - bottomEdgeOfPhoto;
                if (spaceBelowPhoto > (frameW * 0.06)) {
                    const textY = bottomEdgeOfPhoto + spaceBelowPhoto / 2;
                    targetCtx.fillText(state.polaroid.text, frameX + frameW / 2, textY, frameW * 0.9);
                }
            }
            targetCtx.restore();
        }
        
        function drawRoundedImage(ctx, img, x, y, w, h, r, fit = 'contain', offset = { x: 0, y: 0 }, zoom = 1) {
            ctx.save();
            if (r > 0) {
                ctx.beginPath();
                ctx.moveTo(x + r, y); ctx.arcTo(x + w, y, x + w, y + h, r); ctx.arcTo(x + w, y + h, x, y + h, r); ctx.arcTo(x, y + h, x, y, r); ctx.arcTo(x, y, x + w, y, r);
                ctx.closePath();
                ctx.clip();
            }
            
            let sX = 0, sY = 0, sW = img.width, sH = img.height;
            if (fit === 'cover') {
                const imgRatio = img.width / img.height;
                const areaRatio = w / h;
                if (imgRatio > areaRatio) {
                    sH = img.height;
                    sW = sH * areaRatio;
                } else {
                    sW = img.width;
                    sH = sW / areaRatio;
                }

                sW /= zoom;
                sH /= zoom;
                
                sX = (img.width - sW) / 2 + (offset.x || 0);
                sY = (img.height - sH) / 2 + (offset.y || 0);
            }
            
            ctx.drawImage(img, sX, sY, sW, sH, x, y, w, h);
            ctx.restore();
        }

        // --- ADDED MISSING FUNCTIONS ---

        function populatePolaroidFrames() {
            polaroidFrameContainer.innerHTML = '';
            Object.keys(polaroidFrameSpecs).forEach((key) => {
                const spec = polaroidFrameSpecs[key];
                const btn = document.createElement('button');
                btn.className = 'frame-btn p-1 rounded-lg flex flex-col items-center justify-center focus-ring';
                if (key === state.polaroid.frame) {
                    btn.classList.add('active');
                }
                btn.dataset.frame = key;
                btn.title = spec.name;

                const preview = document.createElement('div');
                preview.className = 'frame-preview rounded-md flex items-center justify-center';
                
                const previewImg = document.createElement('div');
                previewImg.className = 'frame-preview-img rounded-sm';

                if (spec.type === 'color') {
                    preview.style.backgroundColor = spec.defaultColor;
                } else if (spec.type === 'pattern' && spec.value) {
                    preview.style.backgroundImage = `url(${spec.value})`;
                } else if (spec.type === 'special') {
                    preview.style.backgroundColor = spec.value;
                } else { // effect
                    preview.style.background = 'linear-gradient(45deg, #888, #ddd)';
                }
                
                preview.appendChild(previewImg);

                const label = document.createElement('span');
                label.className = 'text-xs mt-1 text-gray-300 truncate w-full';
                label.textContent = spec.name;

                btn.appendChild(preview);
                btn.appendChild(label);
                polaroidFrameContainer.appendChild(btn);
            });
        }

        function preloadFrameAssets() {
            Object.values(polaroidFrameSpecs).forEach(spec => {
                if (spec.type === 'pattern' && spec.value) {
                    const img = new Image();
                    img.crossOrigin = 'Anonymous';
                    img.src = spec.value;
                    img.onload = () => {
                        if (state.mode === 'polaroid' && state.polaroid.frame === Object.keys(polaroidFrameSpecs).find(key => polaroidFrameSpecs[key] === spec)) {
                            drawPreview();
                        }
                        populatePolaroidFrames();
                    };
                    frameImageAssets[spec.value] = img;
                }
            });
        }

        function handlePaddingSlider(e) {
            const sliders = document.querySelectorAll('.padding-slider');
            const target = e.currentTarget;
            const value = target.value;
            document.getElementById(`${target.id}Value`).textContent = `${value}px`;

            if (document.getElementById('syncPadding').checked) {
                sliders.forEach(slider => {
                    slider.value = value;
                    document.getElementById(`${slider.id}Value`).textContent = `${value}px`;
                });
            }
            updateAndDraw(false); // No history for slider drag
        }
        
        sliders.forEach(s => s.addEventListener('change', () => updateAndDraw(true))); // Save history on release

        function drawBackground(ctx, w, h) {
            ctx.save();
            switch (state.bgType) {
                case 'solid':
                    ctx.fillStyle = state.color1;
                    ctx.fillRect(0, 0, w, h);
                    break;
                case 'gradient':
                    const gradient = ctx.createLinearGradient(0, 0, w, h);
                    gradient.addColorStop(0, state.color1);
                    gradient.addColorStop(1, state.color2);
                    ctx.fillStyle = gradient;
                    ctx.fillRect(0, 0, w, h);
                    break;
                case 'blur':
                    if (mainImage) {
                        ctx.filter = 'blur(20px)';
                        const imgRatio = mainImage.width / mainImage.height;
                        const canvasRatio = w / h;
                        let sWidth, sHeight;
                        if (imgRatio > canvasRatio) {
                            sHeight = h;
                            sWidth = sHeight * imgRatio;
                        } else {
                            sWidth = w;
                            sHeight = sWidth / imgRatio;
                        }
                        ctx.drawImage(mainImage, (w - sWidth) / 2, (h - sHeight) / 2, sWidth, sHeight);
                        ctx.filter = 'none';
                        ctx.fillStyle = 'rgba(0,0,0,0.3)';
                        ctx.fillRect(0,0,w,h);
                    } else {
                        ctx.fillStyle = '#333';
                        ctx.fillRect(0, 0, w, h);
                    }
                    break;
                case 'transparent':
                    // Do nothing, already clear
                    break;
            }
            ctx.restore();
        }

        function drawTextAndWatermark(ctx, w, h) {
            // Draw Text
            if (state.text.content) {
                ctx.save();
                ctx.font = `${state.text.size}px '${state.text.font}', sans-serif`;
                ctx.fillStyle = state.text.color;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                const lines = state.text.content.split('\n');
                let x, y;
                const [vAlign, hAlign] = state.text.position.split('-');
                
                if (hAlign === 'center') x = w / 2;
                if (hAlign === 'left') x = 20;
                if (hAlign === 'right') x = w - 20;

                const totalTextHeight = lines.length * state.text.size;
                if (vAlign === 'center') y = (h - totalTextHeight) / 2 + state.text.size / 2;
                if (vAlign === 'top') y = 20 + state.text.size / 2;
                if (vAlign === 'bottom') y = h - 20 - totalTextHeight + state.text.size / 2;

                lines.forEach((line, index) => {
                    ctx.fillText(line, x, y + index * state.text.size, w - 40);
                });
                ctx.restore();
            }

            // Draw Watermark
            if (watermarkImage) {
                ctx.save();
                const margin = 20;
                const wmAR = watermarkImage.width / watermarkImage.height;
                let wmH = h * (state.watermark.size / 100);
                let wmW = wmH * wmAR;
                if (wmW > w * (state.watermark.size / 100)) {
                    wmW = w * (state.watermark.size / 100);
                    wmH = wmW / wmAR;
                }
                
                let posX, posY;
                const [vAlign, hAlign] = state.watermark.position.split('-');
                
                if (hAlign === 'left') posX = margin;
                if (hAlign === 'right') posX = w - wmW - margin;
                if (hAlign === 'center') posX = (w - wmW) / 2;

                if (vAlign === 'top') posY = margin;
                if (vAlign === 'bottom') posY = h - wmH - margin;
                if (vAlign === 'center') posY = (h - wmH) / 2;

                if(state.watermark.position === 'center') {
                    posX = (w - wmW) / 2;
                    posY = (h - wmH) / 2;
                }

                ctx.globalAlpha = state.watermark.opacity / 100;
                ctx.drawImage(watermarkImage, posX, posY, wmW, wmH);
                ctx.restore();
            }
        }

        function getCollageLayout(layout, count, area, gap) {
            const rects = [];
            if (count === 0) return rects;
            const { x, y, w, h } = area;

            switch (layout) {
                case 'grid':
                    const cols = Math.ceil(Math.sqrt(count));
                    const rows = Math.ceil(count / cols);
                    const cellW = (w - (cols - 1) * gap) / cols;
                    const cellH = (h - (rows - 1) * gap) / rows;
                    for (let i = 0; i < count; i++) {
                        const row = Math.floor(i / cols);
                        const col = i % cols;
                        rects.push({ x: x + col * (cellW + gap), y: y + row * (cellH + gap), w: cellW, h: cellH });
                    }
                    break;
                case 'hero':
                    if (count === 1) {
                         rects.push({ x, y, w, h });
                    } else {
                        const heroW = w * 0.6 - gap / 2;
                        const sideW = w * 0.4 - gap / 2;
                        const sideH = (h - (count - 2) * gap) / (count - 1);
                        rects.push({ x, y, w: heroW, h });
                        for (let i = 1; i < count; i++) {
                            rects.push({ x: x + heroW + gap, y: y + (i - 1) * (sideH + gap), w: sideW, h: sideH });
                        }
                    }
                    break;
                // Add other layouts here...
                default: // auto / fallback
                    if (count === 1) rects.push({ x, y, w, h });
                    else if (count === 2) {
                        rects.push({ x, y, w: w / 2 - gap / 2, h });
                        rects.push({ x: x + w / 2 + gap / 2, y, w: w / 2 - gap / 2, h });
                    } else if (count === 3) {
                        rects.push({ x, y, w: w / 2 - gap / 2, h });
                        rects.push({ x: x + w / 2 + gap / 2, y, w: w / 2 - gap / 2, h: h / 2 - gap / 2 });
                        rects.push({ x: x + w / 2 + gap / 2, y: y + h / 2 + gap / 2, w: w / 2 - gap / 2, h: h / 2 - gap / 2 });
                    } else { // 4+
                        const cols = Math.ceil(Math.sqrt(count));
                        const rows = Math.ceil(count / cols);
                        const cellW = (w - (cols - 1) * gap) / cols;
                        const cellH = (h - (rows - 1) * gap) / rows;
                        for (let i = 0; i < count; i++) {
                            const row = Math.floor(i / cols);
                            const col = i % cols;
                            rects.push({ x: x + col * (cellW + gap), y: y + row * (cellH + gap), w: cellW, h: cellH });
                        }
                    }
            }
            return rects;
        }

        function drawCollageLayout(targetCtx, w, h, scale) {
            const p = { top: state.padding.top * scale, right: state.padding.right * scale, bottom: state.padding.bottom * scale, left: state.padding.left * scale };
            const area = { x: p.left, y: p.top, w: w - p.left - p.right, h: h - p.top - p.bottom };
            const layoutRects = getCollageLayout(state.collage.layout, collageImages.length, area, state.collage.gap * scale);
            
            layoutRects.forEach((rect, i) => {
                if (collageImages[i]) {
                    const offset = state.collage.imageOffsets[i] || { x: 0, y: 0 };
                    drawRoundedImage(targetCtx, collageImages[i], rect.x, rect.y, rect.w, rect.h, state.collage.cornerRadius, 'cover', offset);
                }
            });
        }
        
        function handleCollageUpload(files) {
            if (!files.length) return;
            let loadedCount = 0;
            const newImages = [];
            Array.from(files).forEach(file => {
                const reader = new FileReader();
                reader.onload = e => {
                    const img = new Image();
                    img.onload = () => {
                        newImages.push(img);
                        state.collage.imageOffsets.push({x:0, y:0});
                        loadedCount++;
                        if (loadedCount === files.length) {
                            collageImages.push(...newImages);
                            displayCollageThumbnails();
                            collageThumbnailsWrapper.style.display = 'block';
                            updateAndDraw();
                        }
                    };
                    img.src = e.target.result;
                };
                reader.readAsDataURL(file);
            });
        }

        function displayCollageThumbnails() {
            collageThumbnailsContainer.innerHTML = '';
            collageImages.forEach((img, index) => {
                const item = document.createElement('div');
                item.className = 'thumbnail-item';
                item.draggable = true;
                item.dataset.index = index;

                const thumbImg = new Image();
                thumbImg.src = img.src;
                item.appendChild(thumbImg);

                const deleteBtn = document.createElement('button');
                deleteBtn.className = 'delete-thumb-btn';
                deleteBtn.innerHTML = '&times;';
                deleteBtn.onclick = (e) => {
                    e.stopPropagation();
                    collageImages.splice(index, 1);
                    state.collage.imageOffsets.splice(index, 1);
                    displayCollageThumbnails();
                    updateAndDraw();
                };
                item.appendChild(deleteBtn);
                
                item.addEventListener('dragstart', e => {
                    draggedThumbnailIndex = index;
                    e.dataTransfer.effectAllowed = 'move';
                    setTimeout(() => item.classList.add('dragging'), 0);
                });

                item.addEventListener('dragend', () => {
                    item.classList.remove('dragging');
                    draggedThumbnailIndex = null;
                });

                item.addEventListener('dragover', e => {
                    e.preventDefault();
                    e.dataTransfer.dropEffect = 'move';
                    item.classList.add('drag-over-thumb');
                });
                
                item.addEventListener('dragleave', () => {
                    item.classList.remove('drag-over-thumb');
                });
                
                item.addEventListener('drop', e => {
                    e.preventDefault();
                    item.classList.remove('drag-over-thumb');
                    const droppedOnIndex = index;
                    if (draggedThumbnailIndex !== null && draggedThumbnailIndex !== droppedOnIndex) {
                        const draggedImg = collageImages.splice(draggedThumbnailIndex, 1)[0];
                        const draggedOffset = state.collage.imageOffsets.splice(draggedThumbnailIndex, 1)[0];
                        
                        collageImages.splice(droppedOnIndex, 0, draggedImg);
                        state.collage.imageOffsets.splice(droppedOnIndex, 0, draggedOffset);
                        
                        displayCollageThumbnails();
                        updateAndDraw();
                    }
                });

                collageThumbnailsContainer.appendChild(item);
            });
        }
        
        function handleWatermarkUpload(e) {
            const file = e.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = (event) => {
                watermarkImage = new Image();
                watermarkImage.onload = () => {
                    document.getElementById('watermarkControls').classList.remove('hidden');
                    updateAndDraw();
                };
                watermarkImage.src = event.target.result;
            };
            reader.readAsDataURL(file);
        }

        function downloadImage() {
            const link = document.createElement('a');
            link.download = `${originalFileName}-edited.png`;
            
            const tempCanvas = document.createElement('canvas');
            const tempCtx = tempCanvas.getContext('2d');
            const scale = 2; // for higher resolution
            tempCanvas.width = canvas.width * scale;
            tempCanvas.height = canvas.height * scale;

            if (state.mode === 'magnifier' && mainImage) {
                 drawMagnifierEffect(tempCtx, tempCanvas.width, tempCanvas.height);
            } else {
                drawBackground(tempCtx, tempCanvas.width, tempCanvas.height);
                drawMainContent(tempCtx, tempCanvas.width, tempCanvas.height, scale);
                 if (state.mode !== 'polaroid') {
                     drawTextAndWatermark(tempCtx, tempCanvas.width, tempCanvas.height);
                }
            }
            
            link.href = tempCanvas.toDataURL('image/png');
            link.click();
            showToast('İndirme tamamlandı!', 'success');
        }

        function saveProject() {
            const projects = JSON.parse(localStorage.getItem('photoEditorProjects') || '[]');
            const thumbnail = canvas.toDataURL('image/jpeg', 0.5);
            const projectData = {
                id: Date.now(),
                name: originalFileName,
                state: state,
                mainImage: mainImage ? mainImage.src : null,
                collageImages: collageImages.map(img => img.src),
                watermarkImage: watermarkImage ? watermarkImage.src : null,
                thumbnail: thumbnail
            };
            projects.unshift(projectData);
            localStorage.setItem('photoEditorProjects', JSON.stringify(projects.slice(0, 20))); // Limit to 20 projects
            showToast('Proje kaydedildi!', 'success');
        }

        function loadProject(projectData) {
            state = projectData.state;
            
            let imagesToLoad = 0;
            let imagesLoaded = 0;
            const onAllImagesLoaded = () => {
                updateUIFromState(state);
                updateAndDraw();
                hideProjectsModal();
                showToast('Proje yüklendi!', 'success');
            };

            const loadImage = (src, target) => {
                if (!src) return;
                imagesToLoad++;
                const img = new Image();
                img.onload = () => {
                    imagesLoaded++;
                    if (imagesLoaded === imagesToLoad) onAllImagesLoaded();
                };
                img.src = src;
                if (target === 'main') mainImage = img;
                if (target === 'watermark') watermarkImage = img;
                return img;
            };

            mainImage = null;
            collageImages = [];
            watermarkImage = null;

            loadImage(projectData.mainImage, 'main');
            loadImage(projectData.watermarkImage, 'watermark');
            if (projectData.collageImages) {
                collageImages = projectData.collageImages.map(src => loadImage(src, 'collage'));
            }

            if (imagesToLoad === 0) {
                onAllImagesLoaded();
            }
        }

        function showProjectsModal() {
            const projects = JSON.parse(localStorage.getItem('photoEditorProjects') || '[]');
            projectListContainer.innerHTML = '';
            if (projects.length === 0) {
                projectListContainer.innerHTML = `<p class="text-gray-400 col-span-full text-center">Kaydedilmiş proje bulunamadı.</p>`;
            } else {
                projects.forEach(p => {
                    const projectCard = document.createElement('div');
                    projectCard.className = 'glass-card rounded-lg p-2 flex flex-col items-center cursor-pointer hover:ring-2 ring-violet-400 transition-all';
                    projectCard.innerHTML = `
                        <img src="${p.thumbnail}" class="rounded-md w-full h-32 object-cover mb-2">
                        <p class="text-white text-sm font-semibold truncate w-full text-center">${p.name}</p>
                        <p class="text-gray-400 text-xs">${new Date(p.id).toLocaleDateString()}</p>
                    `;
                    projectCard.onclick = () => loadProject(p);
                    projectListContainer.appendChild(projectCard);
                });
            }
            projectsModal.classList.remove('hidden');
        }

        function hideProjectsModal() {
            projectsModal.classList.add('hidden');
        }

        function showToast(message, type = 'success') {
            const toast = document.getElementById('toast');
            const toastMessage = document.getElementById('toastMessage');
            toast.className = `px-6 py-3 text-white font-semibold rounded-lg shadow-lg ${type === 'success' ? 'bg-emerald-500' : 'bg-red-500'}`;
            toastMessage.textContent = message;
            toast.classList.add('show');
            setTimeout(() => {
                toast.classList.remove('show');
            }, 3000);
        }

        // --- END OF ADDED FUNCTIONS ---

        function init() {
            populatePolaroidFrames();
            preloadFrameAssets();
            state = getDefaultState();
            updateUIFromState(state);
            saveStateToHistory();
            setupEventListeners();
        }
        
        window.onload = init;
    </script>
</body>
</html>
