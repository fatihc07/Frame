<!DOCTYPE html>
<html lang="tr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Profesyonel Fotoğraf Editörü ve Kolaj</title>
    
    <script src="https://cdn.tailwindcss.com"></script>
    
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://css.gg/css" rel="stylesheet" />
    <link href="https://fonts.googleapis.com/css2?family=Caveat:wght@500&family=Inter:wght@400;500;600;700&family=Playfair+Display:wght@700&family=Roboto+Mono&display=swap" rel="stylesheet">
    <style>
        body { 
            font-family: 'Inter', sans-serif; 
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: #1a202c;
        }

        .glass-card {
            background: rgba(255, 255, 255, 0.15);
            -webkit-backdrop-filter: blur(20px) saturate(180%);
            backdrop-filter: blur(20px) saturate(180%);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .control-section { padding-top: 1.5rem; margin-top: 1.5rem; border-top: 1px solid rgba(255, 255, 255, 0.2); }
        .focus-ring:focus { box-shadow: 0 0 0 3px rgba(124, 58, 237, 0.5); outline: none; }
        .mode-btn, .fit-btn, .layout-btn { background-color: rgba(0, 0, 0, 0.1); color: #e2e8f0; transition: all 0.2s ease-in-out; }
        .mode-btn:hover, .fit-btn:hover, .layout-btn:hover { background-color: rgba(0, 0, 0, 0.2); }
        .mode-btn.active, .fit-btn.active, .layout-btn.active { background-color: rgba(20, 10, 50, 0.6); color: white; box-shadow: 0 4px 15px -1px rgba(0, 0, 0, 0.2); }
        .upload-area { transition: all 0.2s ease-in-out; border-color: rgba(255, 255, 255, 0.3);}
        .upload-area.drag-over { border-color: #a78bfa; background-color: rgba(167, 139, 250, 0.2); }

        select, input[type="text"], input[type="number"] { background-color: rgba(0, 0, 0, 0.15); border: 1px solid rgba(255, 255, 255, 0.2); color: white; }
        select option { background: #2d3748; color: white; }
        ::placeholder { color: #a0aec0; }
        
        input[type="color"] { -webkit-appearance: none; -moz-appearance: none; appearance: none; width: 100%; height: 40px; padding: 0; border: 1px solid rgba(255, 255, 255, 0.2); border-radius: 0.5rem; background-color: transparent; cursor: pointer; }
        input[type="color"]::-webkit-color-swatch-wrapper { padding: 4px; }
        input[type="color"]::-webkit-color-swatch { border: none; border-radius: 0.375rem; }

        input[type=range] { -webkit-appearance: none; background: transparent; width: 100%; }
        input[type=range]:focus { outline: none; }
        input[type=range]::-webkit-slider-runnable-track { width: 100%; height: 6px; cursor: pointer; background: rgba(0, 0, 0, 0.2); border-radius: 3px; }
        input[type=range]::-webkit-slider-thumb { -webkit-appearance: none; height: 20px; width: 20px; border-radius: 50%; background: #f7fafc; cursor: pointer; margin-top: -7px; box-shadow: 0 0 5px rgba(0,0,0,0.3); transition: transform .1s ease-in-out; }
        input[type=range]::-webkit-slider-thumb:hover { transform: scale(1.1); }
        input[type=range]::-moz-range-track { width: 100%; height: 6px; cursor: pointer; background: rgba(0, 0, 0, 0.2); border-radius: 3px; }
        input[type=range]::-moz-range-thumb { height: 20px; width: 20px; border-radius: 50%; background: #f7fafc; cursor: pointer; }

        .peer:checked ~ label { background-color: rgba(20, 10, 50, 0.6); color: white; border-color: transparent; }

        /* Polaroid Çerçeve Stilleri */
        .frame-btn { border: 2px solid transparent; transition: all 0.2s ease-in-out; overflow: hidden; }
        .frame-btn.active { border-color: #a78bfa; transform: scale(1.05); box-shadow: 0 0 15px rgba(167, 139, 250, 0.5); }
        .frame-preview { width: 60px; height: 72px; border: 2px solid #4a5568; background-size: cover; background-position: center; }
        .frame-preview-img { width: 80%; height: 70%; background: #718096; }

        /* Modal Stilleri */
        .modal-overlay { transition: opacity 0.3s ease; }
        .modal-content { transition: transform 0.3s ease; }
        
        /* Toast Bildirim Stilleri */
        #toast {
            position: fixed; bottom: -100px; left: 50%; transform: translateX(-50%);
            transition: bottom 0.5s ease-in-out; z-index: 100;
        }
        #toast.show { bottom: 30px; }

        /* Kolaj Sıralama ve Silme Stilleri */
        #collageThumbnailsContainer {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            padding: 10px;
            border-radius: 0.5rem;
            background-color: rgba(0,0,0,0.1);
        }
        .thumbnail-item {
            position: relative;
            cursor: grab;
            border: 2px solid transparent;
            border-radius: 0.375rem;
            transition: transform 0.2s, border-color 0.2s;
        }
        .thumbnail-item img {
            width: 60px;
            height: 60px;
            object-fit: cover;
            border-radius: 0.25rem;
            display: block;
        }
        .thumbnail-item.dragging {
            opacity: 0.5;
            transform: scale(1.1);
            border-color: #a78bfa;
        }
        .thumbnail-item.drag-over-thumb {
            border-color: #c4b5fd;
        }
        .delete-thumb-btn {
            position: absolute;
            top: -8px;
            right: -8px;
            width: 24px;
            height: 24px;
            background-color: rgba(239, 68, 68, 0.9);
            color: white;
            border: 2px solid white;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            font-weight: bold;
            line-height: 1;
            cursor: pointer;
            opacity: 0;
            transform: scale(0.8);
            transition: opacity 0.2s, transform 0.2s;
            z-index: 10;
        }
        .thumbnail-item:hover .delete-thumb-btn {
            opacity: 1;
            transform: scale(1);
        }
    </style>
</head>
<body class="p-4 lg:p-8">

    <div class="w-full max-w-8xl mx-auto grid grid-cols-1 lg:grid-cols-2 lg:gap-8 xl:gap-12">
        
        <div class="w-full glass-card rounded-2xl shadow-xl p-6 md:p-8 h-max">
            <div class="space-y-6">
                <div class="text-center">
                    <h1 class="text-3xl md:text-4xl font-bold text-white">Profesyonel Editör</h1>
                    <p class="mt-2 text-gray-300">Fotoğraflarınıza sanatsal dokunuşlar katın.</p>
                </div>
                
                <div class="grid grid-cols-4 gap-2 p-1 bg-black/10 rounded-lg">
                     <button id="singleModeBtn" class="mode-btn active py-2 rounded-md font-semibold">Tekli</button>
                     <button id="collageModeBtn" class="mode-btn py-2 rounded-md font-semibold">Kolaj</button>
                     <button id="polaroidModeBtn" class="mode-btn py-2 rounded-md font-semibold">Polaroid</button>
                     <button id="magnifyModeBtn" class="mode-btn py-2 rounded-md font-semibold">Büyüteç</button>
                </div>

                <div class="space-y-4">
                    <div>
                        <label id="imageLoaderLabel" class="block text-sm font-medium text-gray-200 mb-2">1. Fotoğraf Seçin</label>
                        <div id="singleUploader" class="upload-area p-4 border-2 border-dashed rounded-lg text-center">
                             <input type="file" id="imageLoader" accept="image/*" class="block w-full text-sm text-gray-300 file:mr-4 file:py-2 file:px-4 file:rounded-lg file:border-0 file:text-sm file:font-semibold file:bg-violet-500/30 file:text-violet-50 hover:file:bg-violet-500/50 cursor-pointer focus-ring rounded-lg">
                        </div>
                        <div id="collageUploader" class="hidden">
                            <div class="upload-area p-4 border-2 border-dashed rounded-lg text-center mb-4">
                                <input type="file" id="collageImageLoader" accept="image/*" multiple class="block w-full text-sm text-gray-300 file:mr-4 file:py-2 file:px-4 file:rounded-lg file:border-0 file:text-sm file:font-semibold file:bg-purple-500/30 file:text-purple-50 hover:file:bg-purple-500/50 cursor-pointer focus-ring rounded-lg">
                            </div>
                            <div id="collageThumbnailsWrapper" class="hidden">
                                <label class="block text-sm font-medium text-gray-200 mb-2">Resimleri Sırala (Sürükle) veya Sil (X)</label>
                                <div id="collageThumbnailsContainer"></div>
                            </div>
                        </div>
                    </div>

                    <div id="settingsPanel" class="pt-4">
                        <h2 class="text-lg font-semibold text-gray-100 mb-4 text-center">2. Düzenleme Araçları</h2>

                        <div id="canvasSizeSettings">
                             <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
                                <div>
                                    <label for="sizePreset" class="text-xs text-gray-300 mb-2 block">Kanvas Boyutu</label>
                                    <select id="sizePreset" class="w-full h-12 px-3 rounded-lg focus-ring">
                                        <option value="original">Orijinal Boyut</option>
                                        <optgroup label="Sosyal Medya">
                                            <option value="square" selected>Kare Post (1:1 - 1080x1080)</option>
                                            <option value="portrait45">Dikey Post (4:5 - 1080x1350)</option>
                                            <option value="story">Hikaye/Reels (9:16 - 1080x1920)</option>
                                            <option value="horizontal">Yatay Post (1.91:1 - 1080x566)</option>
                                            <option value="profile">Profil Fotoğrafı (1:1 - 320x320)</option>
                                        </optgroup>
                                    </select>
                                </div>
                                <div id="fitFillContainer">
                                    <label class="text-xs text-gray-300 mb-2 block">Fotoğraf Yerleşimi</label>
                                    <div class="grid grid-cols-2 gap-2 p-1 bg-black/10 rounded-lg h-12 items-center">
                                         <button id="fitContainBtn" class="fit-btn active py-2 rounded-md font-semibold text-sm">Sığdır</button>
                                         <button id="fitCoverBtn" class="fit-btn py-2 rounded-md font-semibold text-sm">Doldur</button>
                                    </div>
                                </div>
                            </div>
                        </div>

                        <div id="backgroundStyleSettings">
                            <div class="control-section">
                                <label class="block text-sm font-medium text-gray-200 mb-2">Arkaplan Stili</label>
                                <div class="grid grid-cols-4 gap-2">
                                    <div><input type="radio" name="bgType" id="bgSolid" value="solid" checked class="hidden peer"><label for="bgSolid" class="block text-center cursor-pointer rounded-lg border border-white/20 p-2 text-gray-200 text-sm">Renk</label></div>
                                    <div><input type="radio" name="bgType" id="bgGradient" value="gradient" class="hidden peer"><label for="bgGradient" class="block text-center cursor-pointer rounded-lg border border-white/20 p-2 text-gray-200 text-sm">Gradyan</label></div>
                                    <div><input type="radio" name="bgType" id="bgBlur" value="blur" class="hidden peer"><label for="bgBlur" class="block text-center cursor-pointer rounded-lg border border-white/20 p-2 text-gray-200 text-sm">Bulanık</label></div>
                                    <div><input type="radio" name="bgType" id="bgTransparent" value="transparent" class="hidden peer"><label for="bgTransparent" class="block text-center cursor-pointer rounded-lg border border-white/20 p-2 text-gray-200 text-sm">Transparan</label></div>
                                </div>
                                <div id="colorPickers" class="mt-4 grid grid-cols-2 gap-4">
                                    <input type="color" id="color1" value="#000000">
                                    <input type="color" id="color2" value="#4a5568" class="hidden">
                                </div>
                            </div>
                        </div>

                        <div id="standardSettings">
                            <div class="control-section">
                                 <label class="block text-sm font-medium text-gray-200">Dış Kenar Boşlukları (Padding)</label>
                                 <div class="flex items-center justify-start mt-2 mb-4"><input type="checkbox" id="syncPadding" checked class="h-4 w-4 rounded border-gray-500 text-violet-400 bg-transparent focus:ring-violet-500"><label for="syncPadding" class="ml-2 block text-sm text-gray-200">Tümünü eşitle</label></div>
                                <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-x-6 gap-y-4">
                                    <div><div class="flex justify-between items-center mb-1"><label for="paddingTop" class="text-xs text-gray-300">Üst</label><span id="paddingTopValue" class="text-sm font-semibold text-violet-300">0px</span></div><input type="range" id="paddingTop" value="0" min="0" max="300" class="padding-slider w-full"></div>
                                    <div><div class="flex justify-between items-center mb-1"><label for="paddingRight" class="text-xs text-gray-300">Sağ</label><span id="paddingRightValue" class="text-sm font-semibold text-violet-300">0px</span></div><input type="range" id="paddingRight" value="0" min="0" max="300" class="padding-slider w-full"></div>
                                    <div><div class="flex justify-between items-center mb-1"><label for="paddingBottom" class="text-xs text-gray-300">Alt</label><span id="paddingBottomValue" class="text-sm font-semibold text-violet-300">0px</span></div><input type="range" id="paddingBottom" value="0" min="0" max="300" class="padding-slider w-full"></div>
                                    <div><div class="flex justify-between items-center mb-1"><label for="paddingLeft" class="text-xs text-gray-300">Sol</label><span id="paddingLeftValue" class="text-sm font-semibold text-violet-300">0px</span></div><input type="range" id="paddingLeft" value="0" min="0" max="300" class="padding-slider w-full"></div>
                                </div>
                            </div>
                        </div>
                        
                        <div id="polaroidSettings" class="hidden">
                            <div class="control-section">
                                <label class="block text-sm font-medium text-gray-200 mb-3">Çerçeve Stili</label>
                                <div id="polaroidFrameContainer" class="grid grid-cols-3 sm:grid-cols-4 lg:grid-cols-5 gap-4">
                                    <!-- Çerçeveler JS ile eklenecek -->
                                </div>
                            </div>
                            <div class="control-section" id="polaroidColorSection">
                                <label for="polaroidFrameColor" class="block text-sm font-medium text-gray-200 mb-2">Çerçeve Rengi</label>
                                <input type="color" id="polaroidFrameColor" value="#ffffff">
                            </div>
                             <div class="control-section">
                                <label for="polaroidText" class="block text-sm font-medium text-gray-200 mb-2">El Yazısı Not</label>
                                <input type="text" id="polaroidText" placeholder="Kısa bir not ekle..." class="w-full p-2 rounded-lg" style="font-family: 'Caveat', cursive; font-size: 20px;">
                            </div>
                             <div class="control-section">
                                <label for="polaroidRotation" class="block text-sm font-medium text-gray-200 mb-2">Döndürme Açısı</label>
                                <input type="range" id="polaroidRotation" min="-15" max="15" value="5" class="w-full">
                            </div>
                             <div class="control-section">
                                <label for="polaroidZoom" class="block text-sm font-medium text-gray-200 mb-2">Yakınlaştırma</label>
                                <input type="range" id="polaroidZoom" min="100" max="300" value="100" class="w-full">
                            </div>
                        </div>
                        
                        <div id="magnifySettings" class="hidden">
                            <div class="control-section space-y-4 text-gray-200 text-sm">
                                <div>
                                    <label for="magnifyBlur" class="block mb-1">Arkaplan Bulanıklığı</label>
                                    <input type="range" id="magnifyBlur" min="0" max="40" value="10" class="w-full">
                                </div>
                                <div>
                                    <label for="magnifyZoom" class="block mb-1">Çerçeve İçi Yakınlaştırma</label>
                                    <input type="range" id="magnifyZoom" min="1" max="5" value="1.5" step="0.1" class="w-full">
                                </div>
                                <div class="grid grid-cols-2 gap-4">
                                    <div>
                                        <label for="magnifyFrameWidth" class="block mb-1">Çerçeve Genişliği</label>
                                        <input type="range" id="magnifyFrameWidth" min="100" max="1000" value="300" class="w-full">
                                    </div>
                                    <div>
                                        <label for="magnifyFrameHeight" class="block mb-1">Çerçeve Yüksekliği</label>
                                        <input type="range" id="magnifyFrameHeight" min="100" max="1000" value="450" class="w-full">
                                    </div>
                                </div>
                                <div class="grid grid-cols-2 gap-4">
                                     <div>
                                        <label for="magnifyBorderWidth" class="block mb-1">Çerçeve Kalınlığı</label>
                                        <input type="range" id="magnifyBorderWidth" min="0" max="50" value="10" class="w-full">
                                    </div>
                                    <div>
                                        <label for="magnifyBorderColor" class="block mb-1">Çerçeve Rengi</label>
                                        <input type="color" id="magnifyBorderColor" value="#ffffff">
                                    </div>
                                </div>
                            </div>
                        </div>

                        <div id="collageSettings" class="hidden control-section">
                             <label class="block text-sm font-medium text-gray-200 mb-4">Kolaj Ayarları</label>
                             <div class="grid grid-cols-1 gap-6 text-gray-300 text-xs">
                                <div>
                                    <label class="mb-1 block">İç Boşluk (Gap)</label>
                                    <input type="range" id="collageGap" value="10" min="0" max="100" class="w-full">
                                </div>
                                <div>
                                    <label class="mb-1 block">Köşe Yumuşatma</label>
                                    <input type="range" id="cornerRadius" min="0" max="100" value="0" class="w-full">
                                </div>
                                <div>
                                    <label class="mb-2 block">Kolaj Yerleşimi</label>
                                    <div class="flex flex-wrap gap-2" id="collageLayoutContainer">
                                        <button data-layout="auto" class="layout-btn active text-sm px-3 py-1 rounded">Oto</button>
                                        <button data-layout="grid" class="layout-btn text-sm px-3 py-1 rounded">Izgara</button>
                                        <button data-layout="hero" class="layout-btn text-sm px-3 py-1 rounded">Hero</button>
                                        <button data-layout="columns" class="layout-btn text-sm px-3 py-1 rounded">Sütun</button>
                                        <button data-layout="rows" class="layout-btn text-sm px-3 py-1 rounded">Sıra</button>
                                        <button data-layout="mosaic" class="layout-btn text-sm px-3 py-1 rounded">Mozaik</button>
                                        <button data-layout="center-focus" class="layout-btn text-sm px-3 py-1 rounded">Odak</button>
                                        <button data-layout="overlap" class="layout-btn text-sm px-3 py-1 rounded">Üst Üste</button>
                                        <button data-layout="diagonal" class="layout-btn text-sm px-3 py-1 rounded">Çapraz</button>
                                        <button data-layout="three-stack" class="layout-btn text-sm px-3 py-1 rounded">Üçlü Yığın</button>
                                        <button data-layout="pano" class="layout-btn text-sm px-3 py-1 rounded">Panoramik</button>
                                    </div>
                                </div>
                             </div>
                        </div>

                        <div id="generalTools">
                            <div class="control-section">
                                <label class="block text-sm font-medium text-gray-200 mb-2">Metin Ekle</label>
                                <input type="text" id="textInput" placeholder="Metninizi buraya yazın..." class="w-full p-2 rounded-lg">
                                <div class="grid grid-cols-2 md:grid-cols-4 gap-4 mt-4">
                                    <input type="color" id="textColor" value="#FFFFFF" title="Metin Rengi">
                                    <input type="number" id="textSize" value="48" title="Metin Boyutu" class="w-full p-2 rounded-lg">
                                    <select id="textFont" class="w-full p-2 rounded-lg">
                                        <option value="Inter">Inter</option>
                                        <option value="Playfair Display">Playfair</option>
                                        <option value="Roboto Mono">Mono</option>
                                        <option value="Caveat">Caveat</option>
                                    </select>
                                    <select id="textPosition" class="w-full p-2 rounded-lg">
                                        <option value="bottom-center">Alt-Orta</option>
                                        <option value="top-center">Üst-Orta</option>
                                        <option value="center-center">Orta</option>
                                    </select>
                                </div>
                            </div>

                            <div class="control-section">
                                <label class="block text-sm font-medium text-gray-200 mb-2">Filigran (Watermark)</label>
                                <input type="file" id="watermarkLoader" accept="image/png, image/jpeg" class="block w-full text-sm text-gray-300 file:mr-4 file:py-2 file:px-4 file:rounded-lg file:border-0 file:text-sm file:font-semibold file:bg-teal-500/30 file:text-teal-50 hover:file:bg-teal-500/50 cursor-pointer rounded-lg">
                                <div id="watermarkControls" class="hidden grid grid-cols-2 md:grid-cols-4 gap-4 mt-4 text-xs text-gray-300">
                                     <div><label>Opaklık</label><input type="range" id="watermarkOpacity" min="0" max="100" value="50" class="w-full"></div>
                                     <div><label>Boyut</label><input type="range" id="watermarkSize" min="5" max="100" value="20" class="w-full"></div>
                                     <select id="watermarkPosition" class="w-full p-2 rounded-lg col-span-2">
                                        <option value="bottom-right">Sağ Alt</option>
                                        <option value="bottom-left">Sol Alt</option>
                                        <option value="top-right">Sağ Üst</option>
                                        <option value="top-left">Sol Üst</option>
                                        <option value="center">Orta</option>
                                     </select>
                                </div>
                            </div>
                        </div>

                    </div>
                </div>

                <div class="flex flex-col sm:flex-row items-center justify-between gap-4 pt-6 border-t border-white/20 mt-6">
                    <div class="flex gap-2">
                        <button id="undoBtn" disabled title="Geri Al" class="bg-black/20 text-white font-bold p-3 rounded-lg hover:bg-black/30 disabled:opacity-50 disabled:cursor-not-allowed"><i class="gg-undo"></i></button>
                        <button id="redoBtn" disabled title="İleri Al" class="bg-black/20 text-white font-bold p-3 rounded-lg hover:bg-black/30 disabled:opacity-50 disabled:cursor-not-allowed"><i class="gg-redo"></i></button>
                    </div>
                    <div class="flex-grow flex gap-2 w-full sm:w-auto">
                        <button id="saveProjectBtn" class="w-full bg-emerald-600 text-white font-bold py-3 px-4 rounded-lg hover:bg-emerald-700 disabled:bg-gray-500 disabled:cursor-not-allowed">Projeyi Kaydet</button>
                        <button id="loadProjectBtn" class="w-full bg-sky-600 text-white font-bold py-3 px-4 rounded-lg hover:bg-sky-700">Projelerim</button>
                    </div>
                    <button id="downloadBtn" disabled class="w-full sm:w-auto bg-violet-600 text-white font-bold py-3 px-4 rounded-lg hover:bg-violet-700 focus:outline-none focus:ring-4 focus:ring-violet-400 transition-all duration-300 disabled:bg-gray-500 disabled:cursor-not-allowed shadow-lg shadow-violet-500/50">
                        İndir
                    </button>
                </div>
            </div>
        </div>

        <div class="w-full lg:sticky lg:top-8 h-max">
            <div id="previewArea" class="glass-card rounded-2xl shadow-xl p-4 min-h-[400px] lg:min-h-[calc(100vh-4rem)] flex items-center justify-center">
                <div id="previewPlaceholder" class="text-center text-gray-400">
                    <svg xmlns="http://www.w3.org/2000/svg" class="mx-auto h-16 w-16" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="1" d="M4 16l4.586-4.586a2 2 0 012.828 0L16 16m-2-2l-1-1m6-3a9 9 0 11-18 0 9 9 0 0118 0z" /></svg>
                    <p class="font-semibold text-lg mt-4">Önizleme Alanı</p>
                    <p class="text-sm">Bir fotoğraf yüklediğinizde burada görünecektir.</p>
                </div>
                <div id="canvasWrapper" class="hidden w-full h-full items-center justify-center">
                    <canvas id="canvas" class="max-w-full max-h-full"></canvas>
                </div>
            </div>
        </div>
    </div>

    
<div id="projectsModal" class="modal-overlay fixed inset-0 bg-black bg-opacity-60 flex items-center justify-center p-4 z-50 hidden">
        <div class="modal-content glass-card w-full max-w-4xl rounded-2xl shadow-2xl p-6 md:p-8 transform scale-95">
            <div class="flex justify-between items-center mb-6">
                <h2 class="text-2xl font-bold text-white">Projelerim</h2>
                <button id="closeModalBtn" class="text-gray-300 hover:text-white text-3xl font-bold">&times;</button>
            </div>
            <div id="projectList" class="max-h-[60vh] overflow-y-auto pr-2">
                <!-- Projeler JS ile eklenecek -->
            </div>
        </div>
    </div>
    
    
<div id="toast" class="px-6 py-3 bg-emerald-500 text-white font-semibold rounded-lg shadow-lg">
        <p id="toastMessage"></p>
    </div>

    <script>
        // --- BU UYGULAMA GEMINI TARAFINDAN GELİŞTİRİLMİŞTİR ---
        // --- YENİ: Büyüteç modundaki arkaplan bulanıklık sorunu düzeltildi. ---
        
        const imageLoader = document.getElementById('imageLoader');
        const collageImageLoader = document.getElementById('collageImageLoader');
        const downloadBtn = document.getElementById('downloadBtn');
        const saveProjectBtn = document.getElementById('saveProjectBtn');
        const loadProjectBtn = document.getElementById('loadProjectBtn');
        const undoBtn = document.getElementById('undoBtn');
        const redoBtn = document.getElementById('redoBtn');
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const allUIInputs = document.querySelectorAll('input, select');
        const previewPlaceholder = document.getElementById('previewPlaceholder');
        const canvasWrapper = document.getElementById('canvasWrapper');
        const projectsModal = document.getElementById('projectsModal');
        const closeModalBtn = document.getElementById('closeModalBtn');
        const projectListContainer = document.getElementById('projectList');
        const collageUploaderDiv = document.getElementById('collageUploader');
        const collageThumbnailsWrapper = document.getElementById('collageThumbnailsWrapper');
        const collageThumbnailsContainer = document.getElementById('collageThumbnailsContainer');
        const polaroidFrameContainer = document.getElementById('polaroidFrameContainer');
        const polaroidColorSection = document.getElementById('polaroidColorSection');

        let db;
        let state = {};
        let history = [];
        let historyIndex = -1;
        let mainImage = null;
        let collageImages = [];
        let watermarkImage = null;
        let originalFileName = 'fotoğraf';
        
        let isPanning = false;
        let isModifierDown = false;
        let panStart = { x: 0, y: 0 };
        let activePanTarget = { type: null, index: -1 };
        let initialImageOffset = { x: 0, y: 0 }; 
        let draggedThumbnailIndex = null;
        let frameImageAssets = {};
        
        let isDraggingMagnifyFrame = false;
        let magnifyDragOffset = { x: 0, y: 0 };

        const presets = {
            'original': null, 
            'square': { width: 1080, height: 1080 }, 
            'portrait45': { width: 1080, height: 1350 },
            'story': { width: 1080, height: 1920 },
            'horizontal': { width: 1080, height: 566 },
            'profile': { width: 320, height: 320 }
        };
        
        const polaroidFrameSpecs = {
            'classic': { name: 'Klasik', type: 'color', defaultColor: '#ffffff', textColor: '#2d3748', layout: 'classic' },
            'equal': { name: 'Eşit Kenar', type: 'color', defaultColor: '#ffffff', textColor: '#2d3748', layout: 'equal' },
            'top-heavy': { name: 'Ters Polaroid', type: 'color', defaultColor: '#ffffff', textColor: '#2d3748', layout: 'top-heavy' },
            'dark': { name: 'Siyah', type: 'color', defaultColor: '#2d3748', textColor: '#e2e8f0', layout: 'classic' },
            'vintage': { name: 'Vintage', type: 'color', defaultColor: '#fffae5', textColor: '#5a4a3a', layout: 'classic' },
            'film-kare': { name: 'Film Karesi', type: 'special', value: '#000000', textColor: '#e0e0e0', layout: 'equal' },
            'sprocket-light': { name: 'Film Şeridi (Açık)', type: 'effect', effectColor: 'rgba(255,255,255,0.8)', layout: 'equal' },
            'sprocket-dark': { name: 'Film Şeridi (Koyu)', type: 'effect', effectColor: 'rgba(0,0,0,0.7)', layout: 'equal' },
            'watercolor': { name: 'Suluboya', type: 'pattern', value: 'https://www.toptal.com/designers/subtlepatterns/uploads/watercolor.png', textColor: '#3a5a78', layout: 'classic' },
            'floral': { name: 'Çiçekli', type: 'pattern', value: 'https://www.toptal.com/designers/subtlepatterns/uploads/flowers.png', textColor: '#2a4b2a', layout: 'classic' },
            'galaxy': { name: 'Galaksi', type: 'pattern', value: 'https://images.pexels.com/photos/1169754/pexels-photo-1169754.jpeg?auto=compress&cs=tinysrgb&w=1260&h=750&dpr=1', textColor: '#e0e0ff', layout: 'classic' },
            'grunge': { name: 'Eskitme', type: 'pattern', value: 'https://www.toptal.com/designers/subtlepatterns/uploads/paper-fibers.png', textColor: '#4a4a4a', layout: 'classic' },
        };
        
        Object.keys(polaroidFrameSpecs).forEach(key => {
            polaroidFrameSpecs[key].aspectRatio = 88 / 107;
            if (polaroidFrameSpecs[key].layout === 'classic') {
                 polaroidFrameSpecs[key].photoPadding = 0.05;
            }
        });

        function getDefaultState() {
            return {
                mode: 'single', fit: 'contain', sizePreset: 'square',
                padding: { top: 0, right: 0, bottom: 0, left: 0 }, syncPadding: true,
                bgType: 'solid', color1: '#000000', color2: '#4a5568',
                imageOffset: { x: 0, y: 0 },
                collage: { 
                    gap: 10, 
                    layout: 'auto',
                    cornerRadius: 0,
                    imageOffsets: []
                },
                polaroid: {
                    frame: 'classic',
                    frameColor: '#ffffff',
                    text: '',
                    rotation: 5,
                    zoom: 100
                },
                magnify: {
                    frameX: 100, frameY: 100,
                    frameW: 300, frameH: 450,
                    zoom: 1.5, blur: 10,
                    borderColor: '#ffffff', borderWidth: 10
                },
                text: { content: '', color: '#FFFFFF', size: 48, font: 'Inter', position: 'bottom-center' },
                watermark: { opacity: 50, size: 20, position: 'bottom-right' }
            };
        }
        
        function syncStateWithUI() {
            // Modu belirle
            if (document.getElementById('singleModeBtn').classList.contains('active')) state.mode = 'single';
            else if (document.getElementById('collageModeBtn').classList.contains('active')) state.mode = 'collage';
            else if (document.getElementById('polaroidModeBtn').classList.contains('active')) state.mode = 'polaroid';
            else if (document.getElementById('magnifyModeBtn').classList.contains('active')) state.mode = 'magnify';

            // Tekli mod ayarları
            const newFit = document.getElementById('fitContainBtn').classList.contains('active') ? 'contain' : 'cover';
            if (state.fit !== newFit) state.imageOffset = { x: 0, y: 0 };
            state.fit = newFit;
            
            const newPreset = document.getElementById('sizePreset').value;
             if (state.sizePreset !== newPreset) {
                state.imageOffset = { x: 0, y: 0 };
                if(state.collage.imageOffsets) {
                    state.collage.imageOffsets.forEach(offset => { offset.x = 0; offset.y = 0; });
                }
            }
            state.sizePreset = newPreset;
            
            state.syncPadding = document.getElementById('syncPadding').checked;
            state.padding = {
                top: parseInt(document.getElementById('paddingTop').value, 10),
                right: parseInt(document.getElementById('paddingRight').value, 10),
                bottom: parseInt(document.getElementById('paddingBottom').value, 10),
                left: parseInt(document.getElementById('paddingLeft').value, 10)
            };
            state.bgType = document.querySelector('input[name="bgType"]:checked').value;
            state.color1 = document.getElementById('color1').value;
            state.color2 = document.getElementById('color2').value;
            
            // Kolaj ayarları
            state.collage.gap = parseInt(document.getElementById('collageGap').value, 10);
            state.collage.cornerRadius = parseInt(document.getElementById('cornerRadius').value, 10);
            state.collage.layout = document.querySelector('#collageLayoutContainer .active')?.dataset.layout;
            
            // Polaroid ayarları
            state.polaroid.frame = document.querySelector('#polaroidFrameContainer .active')?.dataset.frame;
            state.polaroid.frameColor = document.getElementById('polaroidFrameColor').value;
            state.polaroid.text = document.getElementById('polaroidText').value;
            state.polaroid.rotation = parseInt(document.getElementById('polaroidRotation').value, 10);
            state.polaroid.zoom = parseInt(document.getElementById('polaroidZoom').value, 10);

            // Büyüteç ayarları
            state.magnify = {
                frameX: state.magnify.frameX, // Pozisyon sürükleme ile güncellenir
                frameY: state.magnify.frameY,
                frameW: parseInt(document.getElementById('magnifyFrameWidth').value, 10),
                frameH: parseInt(document.getElementById('magnifyFrameHeight').value, 10),
                zoom: parseFloat(document.getElementById('magnifyZoom').value),
                blur: parseInt(document.getElementById('magnifyBlur').value, 10),
                borderColor: document.getElementById('magnifyBorderColor').value,
                borderWidth: parseInt(document.getElementById('magnifyBorderWidth').value, 10)
            };

            // Genel araçlar
            state.text = {
                content: document.getElementById('textInput').value,
                color: document.getElementById('textColor').value,
                size: parseInt(document.getElementById('textSize').value, 10),
                font: document.getElementById('textFont').value,
                position: document.getElementById('textPosition').value,
            };
            state.watermark = {
                opacity: parseInt(document.getElementById('watermarkOpacity').value, 10),
                size: parseInt(document.getElementById('watermarkSize').value, 10),
                position: document.getElementById('watermarkPosition').value,
            };
        }

        function updateUIFromState(s) {
            document.getElementById('singleModeBtn').classList.toggle('active', s.mode === 'single');
            document.getElementById('collageModeBtn').classList.toggle('active', s.mode === 'collage');
            document.getElementById('polaroidModeBtn').classList.toggle('active', s.mode === 'polaroid');
            document.getElementById('magnifyModeBtn').classList.toggle('active', s.mode === 'magnify');

            const isMagnify = s.mode === 'magnify';
            const isPolaroid = s.mode === 'polaroid';
            const isCollage = s.mode === 'collage';
            const isSingle = s.mode === 'single';

            document.getElementById('canvasSizeSettings').style.display = isSingle || isCollage || isMagnify ? 'block' : 'none';
            document.getElementById('backgroundStyleSettings').style.display = isSingle || isCollage ? 'block' : 'none';
            document.getElementById('standardSettings').style.display = isSingle || isCollage ? 'block' : 'none';
            document.getElementById('polaroidSettings').style.display = isPolaroid ? 'block' : 'none';
            document.getElementById('collageSettings').style.display = isCollage ? 'block' : 'none';
            document.getElementById('magnifySettings').style.display = isMagnify ? 'block' : 'none';
            document.getElementById('generalTools').style.display = isSingle || isCollage ? 'block' : 'none';
            
            if (isPolaroid) {
                 const frameSpec = polaroidFrameSpecs[s.polaroid.frame];
                 polaroidColorSection.style.display = frameSpec && frameSpec.type === 'color' ? 'block' : 'none';
                 // Polaroid effect frames should not show background settings
                 if (frameSpec && frameSpec.type === 'effect') {
                     document.getElementById('backgroundStyleSettings').style.display = 'none';
                 }
            }

            document.getElementById('fitFillContainer').style.visibility = isSingle ? 'visible' : 'hidden';
            document.getElementById('colorPickers').style.display = s.bgType === 'transparent' ? 'none' : 'grid';
            document.getElementById('color2').style.display = s.bgType === 'gradient' ? 'block' : 'none';

            document.getElementById('fitContainBtn').classList.toggle('active', s.fit === 'contain');
            document.getElementById('fitCoverBtn').classList.toggle('active', s.fit === 'cover');
            document.getElementById('sizePreset').value = s.sizePreset;
            
            document.getElementById('paddingTop').value = s.padding.top; 
            document.getElementById('paddingRight').value = s.padding.right; 
            document.getElementById('paddingBottom').value = s.padding.bottom; 
            document.getElementById('paddingLeft').value = s.padding.left;
            document.querySelectorAll('.padding-slider').forEach(sl => {
                document.getElementById(sl.id + 'Value').textContent = `${sl.value}px`;
            });

            document.getElementById('syncPadding').checked = s.syncPadding;
            ['bgSolid', 'bgGradient', 'bgBlur', 'bgTransparent'].forEach(id => {
                document.getElementById(id).checked = s.bgType === id.replace('bg', '').toLowerCase();
            });
            document.getElementById('color1').value = s.color1; 
            document.getElementById('color2').value = s.color2;
            
            document.getElementById('collageGap').value = s.collage.gap;
            document.getElementById('cornerRadius').value = s.collage.cornerRadius;
            document.querySelectorAll('#collageLayoutContainer button').forEach(b => b.classList.toggle('active', b.dataset.layout === s.collage.layout));
            
            document.querySelectorAll('#polaroidFrameContainer button').forEach(b => b.classList.toggle('active', b.dataset.frame === s.polaroid.frame));
            document.getElementById('polaroidFrameColor').value = s.polaroid.frameColor;
            document.getElementById('polaroidText').value = s.polaroid.text;
            document.getElementById('polaroidRotation').value = s.polaroid.rotation;
            document.getElementById('polaroidZoom').value = s.polaroid.zoom;
            
            document.getElementById('magnifyBlur').value = s.magnify.blur;
            document.getElementById('magnifyZoom').value = s.magnify.zoom;
            document.getElementById('magnifyFrameWidth').value = s.magnify.frameW;
            document.getElementById('magnifyFrameHeight').value = s.magnify.frameH;
            document.getElementById('magnifyBorderColor').value = s.magnify.borderColor;
            document.getElementById('magnifyBorderWidth').value = s.magnify.borderWidth;

            document.getElementById('textInput').value = s.text.content; 
            document.getElementById('textColor').value = s.text.color; 
            document.getElementById('textSize').value = s.text.size; 
            document.getElementById('textFont').value = s.text.font; 
            document.getElementById('textPosition').value = s.text.position;
            document.getElementById('watermarkOpacity').value = s.watermark.opacity; 
            document.getElementById('watermarkSize').value = s.watermark.size; 
            document.getElementById('watermarkPosition').value = s.watermark.position;
            
            document.getElementById('singleUploader').style.display = isSingle || isPolaroid || isMagnify ? 'block' : 'none';
            collageUploaderDiv.style.display = isCollage ? 'block' : 'none';
            document.getElementById('imageLoaderLabel').textContent = `1. ${isCollage ? 'Kolaj Fotoğrafları' : 'Fotoğraf'} Seçin`;
            document.querySelector('#sizePreset option[value="original"]').disabled = isCollage || isPolaroid || isMagnify;
            if ((isPolaroid || isMagnify) && s.sizePreset === 'original') {
                s.sizePreset = 'story'; // Büyüteç ve Polaroid için varsayılan boyut
                document.getElementById('sizePreset').value = 'story';
            }
        }

        function updateAndDraw(saveToHistory = true) {
            syncStateWithUI(); 
            if (saveToHistory) {
                saveStateToHistory();
            }
            updateUIFromState(state);
            drawPreview();

            const hasImage = mainImage || (state.mode === 'collage' && collageImages.length > 0);
            saveProjectBtn.disabled = !hasImage;
            downloadBtn.disabled = !hasImage;
        }

        function saveStateToHistory() {
            history = history.slice(0, historyIndex + 1);
            history.push(JSON.parse(JSON.stringify(state)));
            historyIndex++;
            updateUndoRedoButtons();
        }

        function undo() {
            if (historyIndex > 0) {
                historyIndex--;
                state = JSON.parse(JSON.stringify(history[historyIndex]));
                updateUIFromState(state);
                drawPreview();
                if(state.mode === 'collage') displayCollageThumbnails();
                updateUndoRedoButtons();
            }
        }

        function redo() {
            if (historyIndex < history.length - 1) {
                historyIndex++;
                state = JSON.parse(JSON.stringify(history[historyIndex]));
                updateUIFromState(state);
                drawPreview();
                if(state.mode === 'collage') displayCollageThumbnails();
                updateUndoRedoButtons();
            }
        }
        
        function updateUndoRedoButtons() {
            undoBtn.disabled = historyIndex <= 0;
            redoBtn.disabled = historyIndex >= history.length - 1;
        }
        
        function setupEventListeners() {
            document.getElementById('singleModeBtn').addEventListener('click', () => { if (state.mode !== 'single') switchMode('single'); });
            document.getElementById('collageModeBtn').addEventListener('click', () => { if (state.mode !== 'collage') switchMode('collage'); });
            document.getElementById('polaroidModeBtn').addEventListener('click', () => { if (state.mode !== 'polaroid') switchMode('polaroid'); });
            document.getElementById('magnifyModeBtn').addEventListener('click', () => { if (state.mode !== 'magnify') switchMode('magnify'); });
            
            document.getElementById('fitContainBtn').addEventListener('click', () => { setFitMode('contain'); });
            document.getElementById('fitCoverBtn').addEventListener('click', () => { setFitMode('cover'); });
            
            document.querySelectorAll('.padding-slider').forEach(s => s.addEventListener('input', handlePaddingSlider));
            document.getElementById('syncPadding').addEventListener('change', () => updateAndDraw());

            document.querySelectorAll('input[name="bgType"]').forEach(radio => radio.addEventListener('change', () => updateAndDraw()));

            document.querySelectorAll('#collageLayoutContainer button').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    document.querySelector('#collageLayoutContainer .active')?.classList.remove('active');
                    e.currentTarget.classList.add('active');
                    updateAndDraw();
                });
            });
            
            polaroidFrameContainer.addEventListener('click', (e) => {
                const button = e.target.closest('.frame-btn');
                if (button) {
                    document.querySelector('#polaroidFrameContainer .active')?.classList.remove('active');
                    button.classList.add('active');
                    
                    const frameKey = button.dataset.frame;
                    const frameSpec = polaroidFrameSpecs[frameKey];
                    
                    if (frameSpec.type === 'color') {
                        state.polaroid.frameColor = frameSpec.defaultColor;
                    } else if (frameSpec.type === 'effect') {
                        document.getElementById('bgBlur').checked = true;
                    }
                    
                    updateAndDraw();
                }
            });

            allUIInputs.forEach(el => {
                const eventType = (el.type === 'range' || el.type === 'color') ? 'input' : 'change';
                 if (!el.classList.contains('padding-slider')) {
                    el.addEventListener(eventType, () => updateAndDraw(el.type !== 'range'));
                }
            });
            
            imageLoader.addEventListener('change', (e) => handleImageUpload(e.target.files[0]));
            collageImageLoader.addEventListener('change', (e) => handleCollageUpload(e.target.files));
            document.getElementById('watermarkLoader').addEventListener('change', handleWatermarkUpload);

            document.body.addEventListener('drop', e => { e.preventDefault(); e.stopPropagation(); });
            document.body.addEventListener('dragover', e => { e.preventDefault(); e.stopPropagation(); });

            document.querySelector('#singleUploader').addEventListener('drop', e => {
                 e.preventDefault(); e.stopPropagation(); e.currentTarget.classList.remove('drag-over');
                handleImageUpload(e.dataTransfer.files[0]);
            });
            document.querySelector('#collageUploader .upload-area').addEventListener('drop', e => {
                e.preventDefault(); e.stopPropagation(); e.currentTarget.classList.remove('drag-over');
                handleCollageUpload(e.dataTransfer.files);
            });

            downloadBtn.addEventListener('click', downloadImage);
            saveProjectBtn.addEventListener('click', saveProject);
            loadProjectBtn.addEventListener('click', showProjectsModal);
            closeModalBtn.addEventListener('click', hideProjectsModal);
            projectsModal.addEventListener('click', (e) => { if(e.target === projectsModal) hideProjectsModal(); });
            undoBtn.addEventListener('click', undo);
            redoBtn.addEventListener('click', redo);
            
            window.addEventListener('keydown', e => { if (e.key === 'Meta' || e.key === 'Control') { isModifierDown = true; updateCursor(); } });
            window.addEventListener('keyup', e => { if (e.key === 'Meta' || e.key === 'Control') { isModifierDown = false; updateCursor(); } });
            
            canvasWrapper.addEventListener('mousedown', e => {
                const hasImage = mainImage || (state.mode === 'collage' && collageImages.length > 0);
                if (!hasImage) return;

                const canvasRect = canvas.getBoundingClientRect();
                const mouse = {
                    x: (e.clientX - canvasRect.left) * (canvas.width / canvasRect.width),
                    y: (e.clientY - canvasRect.top) * (canvas.height / canvasRect.height)
                };
                panStart = { x: e.clientX, y: e.clientY };
                
                if (state.mode === 'magnify') {
                    const { frameX, frameY, frameW, frameH } = state.magnify;
                    if (mouse.x > frameX && mouse.x < frameX + frameW && mouse.y > frameY && mouse.y < frameY + frameH) {
                        isDraggingMagnifyFrame = true;
                        magnifyDragOffset = { x: mouse.x - frameX, y: mouse.y - frameY };
                        canvasWrapper.style.cursor = 'grabbing';
                    }
                } else if (isModifierDown) {
                    if (state.mode === 'single' || state.mode === 'polaroid') {
                        isPanning = true;
                        activePanTarget = { type: state.mode, index: -1 };
                        initialImageOffset = { ...state.imageOffset };
                    } else if (state.mode === 'collage') { 
                        const p = state.padding;
                        const area = { x: p.left, y: p.top, w: canvas.width - p.left - p.right, h: canvas.height - p.top - p.bottom };
                        const layout = getCollageLayout(state.collage.layout, collageImages.length, area, state.collage.gap);
                        const clickedIndex = layout.findIndex(rect => mouse.x >= rect.x && mouse.x <= rect.x + rect.w && mouse.y >= rect.y && mouse.y <= rect.y + rect.h);
                        if (clickedIndex > -1) {
                            isPanning = true;
                            activePanTarget = { type: 'collage', index: clickedIndex };
                            initialImageOffset = { ...state.collage.imageOffsets[clickedIndex] };
                        }
                    }
                     if(isPanning) canvasWrapper.style.cursor = 'grabbing';
                }
            });
            
            window.addEventListener('mousemove', e => {
                if (isDraggingMagnifyFrame) {
                    const canvasRect = canvas.getBoundingClientRect();
                    const mouseX = (e.clientX - canvasRect.left) * (canvas.width / canvasRect.width);
                    const mouseY = (e.clientY - canvasRect.top) * (canvas.height / canvasRect.height);

                    state.magnify.frameX = mouseX - magnifyDragOffset.x;
                    state.magnify.frameY = mouseY - magnifyDragOffset.y;
                    
                    // Sınır kontrolü
                    state.magnify.frameX = Math.max(0, Math.min(state.magnify.frameX, canvas.width - state.magnify.frameW));
                    state.magnify.frameY = Math.max(0, Math.min(state.magnify.frameY, canvas.height - state.magnify.frameH));

                    drawPreview();
                    return;
                }

                if (!isPanning) return;
                e.preventDefault();

                const previewRect = canvas.getBoundingClientRect();
                if (previewRect.width === 0) return;

                const previewScale = canvas.width / previewRect.width;
                const dx_canvas = (e.clientX - panStart.x) * previewScale;
                const dy_canvas = (e.clientY - panStart.y) * previewScale;
                
                let targetImage, container, currentOffset, zoom = 1;

                if (activePanTarget.type === 'single') {
                    targetImage = mainImage;
                    const p = state.padding;
                    container = { w: canvas.width - p.left - p.right, h: canvas.height - p.top - p.bottom };
                    currentOffset = state.imageOffset;
                } else if (activePanTarget.type === 'polaroid') {
                    targetImage = mainImage;
                    const frameDetails = getPolaroidFrameDetails(canvas.width, canvas.height);
                    container = { w: frameDetails.photoW, h: frameDetails.photoH };
                    currentOffset = state.imageOffset;
                    zoom = state.polaroid.zoom / 100;
                } else if (activePanTarget.type === 'collage') {
                    const p = state.padding;
                    const area = { x: p.left, y: p.top, w: canvas.width - p.left - p.right, h: canvas.height - p.top - p.bottom };
                    const layout = getCollageLayout(state.collage.layout, collageImages.length, area, state.collage.gap);
                    container = layout[activePanTarget.index];
                    targetImage = collageImages[activePanTarget.index];
                    currentOffset = state.collage.imageOffsets[activePanTarget.index];
                } else {
                    return;
                }

                if (!targetImage || !container || container.w <= 0) return;

                const imgRatio = targetImage.width / targetImage.height;
                const areaRatio = container.w / container.h;
                
                let renderScale;
                if (imgRatio > areaRatio) { 
                    renderScale = container.h / (targetImage.height / zoom);
                } else { 
                    renderScale = container.w / (targetImage.width / zoom);
                }

                const dx_source = dx_canvas / renderScale;
                const dy_source = dy_canvas / renderScale;
                
                let newOffset = {
                    x: initialImageOffset.x - dx_source,
                    y: initialImageOffset.y - dy_source,
                };
                
                let sW, sH;
                if(imgRatio > areaRatio) { sH = targetImage.height; sW = sH * areaRatio; }
                else { sW = targetImage.width; sH = sW / areaRatio; }
                
                sW /= zoom; sH /= zoom;

                const maxOffsetX = Math.max(0, (targetImage.width - sW) / 2);
                const maxOffsetY = Math.max(0, (targetImage.height - sH) / 2);

                newOffset.x = Math.max(-maxOffsetX, Math.min(maxOffsetX, newOffset.x));
                newOffset.y = Math.max(-maxOffsetY, Math.min(maxOffsetY, newOffset.y));

                if (activePanTarget.type === 'single' || activePanTarget.type === 'polaroid') {
                    state.imageOffset = newOffset;
                } else {
                    state.collage.imageOffsets[activePanTarget.index] = newOffset;
                }

                drawPreview();
            });

            window.addEventListener('mouseup', () => {
                if (isPanning || isDraggingMagnifyFrame) {
                    isPanning = false;
                    isDraggingMagnifyFrame = false;
                    activePanTarget = { type: null, index: -1 };
                    updateCursor();
                    saveStateToHistory();
                }
            });
            canvasWrapper.addEventListener('mouseenter', updateCursor);
            canvasWrapper.addEventListener('mouseleave', () => { canvasWrapper.style.cursor = 'default'; });
            
            collageThumbnailsContainer.addEventListener('click', (e) => {
                if(e.target.classList.contains('delete-thumb-btn')) {
                    const indexToDelete = parseInt(e.target.dataset.index, 10);
                    deleteCollageImage(indexToDelete);
                }
            });
        }
        
        function switchMode(mode) {
            if (state.mode === 'collage' || mode === 'collage') {
                mainImage = null;
                collageImages = [];
                imageLoader.value = null; 
                collageImageLoader.value = null;
                collageThumbnailsContainer.innerHTML = '';
                collageThumbnailsWrapper.classList.add('hidden');
            }
            if (mode !== 'collage') {
                collageImages = [];
            }
            if (mode !== 'single' && mode !== 'polaroid' && mode !== 'magnify') {
                mainImage = null;
            }
            
            state.imageOffset = { x: 0, y: 0 };
            state.collage.imageOffsets = [];
            
            previewPlaceholder.classList.remove('hidden');
            canvasWrapper.classList.add('hidden');
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            state.mode = mode;
            updateUIFromState(state);
            updateAndDraw(); 
            saveStateToHistory();
        }

        function setFitMode(fit) {
            document.getElementById('fitContainBtn').classList.toggle('active', fit === 'contain');
            document.getElementById('fitCoverBtn').classList.toggle('active', fit === 'cover');
            updateAndDraw();
        }

        function updateCursor() {
            const canPanSingle = state.mode === 'single' && mainImage && state.fit === 'cover';
            const canPanCollage = state.mode === 'collage' && collageImages.length > 0;
            const canPanPolaroid = state.mode === 'polaroid' && mainImage;
            const canDragMagnify = state.mode === 'magnify' && mainImage;

            if (isDraggingMagnifyFrame || isPanning) {
                 canvasWrapper.style.cursor = 'grabbing';
            } else if (canDragMagnify) {
                 canvasWrapper.style.cursor = 'move';
            } else if (isModifierDown && (canPanSingle || canPanCollage || canPanPolaroid)) {
                canvasWrapper.style.cursor = 'grab';
            } else {
                canvasWrapper.style.cursor = 'default';
            }
        }

        function handlePaddingSlider(e) {
            const value = e.target.value;
            if (document.getElementById('syncPadding').checked) {
                document.querySelectorAll('.padding-slider').forEach(s => s.value = value);
            }
            updateAndDraw(false); 
        }
        document.querySelectorAll('.padding-slider').forEach(s => s.addEventListener('change', () => updateAndDraw(true)));


        function handleImageUpload(file) {
            if (!file) return;
            originalFileName = file.name.split('.').slice(0, -1).join('.') || 'fotoğraf';
            const reader = new FileReader();
            reader.onload = e => {
                mainImage = new Image();
                mainImage.onload = () => {
                    previewPlaceholder.classList.add('hidden');
                    canvasWrapper.style.display = 'flex';
                    canvasWrapper.classList.remove('hidden');
                    state.imageOffset = { x: 0, y: 0 };
                    // Büyüteç modu için varsayılan çerçeve konumunu ayarla
                    if (state.mode === 'magnify') {
                         const preset = presets[state.sizePreset] || { width: 1080, height: 1080 };
                         state.magnify.frameX = (preset.width - state.magnify.frameW) / 2;
                         state.magnify.frameY = (preset.height - state.magnify.frameH) / 2;
                    }
                    updateAndDraw();
                };
                mainImage.src = e.target.result;
            };
            reader.readAsDataURL(file);
        }
        
        function handleCollageUpload(files) {
            if (!files || files.length === 0) return;
            originalFileName = 'kolaj';
            const readers = Array.from(files).map(file => {
                return new Promise(resolve => {
                    const reader = new FileReader();
                    reader.onload = e => {
                        const img = new Image();
                        img.onload = () => resolve(img);
                        img.src = e.target.result;
                    };
                    reader.readAsDataURL(file);
                });
            });
            Promise.all(readers).then(images => {
                collageImages = collageImages.concat(images);
                const newOffsets = images.map(() => ({ x: 0, y: 0 }));
                state.collage.imageOffsets = state.collage.imageOffsets.concat(newOffsets);

                if (collageImages.length > 0) {
                    previewPlaceholder.classList.add('hidden');
                    canvasWrapper.style.display = 'flex';
                    canvasWrapper.classList.remove('hidden');
                    displayCollageThumbnails();
                    updateAndDraw();
                }
            });
        }
        
        function deleteCollageImage(index) {
            if (index > -1 && index < collageImages.length) {
                collageImages.splice(index, 1);
                state.collage.imageOffsets.splice(index, 1);
                
                if (collageImages.length === 0) {
                    previewPlaceholder.classList.remove('hidden');
                    canvasWrapper.classList.add('hidden');
                }
                
                displayCollageThumbnails();
                updateAndDraw();
                saveStateToHistory();
            }
        }

        function displayCollageThumbnails() {
            collageThumbnailsWrapper.classList.toggle('hidden', collageImages.length === 0);
            collageThumbnailsContainer.innerHTML = '';
            collageImages.forEach((img, index) => {
                const thumbItem = document.createElement('div');
                thumbItem.className = 'thumbnail-item';
                thumbItem.dataset.index = index;
                thumbItem.draggable = true;
                thumbItem.innerHTML = `
                    <img src="${img.src}" alt="Kolaj resmi ${index + 1}">
                    <button class="delete-thumb-btn" data-index="${index}" title="Resmi Sil">&times;</button>
                `;
                collageThumbnailsContainer.appendChild(thumbItem);
            });
            addDragDropListenersToThumbnails();
        }

        function addDragDropListenersToThumbnails() {
            const thumbnails = document.querySelectorAll('.thumbnail-item');
            thumbnails.forEach(thumb => {
                thumb.addEventListener('dragstart', handleDragStart);
                thumb.addEventListener('dragend', handleDragEnd);
                thumb.addEventListener('dragover', handleDragOver);
                thumb.addEventListener('dragleave', handleDragLeave);
                thumb.addEventListener('drop', handleDrop);
            });
        }

        function handleDragStart(e) {
            draggedThumbnailIndex = parseInt(e.target.closest('.thumbnail-item').dataset.index);
            e.target.closest('.thumbnail-item').classList.add('dragging');
        }

        function handleDragEnd(e) {
            e.target.closest('.thumbnail-item').classList.remove('dragging');
        }
        
        function handleDragOver(e) {
            e.preventDefault();
            const targetItem = e.target.closest('.thumbnail-item');
            if (targetItem) targetItem.classList.add('drag-over-thumb');
        }

        function handleDragLeave(e) {
             const targetItem = e.target.closest('.thumbnail-item');
            if (targetItem) targetItem.classList.remove('drag-over-thumb');
        }

        function handleDrop(e) {
            e.preventDefault();
            const targetItem = e.target.closest('.thumbnail-item');
            if (!targetItem) return;
            targetItem.classList.remove('drag-over-thumb');
            const droppedOnIndex = parseInt(targetItem.dataset.index);

            if (draggedThumbnailIndex === droppedOnIndex) return;

            const draggedImage = collageImages.splice(draggedThumbnailIndex, 1)[0];
            const draggedOffset = state.collage.imageOffsets.splice(draggedThumbnailIndex, 1)[0];
            
            collageImages.splice(droppedOnIndex, 0, draggedImage);
            state.collage.imageOffsets.splice(droppedOnIndex, 0, draggedOffset);
            
            displayCollageThumbnails();
            updateAndDraw();
        }

        function handleWatermarkUpload(e) {
            const file = e.target.files[0];
            if (!file) {
                watermarkImage = null;
                document.getElementById('watermarkControls').classList.add('hidden');
                updateAndDraw(); return;
            }
            const reader = new FileReader();
            reader.onload = res => {
                watermarkImage = new Image();
                watermarkImage.onload = () => {
                    document.getElementById('watermarkControls').classList.remove('hidden');
                    updateAndDraw();
                }
                watermarkImage.src = res.target.result;
            }
            reader.readAsDataURL(file);
        }

        function drawPreview() {
            const hasImage = mainImage || (state.mode === 'collage' && collageImages.length > 0);
            if (!hasImage) {
                previewPlaceholder.classList.remove('hidden');
                canvasWrapper.classList.add('hidden');
                return;
            };

            const preset = presets[state.sizePreset];
            if (state.sizePreset === 'original' && mainImage && state.mode === 'single') {
                canvas.width = mainImage.width + state.padding.left + state.padding.right;
                canvas.height = mainImage.height + state.padding.top + state.padding.bottom;
            } else if (preset) {
                canvas.width = preset.width;
                canvas.height = preset.height;
            } else { 
                canvas.width = 1080;
                canvas.height = 1080;
            }
            
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            if (state.mode === 'polaroid') {
                const frameSpec = polaroidFrameSpecs[state.polaroid.frame];
                if (frameSpec && frameSpec.type === 'effect') {
                    state.bgType = 'blur';
                    document.getElementById('bgBlur').checked = true;
                }
            }

            if (state.mode !== 'magnify') {
                drawBackground(ctx, canvas.width, canvas.height);
            }
            drawMainContent(ctx, canvas.width, canvas.height);
            if (state.mode === 'single' || state.mode === 'collage') {
                 drawTextAndWatermark(ctx, canvas.width, canvas.height);
            }
        }

        function drawBackground(targetCtx, w, h) {
            targetCtx.save();
            if (state.bgType === 'solid') {
                targetCtx.fillStyle = state.color1;
                targetCtx.fillRect(0, 0, w, h);
            } else if (state.bgType === 'gradient') {
                const gradient = targetCtx.createLinearGradient(0, 0, w, h);
                gradient.addColorStop(0, state.color1);
                gradient.addColorStop(1, state.color2);
                targetCtx.fillStyle = gradient;
                targetCtx.fillRect(0, 0, w, h);
            } else if (state.bgType === 'blur' && (mainImage || collageImages.length > 0)) {
                const imgToBlur = mainImage || collageImages[0];
                targetCtx.fillStyle = state.color1;
                targetCtx.fillRect(0, 0, w, h);
                targetCtx.save();
                targetCtx.filter = 'blur(30px) brightness(0.8)';
                const imgRatio = imgToBlur.width / imgToBlur.height;
                const canvasRatio = w / h;
                let finalW = w, finalH = h;
                if(imgRatio > canvasRatio) { finalH = w / imgRatio; } else { finalW = h * imgRatio; }
                const x = (w - finalW) / 2; const y = (h - finalH) / 2;
                targetCtx.drawImage(imgToBlur, x, y, finalW, finalH);
                targetCtx.restore();
            } else if (state.bgType === 'transparent') {
                // Do nothing, canvas is already cleared.
            } else {
                targetCtx.fillStyle = '#cccccc';
                targetCtx.fillRect(0, 0, w, h);
            }
            targetCtx.restore();
        }

        function drawMainContent(targetCtx, w, h, scale = 1) {
            targetCtx.save();
            
            if (state.mode === 'polaroid' && mainImage) {
                drawPolaroidFrame(targetCtx, w, h, scale);
            } else if (state.mode === 'magnify' && mainImage) {
                drawMagnifyEffectOnContext(targetCtx, w, h, mainImage, state.magnify);
            } else {
                const p = { top: state.padding.top * scale, right: state.padding.right * scale, bottom: state.padding.bottom * scale, left: state.padding.left * scale };
                const drawableW = w - p.left - p.right;
                const drawableH = h - p.top - p.bottom;
                if (drawableW <= 0 || drawableH <= 0) { targetCtx.restore(); return; }

                if (state.mode === 'single' && mainImage) {
                    if (state.fit === 'contain') {
                        const containerRatio = drawableW / drawableH;
                        const imgRatio = mainImage.width / mainImage.height;
                        let finalW, finalH;
                        if (imgRatio > containerRatio) { finalW = drawableW; finalH = finalW / imgRatio; } 
                        else { finalH = drawableH; finalW = finalH * imgRatio; }
                        const x = p.left + (drawableW - finalW) / 2;
                        const y = p.top + (drawableH - finalH) / 2;
                        drawRoundedImage(targetCtx, mainImage, x, y, finalW, finalH, 0, 'contain');
                    } else { // 'cover'
                        const offset = state.imageOffset || { x: 0, y: 0 };
                        drawRoundedImage(targetCtx, mainImage, p.left, p.top, drawableW, drawableH, 0, 'cover', offset);
                    }
                } else if (state.mode === 'collage' && collageImages.length > 0) {
                    drawCollageLayout(targetCtx, w, h, scale);
                }
            }
            targetCtx.restore();
        }

        function drawMagnifyEffectOnContext(targetCtx, w, h, image, mState) {
            if (!image) return;
            const { frameX, frameY, frameW, frameH, zoom, blur, borderColor, borderWidth } = mState;

            // --- 1. Calculate 'cover' dimensions ---
            const canvasRatio = w / h;
            const imageRatio = image.width / image.height;
            let destW, destH, destX, destY;
            if (imageRatio > canvasRatio) {
                destH = h; destW = h * imageRatio; destX = (w - destW) / 2; destY = 0;
            } else {
                destW = w; destH = w / imageRatio; destX = 0; destY = (h - destH) / 2;
            }

            // --- STEP A: Draw the blurred background ---
            targetCtx.save();
            if (blur > 0) {
                targetCtx.filter = `blur(${blur}px)`;
            }
            targetCtx.drawImage(image, destX, destY, destW, destH);
            targetCtx.restore(); // This removes the filter.

            // --- STEP B: Draw the clear, zoomed foreground ---
            targetCtx.save();
            
            // Create a clipping path for the frame
            targetCtx.beginPath();
            targetCtx.rect(frameX, frameY, frameW, frameH);
            targetCtx.clip();

            // Inside the clip, we want to draw the image zoomed.
            // We can do this by transforming the context.
            const centerX = frameX + frameW / 2;
            const centerY = frameY + frameH / 2;
            
            targetCtx.translate(centerX, centerY);
            targetCtx.scale(zoom, zoom);
            targetCtx.translate(-centerX, -centerY);
            
            // Now, draw the original 'covered' image. The clip and transform
            // will take care of showing only the correct zoomed portion.
            // This will draw over the blurred background inside the clipped area.
            targetCtx.drawImage(image, destX, destY, destW, destH);
            
            targetCtx.restore(); // Removes clip and transform

            // --- STEP C: Draw the border ---
            if (borderWidth > 0) {
                targetCtx.strokeStyle = borderColor;
                targetCtx.lineWidth = borderWidth;
                targetCtx.strokeRect(frameX, frameY, frameW, frameH);
            }
        }


        function getPolaroidFrameDetails(canvasW, canvasH) {
            const frameSpec = polaroidFrameSpecs[state.polaroid.frame];
            const margin = Math.min(canvasW, canvasH) * 0.1;
            const availableW = canvasW - 2 * margin;
            const availableH = canvasH - 2 * margin;

            let frameW, frameH;
            if (availableW / frameSpec.aspectRatio <= availableH) {
                frameW = availableW;
                frameH = frameW / frameSpec.aspectRatio;
            } else {
                frameH = availableH;
                frameW = frameH * frameSpec.aspectRatio;
            }
            
            const p = frameSpec.photoPadding || 0.05;
            const photoW = frameW * (1 - 2 * p);
            const photoH = photoW;
            const photoX = (canvasW - frameW) / 2 + frameW * p;
            const photoY = (canvasH - frameH) / 2 + frameW * p;

            return { frameW, frameH, photoX, photoY, photoW, photoH };
        }

        function drawPolaroidFrame(targetCtx, w, h, scale) {
            const frameSpec = polaroidFrameSpecs[state.polaroid.frame];
            if (!frameSpec) return;

            targetCtx.save();
            
            if (frameSpec.type === 'effect') {
                const margin = Math.min(w, h) * 0.05;
                const photoW = w - 2 * margin;
                const photoH = h - 2 * margin;
                const photoX = margin;
                const photoY = margin;

                drawRoundedImage(targetCtx, mainImage, photoX, photoY, photoW, photoH, 0, 'cover', state.imageOffset, state.polaroid.zoom / 100);
                
                targetCtx.strokeStyle = 'rgba(255,255,255,0.9)';
                targetCtx.lineWidth = margin * 0.05;
                targetCtx.strokeRect(photoX, photoY, photoW, photoH);

                targetCtx.fillStyle = frameSpec.effectColor;
                const holeW = photoW * 0.02;
                const holeH = photoH * 0.04;
                const holeMargin = holeW * 1.5;
                for (let i = photoY + holeMargin; i < photoY + photoH - holeMargin; i += holeH * 1.5) {
                    targetCtx.fillRect(photoX + holeMargin, i, holeW, holeH);
                    targetCtx.fillRect(photoX + photoW - holeMargin - holeW, i, holeW, holeH);
                }
                targetCtx.restore();
                return;
            }

            const margin = Math.min(w, h) * 0.1;
            const availableW = w - 2 * margin;
            const availableH = h - 2 * margin;

            let frameW, frameH;
            if (availableW / frameSpec.aspectRatio <= availableH) {
                frameW = availableW;
                frameH = frameW / frameSpec.aspectRatio;
            } else {
                frameH = availableH;
                frameW = frameH * frameSpec.aspectRatio;
            }

            const frameX = (w - frameW) / 2;
            const frameY = (h - frameH) / 2;
            
            targetCtx.translate(frameX + frameW / 2, frameY + frameH / 2);
            targetCtx.rotate(state.polaroid.rotation * Math.PI / 180);
            targetCtx.translate(-(frameX + frameW / 2), -(frameY + frameH / 2));

            targetCtx.shadowColor = 'rgba(0,0,0,0.4)';
            targetCtx.shadowBlur = 30 * scale;
            targetCtx.shadowOffsetX = 5 * scale;
            targetCtx.shadowOffsetY = 10 * scale;

            if (frameSpec.type === 'color') {
                targetCtx.fillStyle = state.polaroid.frameColor;
            } else if (frameSpec.type === 'pattern' && frameImageAssets[frameSpec.value] && frameImageAssets[frameSpec.value].complete) {
                targetCtx.fillStyle = targetCtx.createPattern(frameImageAssets[frameSpec.value], 'repeat');
            } else {
                targetCtx.fillStyle = frameSpec.value || '#ffffff';
            }
            targetCtx.fillRect(frameX, frameY, frameW, frameH);
            
            targetCtx.shadowColor = 'transparent';

            let photoX, photoY, photoW, photoH;
            const layout = frameSpec.layout || 'classic';

            if (layout === 'equal') {
                const p = 0.05;
                photoX = frameX + frameW * p;
                photoY = frameY + frameH * p;
                photoW = frameW * (1 - 2 * p);
                photoH = frameH * (1 - 2 * p);
            } else if (layout === 'top-heavy') {
                const pX = 0.05; const pTop = 0.25; const pBottom = 0.05;
                photoX = frameX + frameW * pX;
                photoY = frameY + frameH * pTop;
                photoW = frameW * (1 - 2 * pX);
                photoH = frameH - (frameH * pTop) - (frameH * pBottom);
            } else { // 'classic'
                const p = frameSpec.photoPadding;
                photoX = frameX + frameW * p;
                photoY = frameY + frameW * p;
                photoW = frameW * (1 - 2 * p);
                photoH = photoW;
            }
            
            targetCtx.fillStyle = '#1a202c';
            targetCtx.fillRect(photoX, photoY, photoW, photoH);
            drawRoundedImage(targetCtx, mainImage, photoX, photoY, photoW, photoH, 0, 'cover', state.imageOffset, state.polaroid.zoom / 100);

            if (frameSpec.type === 'special' && state.polaroid.frame === 'film-kare') {
                targetCtx.save();
                targetCtx.fillStyle = frameSpec.textColor;
                targetCtx.font = `bold ${frameW * 0.025}px 'Roboto Mono', monospace`;
                targetCtx.textAlign = 'center';
                targetCtx.textBaseline = 'middle';
                
                targetCtx.translate(photoX + photoW + (frameW - (photoX + photoW - frameX))/2, photoY + photoH / 2);
                targetCtx.rotate(Math.PI / 2);
                targetCtx.fillText('KODAK HITS', 0, 0);
                targetCtx.restore();

                targetCtx.save();
                targetCtx.translate(photoX - (photoX - frameX)/2, photoY + photoH / 2);
                targetCtx.rotate(-Math.PI / 2);
                targetCtx.fillText('KODAK HITS', 0, 0);
                targetCtx.restore();
            }

            if(state.polaroid.text) {
                targetCtx.fillStyle = frameSpec.textColor;
                targetCtx.font = `${frameW * 0.05}px 'Caveat', cursive`;
                targetCtx.textAlign = 'center';
                targetCtx.textBaseline = 'middle';
                const bottomEdgeOfPhoto = photoY + photoH;
                const bottomEdgeOfFrame = frameY + frameH;
                const spaceBelowPhoto = bottomEdgeOfFrame - bottomEdgeOfPhoto;
                if (spaceBelowPhoto > (frameW * 0.06)) {
                    const textY = bottomEdgeOfPhoto + spaceBelowPhoto / 2;
                    targetCtx.fillText(state.polaroid.text, frameX + frameW / 2, textY, frameW * 0.9);
                }
            }

            targetCtx.restore();
        }

        function drawCollageLayout(targetCtx, w, h, scale) {
            const p = { top: state.padding.top * scale, right: state.padding.right * scale, bottom: state.padding.bottom * scale, left: state.padding.left * scale };
            const gap = state.collage.gap * scale;
            const cornerRadius = state.collage.cornerRadius * scale;
            const area = { x: p.left, y: p.top, w: w - p.left - p.right, h: h - p.top - p.bottom };
            const layout = getCollageLayout(state.collage.layout, collageImages.length, area, gap);
            
            collageImages.slice(0, layout.length).forEach((img, i) => {
                const rect = layout[i];
                if (rect && rect.w > 0 && rect.h > 0) {
                    const offset = state.collage.imageOffsets[i] || { x: 0, y: 0 };
                    drawRoundedImage(targetCtx, img, rect.x, rect.y, rect.w, rect.h, cornerRadius, 'cover', offset);
                }
            });
        }
        
        function getCollageLayout(type, numImages, area, gap) {
            const rects = [];
            if (numImages === 0) return rects;
            const addRect = (x, y, w, h) => rects.push({ x: Math.round(x), y: Math.round(y), w: Math.round(w), h: Math.round(h) });

            if (type === 'auto') {
                if (numImages === 1) type = 'columns';
                else if (numImages === 2) type = 'columns';
                else if (numImages === 3) type = 'hero';
                else if (numImages === 4) type = 'grid';
                else if (numImages === 5) type = 'center-focus';
                else if (numImages === 6) type = 'pano';
                else type = 'grid';
            }

            switch (type) {
                case 'columns':
                    const colW = (area.w - (numImages - 1) * gap) / numImages;
                    for (let i=0; i<numImages; i++) { addRect(area.x + i * (colW + gap), area.y, colW, area.h); }
                    break;
                case 'rows':
                    const rowH = (area.h - (numImages - 1) * gap) / numImages;
                    for (let i=0; i<numImages; i++) { addRect(area.x, area.y + i * (rowH + gap), area.w, rowH); }
                    break;
                case 'grid':
                    const cols = numImages === 3 ? 3 : Math.ceil(Math.sqrt(numImages * (area.w / area.h)));
                    const rows = numImages === 3 ? 1 : Math.ceil(numImages / cols);
                    const cellW = (area.w - (cols - 1) * gap) / cols;
                    const cellH = (area.h - (rows - 1) * gap) / rows;
                    for (let i = 0; i < numImages; i++) {
                        const c = i % cols; const r = Math.floor(i / cols);
                        addRect(area.x + c * (cellW + gap), area.y + r * (cellH + gap), cellW, cellH);
                    }
                    break;
                 case 'hero':
                    if (numImages > 1) {
                        const heroW = area.w * 0.66 - gap / 2;
                        addRect(area.x, area.y, heroW, area.h);
                        const sideCount = numImages - 1;
                        const thumbW = area.w - heroW - gap;
                        const thumbH = (area.h - (sideCount - 1) * gap) / sideCount;
                        for (let i = 0; i < sideCount; i++) {
                            addRect(area.x + heroW + gap, area.y + i * (thumbH + gap), thumbW, thumbH);
                        }
                    } else { addRect(area.x, area.y, area.w, area.h); }
                    break;
                case 'center-focus':
                    if (numImages === 1) { addRect(area.x, area.y, area.w, area.h); }
                    else if (numImages === 2) { const h = (area.h - gap)/2; addRect(area.x, area.y, area.w, h); addRect(area.x, area.y+h+gap, area.w, h); }
                    else {
                        const centerW = area.w * 0.5; const centerH = area.h * 0.5;
                        addRect(area.x + area.w * 0.25, area.y + area.h * 0.25, centerW, centerH);
                        const others = numImages - 1;
                        if (others > 0) {
                            const sideW = area.w * 0.25 - gap / 2;
                            const sideH = (area.h - (Math.ceil(others/2)-1) * gap) / Math.ceil(others/2);
                            for (let i=0; i < others; i++) {
                                if(i < Math.ceil(others/2)) addRect(area.x, area.y + i*(sideH+gap), sideW, sideH);
                                else addRect(area.x + area.w - sideW, area.y + (i-Math.ceil(others/2))*(sideH+gap), sideW, sideH);
                            }
                        }
                    }
                    break;
                case 'overlap':
                    for (let i = 0; i < numImages; i++) {
                        const overlapX = (i * 50); const overlapY = (i * 30);
                        const w = area.w - (numImages-1)*50; const h = area.h - (numImages-1)*30;
                        addRect(area.x + overlapX, area.y + overlapY, w, h);
                    }
                    break;
                case 'diagonal':
                    if (numImages === 1) { addRect(area.x, area.y, area.w, area.h); break; }
                    let x = area.x, y = area.y;
                    const w = (area.w - (numImages-1) * gap) / numImages;
                    const h = (area.h - (numImages-1) * gap) / numImages;
                    for (let i = 0; i < numImages; i++) {
                        addRect(x, y, w, h);
                        x += w + gap; y += h + gap;
                    }
                    break;
                case 'three-stack':
                    if (numImages === 1) { addRect(area.x, area.y, area.w, area.h); }
                    else if (numImages === 2) { const h = (area.h-gap)/2; addRect(area.x, area.y, area.w, h); addRect(area.x, area.y+h+gap, area.w, h); }
                    else { const h1 = area.h/2 - gap/2; const h2 = area.h/2 - gap/2; const w = (area.w - gap)/2; addRect(area.x, area.y, area.w, h1); addRect(area.x, area.y+h1+gap, w, h2); addRect(area.x+w+gap, area.y+h1+gap, w, h2); }
                    break;
                case 'pano':
                    if (numImages > 1) {
                        const panoH = area.h * 0.6 - gap / 2;
                        addRect(area.x, area.y, area.w, panoH);
                        const sideCount = numImages - 1;
                        const thumbH = area.h - panoH - gap;
                        const thumbW = (area.w - (sideCount - 1) * gap) / sideCount;
                        for (let i = 0; i < sideCount; i++) {
                            addRect(area.x + i * (thumbW + gap), area.y + panoH + gap, thumbW, thumbH);
                        }
                    } else { addRect(area.x, area.y, area.w, area.h); }
                    break;
                case 'mosaic':
                    if (numImages === 1) { addRect(area.x, area.y, area.w, area.h); }
                    else if (numImages === 2) { if(area.w > area.h) { const w = (area.w-gap)/2; addRect(area.x, area.y, w, area.h); addRect(area.x + w + gap, area.y, w, area.h); } else { const h = (area.h-gap)/2; addRect(area.x, area.y, area.w, h); addRect(area.x, area.y + h + gap, area.w, h); } } 
                    else if (numImages === 3) { if(area.w > area.h) { const w1=area.w*0.66-gap/2; const w2=area.w*0.33-gap/2; addRect(area.x, area.y, w1, area.h); addRect(area.x+w1+gap, area.y, w2, area.h/2-gap/2); addRect(area.x+w1+gap, area.y+area.h/2+gap/2, w2, area.h/2-gap/2); } else { const h1=area.h*0.66-gap/2; const h2=area.h*0.33-gap/2; addRect(area.x, area.y, area.w, h1); addRect(area.x, area.y+h1+gap, area.w/2-gap/2, h2); addRect(area.x+w2+gap/2, area.y+h1+gap, area.w/2-gap/2, h2); } }
                    else { const cols = Math.ceil(Math.sqrt(numImages)); const rows = Math.ceil(numImages / cols); const cellW = (area.w - (cols-1)*gap)/cols; const cellH = (area.h - (rows-1)*gap)/rows; for (let i = 0; i < numImages; i++) { const c=i%cols; const r=Math.floor(i/cols); addRect(area.x+c*(cellW+gap), area.y+r*(cellH+gap), cellW, cellH); } }
                    break;
                default:
                    const def_cols = numImages > 4 ? Math.ceil(Math.sqrt(numImages)) : (numImages > 1 ? 2 : 1);
                    const def_rows = Math.ceil(numImages / def_cols);
                    const cellW_def = (area.w - (def_cols - 1) * gap) / def_cols;
                    const cellH_def = (area.h - (def_rows - 1) * gap) / def_rows;
                    for (let i = 0; i < numImages; i++) { const c = i % def_cols; const r = Math.floor(i / def_cols); addRect(area.x + c * (cellW_def + gap), area.y + r * (cellH_def + gap), cellW_def, cellH_def); }
                    break;
            }
            return rects;
        }
        
        function drawRoundedImage(ctx, img, x, y, w, h, r, fit = 'contain', offset = { x: 0, y: 0 }, zoom = 1) {
            ctx.save();
            if (r > 0) {
                ctx.beginPath();
                ctx.moveTo(x + r, y); ctx.arcTo(x + w, y, x + w, y + h, r); ctx.arcTo(x + w, y + h, x, y + h, r); ctx.arcTo(x, y + h, x, y, r); ctx.arcTo(x, y, x + w, y, r);
                ctx.closePath();
                ctx.clip();
            }
            
            let sX = 0, sY = 0, sW = img.width, sH = img.height;
            if (fit === 'cover') {
                const imgRatio = img.width / img.height;
                const areaRatio = w / h;
                if (imgRatio > areaRatio) {
                    sH = img.height;
                    sW = sH * areaRatio;
                } else {
                    sW = img.width;
                    sH = sW / areaRatio;
                }

                sW /= zoom;
                sH /= zoom;
                
                sX = (img.width - sW) / 2 + (offset.x || 0);
                sY = (img.height - sH) / 2 + (offset.y || 0);
            }
            
            ctx.drawImage(img, sX, sY, sW, sH, x, y, w, h);
            ctx.restore();
        }

        function drawTextAndWatermark(targetCtx, w, h, scale = 1) {
            targetCtx.save();
            const margin = 20 * scale;
            if (state.text.content) {
                targetCtx.fillStyle = state.text.color;
                targetCtx.font = `bold ${state.text.size * scale}px ${state.text.font}`;
                targetCtx.textAlign = 'center';
                let x = w / 2, y;
                if (state.text.position.includes('top')) y = margin;
                else if (state.text.position.includes('bottom')) y = h - margin;
                else y = h / 2;
                if (state.text.position.includes('left')) { targetCtx.textAlign = 'left'; x = margin; }
                else if (state.text.position.includes('right')) { targetCtx.textAlign = 'right'; x = w - margin; }
                if (state.text.position.includes('top')) targetCtx.textBaseline = 'top';
                else if (state.text.position.includes('bottom')) targetCtx.textBaseline = 'bottom';
                else targetCtx.textBaseline = 'middle';
                targetCtx.shadowColor = 'rgba(0,0,0,0.5)'; targetCtx.shadowBlur = 5; targetCtx.shadowOffsetX = 2; targetCtx.shadowOffsetY = 2;
                targetCtx.fillText(state.text.content, x, y);
            }
            if (watermarkImage) {
                targetCtx.globalAlpha = state.watermark.opacity / 100;
                const wmRatio = watermarkImage.width / watermarkImage.height;
                const wmSize = (w * (state.watermark.size / 100));
                const wmWidth = wmSize; const wmHeight = wmWidth / wmRatio;
                let x, y;
                if (state.watermark.position.includes('left')) x = margin;
                else if (state.watermark.position.includes('right')) x = w - wmWidth - margin;
                else x = (w - wmWidth) / 2;
                if (state.watermark.position.includes('top')) y = margin;
                else if (state.watermark.position.includes('bottom')) y = h - wmHeight - margin;
                else y = (h - wmHeight) / 2;
                targetCtx.drawImage(watermarkImage, x, y, wmWidth, wmHeight);
            }
            targetCtx.restore();
        }

        function downloadImage() {
            downloadBtn.disabled = true;
            downloadBtn.textContent = 'Oluşturuluyor...';
            setTimeout(() => {
                const tempCanvas = document.createElement('canvas');
                const tempCtx = tempCanvas.getContext('2d');
                const qualityMultiplier = 2.5;
                const preset = presets[state.sizePreset];
                
                if (state.mode === 'magnify' && mainImage) {
                    if (!preset) {
                        showToast("Lütfen bir kanvas boyutu seçin.", "error");
                        downloadBtn.disabled = false;
                        downloadBtn.textContent = 'İndir';
                        return;
                    }
                    tempCanvas.width = preset.width * qualityMultiplier;
                    tempCanvas.height = preset.height * qualityMultiplier;

                    const scaleX = tempCanvas.width / canvas.width;
                    const scaleY = tempCanvas.height / canvas.height;

                    const renderMagnifyState = {
                        ...state.magnify,
                        frameX: state.magnify.frameX * scaleX,
                        frameY: state.magnify.frameY * scaleY,
                        frameW: state.magnify.frameW * scaleX,
                        frameH: state.magnify.frameH * scaleY,
                        borderWidth: state.magnify.borderWidth * Math.min(scaleX, scaleY),
                        blur: state.magnify.blur * Math.min(scaleX, scaleY)
                    };
                    
                    drawMagnifyEffectOnContext(tempCtx, tempCanvas.width, tempCanvas.height, mainImage, renderMagnifyState);

                } else if (preset) {
                    tempCanvas.width = preset.width * qualityMultiplier;
                    tempCanvas.height = preset.height * qualityMultiplier;
                    tempCtx.clearRect(0, 0, tempCanvas.width, tempCanvas.height);
                    drawBackground(tempCtx, tempCanvas.width, tempCanvas.height);
                    drawMainContent(tempCtx, tempCanvas.width, tempCanvas.height, qualityMultiplier);
                    if (state.mode !== 'polaroid') {
                        drawTextAndWatermark(tempCtx, tempCanvas.width, tempCanvas.height, qualityMultiplier);
                    }
                } else if (state.sizePreset === 'original' && mainImage && state.mode === 'single') {
                    tempCanvas.width = (mainImage.width + state.padding.left + state.padding.right) * qualityMultiplier;
                    tempCanvas.height = (mainImage.height + state.padding.top + state.padding.bottom) * qualityMultiplier;
                    tempCtx.clearRect(0, 0, tempCanvas.width, tempCanvas.height);
                    drawBackground(tempCtx, tempCanvas.width, tempCanvas.height);
                    drawMainContent(tempCtx, tempCanvas.width, tempCanvas.height, qualityMultiplier);
                    drawTextAndWatermark(tempCtx, tempCanvas.width, tempCanvas.height, qualityMultiplier);
                } else {
                     downloadBtn.disabled = false;
                     downloadBtn.textContent = 'İndir';
                     return;
                }

                const link = document.createElement('a');
                link.href = tempCanvas.toDataURL('image/png', 1.0);
                link.download = `${originalFileName}-${state.mode}-duzenlenmis.png`;
                link.click();
                downloadBtn.disabled = false;
                downloadBtn.textContent = 'İndir';
            }, 100);
        }
        
        function initDB() {
            const request = indexedDB.open('PhotoEditorDB', 1);
            request.onerror = (e) => console.error("Veritabanı hatası:", e.target.errorCode);
            request.onsuccess = (e) => { db = e.target.result; };
            request.onupgradeneeded = (e) => {
                const store = e.target.result.createObjectStore('projects', { keyPath: 'id', autoIncrement: true });
                store.createIndex('name', 'name', { unique: false });
            };
        }

        async function saveProject() {
            if (!db) { showToast("Veritabanı hazır değil.", "error"); return; }
            const projectName = prompt("Projenize bir isim verin:", "Yeni Projem " + new Date().toLocaleDateString());
            if (!projectName) return;
            const imageToBlob = async (img) => {
                if (!img || !img.src) return null;
                 if (img.src.startsWith('blob:')) return fetch(img.src).then(r => r.blob());
                return await fetch(img.src).then(r => r.blob());
            };
            syncStateWithUI();
            const projectData = {
                name: projectName,
                state: state,
                mainImage: await imageToBlob(mainImage),
                collageImages: await Promise.all(collageImages.map(img => imageToBlob(img))),
                watermarkImage: await imageToBlob(watermarkImage),
                savedAt: new Date()
            };
            const transaction = db.transaction(['projects'], 'readwrite');
            transaction.oncomplete = () => showToast(`'${projectName}' projesi kaydedildi!`);
            transaction.onerror = (e) => { console.error("Kaydetme hatası:", e.target.error); showToast("Proje kaydedilemedi.", "error"); };
            transaction.objectStore('projects').add(projectData);
        }

        async function showProjectsModal() {
            if (!db) { showToast("Veritabanı hazır değil.", "error"); return; }
            projectsModal.classList.remove('hidden');
            document.body.style.overflow = 'hidden';
            projectsModal.querySelector('.modal-content').classList.remove('scale-95');
            const store = db.transaction(['projects'], 'readonly').objectStore('projects');
            const request = store.getAll();
            request.onerror = (e) => console.error("Projeler yüklenemedi:", e.target.error);
            request.onsuccess = () => {
                const projects = request.result.sort((a, b) => new Date(b.savedAt) - new Date(a.savedAt));
                projectListContainer.innerHTML = projects.length === 0 ? `<p class="text-center text-gray-400">Kaydedilmiş proje bulunamadı.</p>` : '';
                projects.forEach(p => {
                    let previewUrl = 'https://placehold.co/100x75/4a5568/ffffff?text=O%CC%88nizleme';
                    if (p.mainImage) previewUrl = URL.createObjectURL(p.mainImage);
                    else if (p.collageImages && p.collageImages.length > 0) previewUrl = URL.createObjectURL(p.collageImages[0]);
                    const projectEl = document.createElement('div');
                    projectEl.className = 'glass-card flex items-center p-4 rounded-lg mb-4 hover:bg-white/10 transition-colors duration-200';
                    projectEl.innerHTML = `
                        <img src="${previewUrl}" class="w-24 h-24 object-cover rounded-md mr-4 bg-gray-700" onload="URL.revokeObjectURL(this.src)">
                        <div class="flex-grow">
                            <h3 class="font-bold text-lg text-white">${p.name}</h3>
                            <p class="text-sm text-gray-300">${new Date(p.savedAt).toLocaleString('tr-TR')}</p>
                        </div>
                        <div class="flex flex-col gap-2">
                            <button data-id="${p.id}" class="load-btn bg-sky-600 text-white px-4 py-2 rounded-md hover:bg-sky-700">Yükle</button>
                            <button data-id="${p.id}" class="delete-btn bg-red-600 text-white px-4 py-2 rounded-md hover:bg-red-700">Sil</button>
                        </div>
                    `;
                    projectListContainer.appendChild(projectEl);
                });
            };
        }
        
        projectListContainer.addEventListener('click', (e) => {
            const id = e.target.dataset.id;
            if (!id) return;
            if (e.target.classList.contains('load-btn')) { loadProjectById(parseInt(id)); } 
            else if (e.target.classList.contains('delete-btn')) {
                 if (window.confirm("Bu projeyi silmek istediğinizden emin misiniz? Bu işlem geri alınamaz.")) {
                     deleteProjectById(parseInt(id));
                 }
            }
        });

        function hideProjectsModal() {
            projectsModal.querySelector('.modal-content').classList.add('scale-95');
            projectsModal.classList.add('hidden');
            document.body.style.overflow = 'auto';
        }

        async function loadProjectById(id) {
            const request = db.transaction(['projects'], 'readonly').objectStore('projects').get(id);
            request.onerror = (e) => console.error("Proje yüklenemedi:", e.target.error);
            request.onsuccess = () => {
                const pData = request.result;
                if (!pData) return;
                state = { ...getDefaultState(), ...pData.state };
                history = []; historyIndex = -1;
                saveStateToHistory();

                const blobToImage = (blob) => !blob ? Promise.resolve(null) : new Promise(resolve => {
                    const img = new Image();
                    img.onload = () => resolve(img);
                    img.onerror = () => resolve(null);
                    img.src = URL.createObjectURL(blob);
                });
                
                Promise.all([
                    blobToImage(pData.mainImage),
                    Promise.all((pData.collageImages || []).map(b => blobToImage(b))),
                    blobToImage(pData.watermarkImage)
                ]).then(([loadedMain, loadedCollage, loadedWatermark]) => {
                    mainImage = loadedMain;
                    collageImages = loadedCollage;
                    watermarkImage = loadedWatermark;
                    
                    if (state.mode === 'collage' && (!state.collage.imageOffsets || state.collage.imageOffsets.length !== collageImages.length)) {
                        state.collage.imageOffsets = collageImages.map(() => ({ x: 0, y: 0 }));
                    }

                    updateUIFromState(state);
                    const hasImage = mainImage || (state.mode === 'collage' && collageImages.length > 0);
                    if(hasImage) {
                        previewPlaceholder.classList.add('hidden');
                        canvasWrapper.style.display = 'flex';
                        canvasWrapper.classList.remove('hidden');
                        if (state.mode === 'collage') displayCollageThumbnails();
                    }
                    if(watermarkImage) {
                         document.getElementById('watermarkControls').classList.remove('hidden');
                    } else {
                         document.getElementById('watermarkControls').classList.add('hidden');
                         document.getElementById('watermarkLoader').value = '';
                    }
                    
                    updateAndDraw();
                    hideProjectsModal();
                    showToast(`'${pData.name}' projesi yüklendi.`);
                });
            };
        }

        function deleteProjectById(id) {
            const request = db.transaction(['projects'], 'readwrite').objectStore('projects').delete(id);
            request.onsuccess = () => {
                showToast("Proje silindi.", "info");
                showProjectsModal();
            };
            request.onerror = (e) => {
                console.error("Silme hatası:", e.target.error);
                showToast("Proje silinemedi.", "error");
            };
        }
        
        function showToast(message, type = 'success') {
            const toast = document.getElementById('toast');
            const toastMessage = document.getElementById('toastMessage');
            toastMessage.textContent = message;
            toast.className = 'px-6 py-3 text-white font-semibold rounded-lg shadow-lg z-50';
            if(type === 'success') toast.classList.add('bg-emerald-500');
            else if (type === 'error') toast.classList.add('bg-red-500');
            else if (type === 'info') toast.classList.add('bg-sky-500');
            toast.classList.add('show');
            setTimeout(() => { toast.classList.remove('show'); }, 3000);
        }
        
        function preloadFrameAssets() {
            for (const key in polaroidFrameSpecs) {
                const spec = polaroidFrameSpecs[key];
                if (spec.type === 'pattern') {
                    const img = new Image();
                    img.crossOrigin = "Anonymous";
                    img.src = spec.value;
                    img.onload = () => updateAndDraw();
                    frameImageAssets[spec.value] = img;
                }
            }
        }

        function populatePolaroidFrames() {
            polaroidFrameContainer.innerHTML = '';
            for (const key in polaroidFrameSpecs) {
                const spec = polaroidFrameSpecs[key];
                const button = document.createElement('button');
                button.className = 'frame-btn rounded-lg p-1';
                button.dataset.frame = key;
                
                const preview = document.createElement('div');
                preview.className = 'frame-preview flex items-center justify-center rounded-sm';
                if (spec.type === 'pattern') {
                    preview.style.backgroundImage = `url(${spec.value})`;
                } else {
                    preview.style.backgroundColor = spec.defaultColor || spec.value || '#ccc';
                }
                
                const imgPlaceholder = document.createElement('div');
                imgPlaceholder.className = 'frame-preview-img';
                
                const span = document.createElement('span');
                span.className = 'text-xs mt-1 block text-gray-200';
                span.textContent = spec.name;
                
                preview.appendChild(imgPlaceholder);
                button.appendChild(preview);
                button.appendChild(span);
                polaroidFrameContainer.appendChild(button);
            }
        }

        function init() {
            initDB();
            populatePolaroidFrames();
            preloadFrameAssets();
            state = getDefaultState();
            updateUIFromState(state);
            updateAndDraw();
            saveStateToHistory();
            setupEventListeners();
        }
        
        window.onload = init;
    </script>
</body>
</html>
